<!DOCTYPE html>
<html lang="az">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Durak - Kart Oyunu</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.1/signalr.min.js"></script>
    <link rel="stylesheet" href="./Durak.css">
</head>

<body>
    <div class="messages" id="messages"></div>

    <div class="container">
        <div class="header">
            <button class="back-btn" onclick="backToGames()">
                ‚Üê
            </button>
            <h1 class="header-title">DURAK</h1>
            <div class="user-info" id="userInfo">
                <span id="userBalance">0</span>
            </div>
        </div>

        <!-- Lobby Screen -->
        <div class="lobby-screen" id="lobbyScreen">
            <div class="player-select-section">
                <!-- <h2>‚ö° Oyun N√∂v√º Se√ßin</h2> -->
                <div class="player-options">
                    <div class="player-option" data-count="2" onclick="selectPlayerCount(2)">
                        <div class="player-count">2</div>
                        <div class="player-label">Oyun√ßu</div>
                    </div>
                    <div class="player-option" data-count="3" onclick="selectPlayerCount(3)">
                        <div class="player-count">3</div>
                        <div class="player-label">Oyun√ßu</div>
                    </div>
                    <div class="player-option" data-count="4" onclick="selectPlayerCount(4)">
                        <div class="player-count">4</div>
                        <div class="player-label">Oyun√ßu</div>
                    </div>
                    <div class="player-option" data-count="6" onclick="selectPlayerCount(6)">
                        <div class="player-count">6</div>
                        <div class="player-label">Oyun√ßu</div>
                    </div>
                </div>
            </div>

            <!-- Room options panel (deck size, bet, modes, start) -->
            <div class="room-options-panel" id="roomOptionsPanel" style="display:none;">
                <h2>Otaq Parametrl…ôri</h2>
                <div class="deck-size-row">
                    <div class="deck-pill" data-size="24" onclick="toggleDeckSize(24)">24</div>
                    <div class="deck-pill selected" data-size="36" onclick="toggleDeckSize(36)">36</div>
                    <div class="deck-pill" data-size="52" onclick="toggleDeckSize(52)">52</div>
                </div>

                <div class="bet-row">
                    <label>Bet se√ßimi</label>
                    <div class="bet-presets">
                        <button class="bet-btn" onclick="selectBet(0.2)">0.2</button>
                        <button class="bet-btn" onclick="selectBet(0.5)">0.5</button>
                        <button class="bet-btn" onclick="selectBet(1)">1</button>
                        <button class="bet-btn" onclick="selectBet(2)">2</button>
                        <button class="bet-btn" onclick="selectBet(5)">5</button>
                        <button class="bet-btn" onclick="selectBet(10)">10</button>
                        <button class="bet-btn" onclick="selectBet(20)">20</button>
                        <button class="bet-btn" onclick="selectBet(50)">50</button>
                        <button class="bet-btn" onclick="selectBet(100)">100</button>
                    </div>
                </div>

                <div class="modes-row">
                    <label>Oyun rejiml…ôri</label>
                    <div class="modes-grid">
                        <div class="mode-col">
                            <!-- <div class="mode-title">S√ºtun 1</div> -->
                            <div class="mode-card selected" data-col="1" data-value="atilan"
                                onclick="selectMode(1,'atilan')">atƒ±lan</div>
                            <div class="mode-card" data-col="1" data-value="pas" onclick="selectMode(1,'pas')">pas</div>
                        </div>
                        <div class="mode-col">
                            <!-- <div class="mode-title">S√ºtun 2</div> -->
                            <div class="mode-card selected" data-col="2" data-value="qonsular"
                                onclick="selectMode(2,'qonsular')">qon≈üular </div>
                            <div class="mode-card" data-col="2" data-value="hamisi" onclick="selectMode(2,'hamisi')">
                                hamƒ±sƒ±</div>
                        </div>
                    </div>
                </div>

                <div class="start-row">
                    <button class="btn btn-success" onclick="startMatch()">Ba≈üla</button>
                    <button class="btn btn-sm" onclick="goBackToPlayerSelect()">‚Üê Geri</button>
                </div>
            </div>

            <div class="quick-rooms-section" id="roomsSection" style="display:none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="margin: 0;">üéÆ Hazƒ±r Otaqlar</h2>
                    <button class="btn btn-sm" onclick="goBackToPlayerSelect()"
                        style="width: auto; padding: 10px 20px;">
                        ‚Üê Geri
                    </button>
                </div>
                <p style="opacity: 0.8; margin-bottom: 20px;">A≈üaƒüƒ±dakƒ± otaqlardan birin…ô qo≈üulun</p>
                <div class="rooms-grid" id="quickRoomsList">
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>Otaqlar y√ºkl…ônir...</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Game Screen -->
        <div class="game-screen" id="gameScreen">
            <div class="game-container">
                <div class="game-header">
                    <div class="game-info">
                        <div class="info-item">
                            <div class="label">M√ºkafat Fondu</div>
                            <div class="value" id="totalPrize">0 AZN</div>
                        </div>
                        <div class="info-item">
                            <div class="label">Otaq</div>
                            <div class="value" id="currentRoomName">-</div>
                        </div>
                        <div class="info-item">
                            <div class="label">G√∂y…ôrt…ôd…ô</div>
                            <div class="value" id="deckCount">36</div>
                        </div>
                    </div>
                    <div class="game-actions">
                        <button class="btn btn-sm btn-success hidden" id="beatenBtn">‚úÖ Beaten</button>
                        <button class="btn btn-sm btn-danger hidden" id="takeCardsBtn">üì• Kartlarƒ± G√∂t√ºr</button>
                        <button class="btn btn-sm btn-danger" id="leaveRoomBtn">Otaqdan √áƒ±x</button>
                    </div>
                </div>

                <div class="players-section" id="playersSection"></div>

                <div class="game-table" id="gameTable">
                    <div class="trump-card-display" id="trumpDisplay">
                        <div class="deck-stack" id="deckStack">
                            <div class="deck-card"></div>
                            <div class="deck-card"></div>
                            <div class="deck-card"></div>
                            <div class="deck-count" id="deckCountDisplay">24</div>
                        </div>

                        <div class="trump-label">Koz:</div>
                        <div id="trumpCardContainer"></div>
                    </div>
                    <div class="table-cards" id="tableCards">
                        <div class="empty-hand">Masa bo≈üdur</div>
                    </div>
                </div>

                <!-- <div class="quick-messages-section">
                    <div style="text-align: center; margin-bottom: 15px; font-weight: 600;">Tez Mesajlar:</div>
                    <div class="quick-messages-grid">
                        <button class="quick-msg-btn" onclick="sendQuickMsg('üëç', 'Yax≈üƒ±!')">üëç Yax≈üƒ±</button>
                        <button class="quick-msg-btn" onclick="sendQuickMsg('üòÇ', 'G√ºlm…ôli!')">üòÇ G√ºlm…ôli</button>
                        <button class="quick-msg-btn" onclick="sendQuickMsg('üî•', 'Super!')">üî• Super</button>
                        <button class="quick-msg-btn" onclick="sendQuickMsg('üòé', 'Cool!')">üòé Cool</button>
                        <button class="quick-msg-btn" onclick="sendQuickMsg('üí™', 'G√ºcl√º!')">üí™ G√ºcl√º</button>
                        <button class="quick-msg-btn" onclick="sendQuickMsg('üò¢', 'Pis!')">üò¢ Pis</button>
                        <button class="quick-msg-btn" onclick="sendQuickMsg('üéØ', 'D…ôqiq!')">üéØ D…ôqiq</button>
                        <button class="quick-msg-btn" onclick="sendQuickMsg('‚ö°', 'S√ºr…ôtli!')">‚ö° S√ºr…ôtli</button>
                    </div>
                </div> -->

                <div class="player-hand">
                    <div class="player-hand-title">Sizin Kartlarƒ±nƒ±z</div>
                    <div class="cards-container" id="playerCards">
                        <div class="empty-hand">Kartlarƒ±nƒ±z y√ºkl…ônir...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>

        let currentUserToken = null;
        let currentUserData = null;

        console.log('üÉè [DURAK] Script y√ºkl…ôndi');

        window.addEventListener('message', (event) => {
            console.log('üì® [DURAK] Message alƒ±ndƒ±:', event.data);

            if (event.data && event.data.type === 'INIT_USER') {
                console.log('‚úÖ [DURAK] INIT_USER q…ôbul edildi');

                currentUserData = event.data.payload;
                currentUserToken = currentUserData.token;

                console.log('üë§ [DURAK] User:', currentUserData.username);
                console.log('üé´ [DURAK] Token:', currentUserToken ? 'VAR' : 'YOX');

                // UI-ƒ± yenil…ô
                document.getElementById('userBalance').textContent = currentUserData.balance;

                console.log('üöÄ [DURAK] init() √ßaƒüƒ±rƒ±lƒ±r...');
                // SignalR ba≈ülat
                init();
            }
        });

        // ============================================
        // getToken funksiyasƒ±nƒ± d…ôyi≈üdir
        // ============================================
        function getToken() {
            return currentUserToken || "";
        }

        // ============================================
        // Qalan kod eyni qalƒ±r
        // ============================================

        // M√∂vcud connection, currentUser v…ô s. d…ôyi≈ü…ônl…ôr...
        const connection = new signalR.HubConnectionBuilder()
            .withUrl("https://nehemiah-paginal-alan.ngrok-free.dev/durakHub", { accessTokenFactory: () => getToken() })
            .withAutomaticReconnect()
            .build();


        let currentUser = null;
        let currentRoom = null;
        let myCards = [];
        let gameState = null;
        let selectedPlayerCount = 0;
        let selectedDeckSize = 36;
        let selectedBet = 0;
        // modes: enforce exactly one per column
        let selectedModes = { col1: 'atilan', col2: 'qonsular' };
        let draggedCard = null;

        const suitIcons = {
            'Hearts': '‚ô•',
            'Diamonds': '‚ô¶',
            'Clubs': '‚ô£',
            'Spades': '‚ô†'
        };

        const rankNames = {
            '2': '2', '3': '3', '4': '4', '5': '5',
            '6': '6', '7': '7', '8': '8', '9': '9', '10': '10',
            'Jack': 'J', 'Queen': 'Q', 'King': 'K', 'Ace': 'A'
        };

        // ‚úÖ init() funksiyasƒ±nƒ± sad…ôl…ô≈üdir
        async function init() {
            console.log('üöÄ [DURAK] init() ba≈üladƒ±');

            if (!currentUserToken) {
                console.error('‚ùå [DURAK] Token yoxdur!');
                return;
            }

            try {
                await connection.start();
                console.log("‚úÖ [DURAK] SignalR qo≈üuldu");
            } catch (err) {
                console.error("‚ùå [DURAK] SignalR x…ôtasƒ±:", err);
                showMessage("Server…ô qo≈üulmaq alƒ±nmadƒ±", "error");
            }
        }


        // ... suitIcons, rankNames v…ô s. ...



        // ... qalan b√ºt√ºn kod eyni qalƒ±r (setupEventHandlers v…ô s.) ...
        // ‚úÖ YENƒ∞ - Transfer event
        connection.on("AttackTransferred", (data) => {
            showMessage(`üîÑ ${data.playerName} transfer etdi ‚Üí ${data.newDefender}`, "info");
            console.log('üîÑ Transfer:', data);
        });
        // ‚úÖ YENƒ∞ - Player Vote notification
        connection.on("PlayerVoted", (data) => {
            showVoteNotification(data);
        });
        // ‚ùå Sƒ∞L - connection.on("UserData") event handler-ini d…ôyi≈üdir:
        connection.on("UserData", (data) => {
            currentUser = data;
            console.log('üë§ [DURAK] UserData event:', data);

            // ‚úÖ Artƒ±q React-d…ôn aldƒ±q, yenid…ôn yazmƒ±rƒ±q
            // document.getElementById("userName").textContent = data.fullName;

            document.getElementById("lobbyScreen").style.display = "block";

            // URL parametrind…ôn player count yoxla
            const urlParams = new URLSearchParams(window.location.search);
            const playersParam = urlParams.get('players');
            if (playersParam && ['2', '3', '4', '6'].includes(playersParam)) {
                selectPlayerCount(parseInt(playersParam));
            }
        });


        connection.on("RefundProcessed", (data) => {
            showMessage(data.message, "success");
            console.log('üí∏ Refund:', data.amount, 'AZN');
        });

        connection.on("JoinedRoom", (data) => {
            currentRoom = data;
            document.getElementById("currentRoomName").textContent = data.roomName;
            document.getElementById("lobbyScreen").style.display = "none";
            document.getElementById("gameScreen").style.display = "block";

            document.getElementsByClassName("header")[0].style.display = "none";

            let message = `${data.roomName} otaƒüƒ±na qo≈üuldunuz`;
            if (data.entryFee > 0) {
                message += ` (Giri≈ü haqqƒ±: ${data.entryFee} AZN)`;
            }
            showMessage(message, "success");
        });

        connection.on("PlayerJoined", (playerName) => {
            showMessage(`${playerName} oyuna qo≈üuldu`, "info");
        });

        connection.on("PlayerLeft", (playerName) => {
            showMessage(`${playerName} oyunu t…ôrk etdi`, "info");
        });

        connection.on("GameStarted", (data) => {
            showMessage("Oyun ba≈üladƒ±! üéÆ", "success");
            renderTrumpCard(data.trumpCard);
        });

        connection.on("YourCards", (cards) => {
            myCards = cards;
            renderPlayerCards();
        });

        connection.on("GameState", (state) => {
            gameState = state;
            console.log('üéÆ GAME STATE UPDATED:', state);

            renderPlayers(state.players);
            renderTableCards(state);

            document.getElementById("deckCount").textContent = state.deckCount;
            document.getElementById("deckCountDisplay").textContent = state.deckCount;

            // ‚úÖ YENƒ∞ - Deck size v…ô transfer info
            if (state.deckSize) {
                document.getElementById("deckSizeInfo").textContent = `${state.deckSize} kart`;
            }

            if (state.transferEnabled !== undefined) {
                const transferBadge = document.getElementById("transferInfo");
                if (state.transferEnabled) {
                    transferBadge.textContent = "Transfer ‚úì";
                    transferBadge.classList.remove('disabled');
                } else {
                    transferBadge.textContent = "Transfer ‚úó";
                    transferBadge.classList.add('disabled');
                }
            }

            const deckStack = document.getElementById("deckStack");
            if (state.deckCount === 0) {
                deckStack.style.display = 'none';
            } else {
                deckStack.style.display = 'block';
            }

            if (state.totalPrize > 0) {
                document.getElementById("totalPrize").textContent = `${state.totalPrize} AZN`;
            }

            if (myCards.length > 0) {
                renderPlayerCards();
            }

            updateActionButtons(state);
        });

        connection.on("CardsAttacked", (data) => {
            showMessage(`${data.playerName} h√ºcum etdi`, "info");
        });

        connection.on("CardsDefended", (data) => {
            showMessage(`${data.playerName} m√ºdafi…ô etdi`, "success");
        });

        connection.on("CardsTaken", (data) => {
            showMessage(`${data.playerName} kartlarƒ± g√∂t√ºrd√º`, "warning");
        });

        connection.on("CardsDiscarded", () => {
            showMessage("Kartlar yandƒ±rƒ±ldƒ± üî•", "success");
        });

        connection.on("GameOver", (data) => {
            showMessage(data.message, "info");

            let alertMessage = data.message;
            if (data.winnerPrize) {
                alertMessage += `\n\nüí∞ M√ºkafat: ${data.winnerPrize} AZN`;
                alertMessage += `\nüìä Komissiya: ${data.commission} AZN`;
            }

            if (data.canRematch) {
                alertMessage += `\n\nüîÑ Yenid…ôn oynamaq ist…ôyirsiniz?`;
                if (data.entryFee > 0) {
                    alertMessage += `\n(Giri≈ü haqqƒ±: ${data.entryFee} AZN)`;
                }
            }

            alert(alertMessage);

            if (data.canRematch) {
                showRematchUI(data.entryFee);
            }
        });

        connection.on("RematchVote", (data) => {
            showMessage(`${data.playerName} yenid…ôn oynamaq ist…ôyir (${data.votes}/${data.required})`, "info");
        });

        connection.on("RematchFailed", (data) => {
            showMessage(data.message, "error");
            hideRematchUI();
        });

        connection.on("Error", (msg) => showMessage(msg, "error"));
        connection.on("JoinError", (msg) => showMessage(msg, "error"));
        connection.on("GameError", (msg) => showMessage(msg, "error"));
        connection.on("ActionError", (msg) => showMessage(msg, "error"));

        connection.on("LeftRoom", () => {
            currentRoom = null;
            myCards = [];
            gameState = null;
            document.getElementById("gameScreen").style.display = "none";
            document.getElementById("lobbyScreen").style.display = "block";
            document.getElementById("roomsSection").style.display = "none";

            document.getElementsByClassName("header")[0].style.display = "block";

        });

        connection.on("QuickMessage", (data) => {
            showMessage(`${data.playerName}: ${data.emoji} ${data.message}`, "info");
            const display = document.createElement("div");
            display.className = "quick-message-display";
            display.innerHTML = `
                    <div style="margin-bottom: 10px; font-size: 0.5em; opacity: 0.8;">${data.playerName}</div>
                    <div>${data.emoji} ${data.message}</div>
                `;
            document.body.appendChild(display);
            setTimeout(() => display.remove(), 2000);
        });

        // ============ Helper Functions ============

        function showVoteNotification(data) {
            document.querySelectorAll('.vote-notification').forEach(n => n.remove());

            const notification = document.createElement("div");
            notification.className = "vote-notification";

            const actionText = {
                "Beaten": "üî• Beaten",
                "TakeCards": "üì• G√∂t√ºrm…ôk"
                // "Pass" silindi
            }[data.action] || data.action;

            notification.innerHTML = `
        <div style="margin-bottom: 5px;">${data.playerName}</div>
        <div style="font-size: 1.2em;">${actionText} (${data.votes}/${data.required})</div>
    `;

            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(400px)';
                setTimeout(() => notification.remove(), 300);
            }, 3000);

            console.log(`üó≥Ô∏è Vote: ${data.playerName} - ${data.action} (${data.votes}/${data.required})`);
        }

        function showRematchUI(entryFee) {
            const existingUI = document.getElementById("rematchUI");
            if (existingUI) existingUI.remove();

            const rematchDiv = document.createElement("div");
            rematchDiv.id = "rematchUI";
            rematchDiv.style.cssText = `
                    position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%);
                    background: rgba(0,0,0,0.95); padding: 30px; border-radius: 20px;
                    text-align: center; z-index: 2000; border: 3px solid #fbbf24;
                    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
                `;

            rematchDiv.innerHTML = `
                    <h2 style="margin-bottom: 20px; color: #fbbf24;">üîÑ Yenid…ôn Oyna</h2>
                    ${entryFee > 0 ? `<p style="margin-bottom: 20px; font-size: 1.2em;">Giri≈ü haqqƒ±: ${entryFee} AZN</p>` : ''}
                    <button class="btn btn-success" onclick="voteRematch()" style="width: 200px; margin: 0 auto;">
                        ‚úÖ Razƒ±yam
                    </button>
                `;

            document.body.appendChild(rematchDiv);
        }

        function hideRematchUI() {
            const rematchUI = document.getElementById("rematchUI");
            if (rematchUI) rematchUI.remove();
        }

        async function voteRematch() {
            try {
                await connection.invoke("VoteRematch");
                showMessage("S…ôsiniz qeyd…ô alƒ±ndƒ±! ‚è≥", "success");
            } catch (err) {
                showMessage("X…ôta: " + err.toString(), "error");
            }
        }

        // Player Selection
        async function selectPlayerCount(count) {
            selectedPlayerCount = count;
            document.getElementById("roomOptionsPanel").style.display = "block";
            document.getElementById("roomsSection").style.display = "none";
            // reset temporary selections
            selectedDeckSize = 36;
            selectedBet = 0;
            selectedModes = { col1: 'atilan', col2: 'qonsular' };
            // update UI classes (simple)
            document.querySelectorAll('.deck-pill').forEach(p => p.classList.toggle('selected', parseInt(p.dataset.size) === selectedDeckSize));
            document.querySelectorAll('.bet-btn').forEach(b => b.classList.remove('active'));
            // update mode cards
            document.querySelectorAll('.mode-card').forEach(m => {
                const col = m.dataset.col;
                const val = m.dataset.value;
                if (col == '1') m.classList.toggle('selected', selectedModes.col1 === val);
                if (col == '2') m.classList.toggle('selected', selectedModes.col2 === val);
            });
            // mark selected player-option visually (persist selection)
            document.querySelectorAll('.player-option').forEach(opt => {
                const c = parseInt(opt.dataset.count, 10);
                opt.classList.toggle('selected', c === selectedPlayerCount);
            });
        }

        function goBackToPlayerSelect() {
            document.getElementById("roomsSection").style.display = "none";
            document.getElementById("roomOptionsPanel").style.display = "none";
            // keep the player-select visible and highlight the chosen count
            document.querySelectorAll('.player-option').forEach(opt => {
                const c = parseInt(opt.dataset.count, 10);
                opt.classList.toggle('selected', c === selectedPlayerCount);
            });
        }

        async function loadQuickRooms(playerCount) {
            try {
                const quickRooms = await connection.invoke("GetQuickRooms");
                const filtered = quickRooms.filter(r => r.maxPlayers === playerCount);
                const container = document.getElementById("quickRoomsList");

                if (filtered.length === 0) {
                    container.innerHTML = '<div class="empty-hand">Hazƒ±rda uyƒüun otaq yoxdur</div>';
                    return;
                }

                container.innerHTML = filtered.map(room => {
                    // ‚úÖ YENƒ∞ - Deck size v…ô transfer info (…ôg…ôr backend g√∂nd…ôrirs…ô)
                    const deckInfo = room.deckSize ? `<span class="deck-badge">${room.deckSize} kart</span>` : '';
                    const transferInfo = room.transferEnabled !== undefined
                        ? `<span class="transfer-badge ${room.transferEnabled ? '' : 'disabled'}">${room.transferEnabled ? 'Transfer ‚úì' : 'Transfer ‚úó'}</span>`
                        : '';

                    return `
                            <div class="room-card" onclick="joinRoom('${room.roomId}')">
                                <h3>‚ö° ${room.roomName}</h3>
                                <div>${deckInfo} ${transferInfo}</div>
                                <div class="room-info">
                                    <span>üë• ${room.playerCount}/${room.maxPlayers}</span>
                                    ${room.entryFee > 0 ? `<span>üí∞ ${room.entryFee} AZN</span>` : ''}
                                </div>
                                ${room.totalPrize > 0 ? `<p style="color: #fbbf24; font-weight: 600;">üèÜ ${room.totalPrize} AZN</p>` : ''}
                                <span class="room-status waiting">‚è≥ G√∂zl…ôyir</span>
                            </div>
                        `;
                }).join('');
            } catch (err) {
                console.error(err);
                container.innerHTML = '<div class="empty-hand">Y√ºkl…ôm…ô x…ôtasƒ±</div>';
            }
        }

        // ===== Room options helpers =====
        function toggleDeckSize(size) {
            selectedDeckSize = size;
            document.querySelectorAll('.deck-pill').forEach(p => p.classList.toggle('selected', parseInt(p.dataset.size) === size));
        }

        function selectBet(amount) {
            selectedBet = amount;
            document.querySelectorAll('.bet-btn').forEach(b => {
                const v = parseFloat(b.textContent.trim());
                b.classList.toggle('active', v === amount);
            });
        }

        function selectMode(col, value) {
            if (col === 1) {
                selectedModes.col1 = value;
            } else if (col === 2) {
                selectedModes.col2 = value;
            }
            document.querySelectorAll('.mode-card').forEach(m => {
                const c = parseInt(m.dataset.col, 10);
                const val = m.dataset.value;
                if (c === 1) m.classList.toggle('selected', selectedModes.col1 === val);
                if (c === 2) m.classList.toggle('selected', selectedModes.col2 === val);
            });
        }

        async function startMatch() {
            // ensure SignalR connection is active to avoid invocation errors
            try {
                if (connection && typeof signalR !== 'undefined' && connection.state !== signalR.HubConnectionState.Connected) {
                    await connection.start();
                }
            } catch (connErr) {
                console.error('Connection start failed before startMatch:', connErr);
                showMessage('Server…ô qo≈üulmaq alƒ±nmadƒ±. Yenid…ôn c…ôhd edin.', 'error');
                return;
            }
            if (!selectedPlayerCount) {
                showMessage('Oyun√ßu sayƒ±nƒ± se√ßin', 'warning');
                return;
            }

            showMessage('Otaq axtarƒ±lƒ±r...', 'info');
            try {
                // Try to find an existing quick room that matches criteria
                const quickRooms = await connection.invoke('GetQuickRooms');
                const match = quickRooms.find(r => r.maxPlayers === selectedPlayerCount && (r.entryFee || 0) === (selectedBet || 0) && (!r.deckSize || r.deckSize === selectedDeckSize));
                if (match) {
                    joinRoom(match.roomId);
                    return;
                }

                // If not found, attempt to create a room (try common method names)
                const createPayload = { maxPlayers: selectedPlayerCount, entryFee: selectedBet || 0, deckSize: selectedDeckSize, modes: [selectedModes.col1, selectedModes.col2] };
                try {
                    await connection.invoke('CreateRoom', createPayload);
                    showMessage('Yeni otaq yaradƒ±ldƒ±, qo≈üulur...', 'success');
                } catch (cErr) {
                    try {
                        await connection.invoke('CreateQuickRoom', createPayload);
                        showMessage('Yeni otaq yaradƒ±ldƒ± (quick), qo≈üulur...', 'success');
                    } catch (cErr2) {
                        showMessage('Otaq yaradƒ±lmadƒ±: server d…ôst…ôyi yoxdur', 'error');
                        console.error('Create room errors:', cErr, cErr2);
                    }
                }
            } catch (err) {
                console.error('Start match error:', err);
                showMessage('Otaq axtarƒ±lark…ôn x…ôta ba≈ü verdi', 'error');
            }
        }

        async function joinRoom(roomId) {
            try {
                await connection.invoke("JoinRoom", roomId);
            } catch (err) {
                showMessage("Otaƒüa qo≈üulmaq alƒ±nmadƒ±", "error");
            }
        }

        async function sendQuickMsg(emoji, message) {
            try {
                await connection.invoke("SendQuickMessage", emoji, message);
            } catch (err) {
                console.error("Quick message error:", err);
            }
        }

        // ============ Rendering Functions ============

        function renderTrumpCard(card) {
            if (!card) return;
            const container = document.getElementById("trumpCardContainer");
            const cardDiv = createCardElement(card, false, false);
            container.innerHTML = '';
            container.appendChild(cardDiv);
        }

        function renderPlayers(players) {
            const container = document.getElementById("playersSection");
            container.innerHTML = players.map(player => {
                let roleClass = '';
                let roleText = '';

                if (player.isAttacker) {
                    roleClass = 'attacker';
                    roleText = '<span class="player-role attacker">‚öîÔ∏è Saldƒ±ran</span>';
                } else if (player.isDefender) {
                    roleClass = 'defender';
                    roleText = '<span class="player-role defender">üõ°Ô∏è M√ºdafi…ô√ßi</span>';
                }

                return `
                        <div class="player-card ${roleClass}">
                            <div class="player-name">${player.name}</div>
                            <div class="player-cards-count">üÉè ${player.cardCount} kart</div>
                            ${roleText}
                        </div>
                    `;
            }).join('');
        }

        function renderTableCards(state) {
            const container = document.getElementById("tableCards");

            const hasDefended = state.defendedCards && state.defendedCards.length > 0;
            const hasUndefended = state.tableCards && state.tableCards.length > 0;

            if (!hasDefended && !hasUndefended) {
                container.innerHTML = '<div class="empty-hand">Masa bo≈üdur</div>';
                return;
            }

            container.innerHTML = '';

            let isDefender = false;
            if (currentUser && state.players) {
                const myUserId = parseInt(currentUser.userId);
                const myPlayer = state.players.find(p => p.userId === myUserId);
                if (myPlayer) {
                    isDefender = myPlayer.isDefender;
                }
            }

            // 1. Defended pairs
            if (hasDefended) {
                state.defendedCards.forEach(pair => {
                    const pairDiv = document.createElement('div');
                    pairDiv.className = 'card-pair';
                    pairDiv.style.border = '2px solid rgba(16, 185, 129, 0.5)';
                    pairDiv.style.background = 'rgba(16, 185, 129, 0.1)';
                    pairDiv.style.padding = '10px';
                    pairDiv.style.borderRadius = '10px';

                    const attackCardEl = createCardElement(pair.attackCard, false, false);
                    const defendCardEl = createCardElement(pair.defendCard, false, false);

                    pairDiv.appendChild(attackCardEl);
                    pairDiv.appendChild(defendCardEl);
                    container.appendChild(pairDiv);
                });
            }

            // 2. Undefended cards
            if (hasUndefended) {
                state.tableCards.forEach(card => {
                    const cardWrapper = document.createElement('div');
                    const cardEl = createCardElement(card, false, false);

                    if (isDefender) {
                        cardWrapper.className = 'card-pair card-drop-zone';
                        cardWrapper.style.border = '3px dashed rgba(59, 130, 246, 0.8)';
                        cardWrapper.style.padding = '20px';
                        cardWrapper.style.borderRadius = '15px';
                        cardWrapper.style.minHeight = '170px';
                        cardWrapper.style.minWidth = '130px';
                        cardWrapper.style.display = 'flex';
                        cardWrapper.style.alignItems = 'center';
                        cardWrapper.style.justifyContent = 'center';
                        cardWrapper.style.background = 'rgba(59, 130, 246, 0.1)';

                        cardWrapper.setAttribute('data-attack-rank', card.rank);
                        cardWrapper.setAttribute('data-attack-suit', card.suit);

                        cardWrapper.ondragover = function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            this.style.background = 'rgba(16, 185, 129, 0.3)';
                            this.style.borderColor = '#10b981';
                            return false;
                        };

                        cardWrapper.ondragleave = function (e) {
                            e.preventDefault();
                            this.style.background = 'rgba(59, 130, 246, 0.1)';
                            this.style.borderColor = 'rgba(59, 130, 246, 0.8)';
                        };

                        cardWrapper.ondrop = function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            this.style.background = 'rgba(59, 130, 246, 0.1)';
                            this.style.borderColor = 'rgba(59, 130, 246, 0.8)';
                            handleDropOnZone(this);
                            return false;
                        };
                    } else {
                        cardWrapper.className = 'card-pair';
                        cardWrapper.style.border = '2px solid rgba(239, 68, 68, 0.3)';
                        cardWrapper.style.padding = '10px';
                        cardWrapper.style.borderRadius = '10px';
                    }

                    cardWrapper.appendChild(cardEl);
                    container.appendChild(cardWrapper);
                });
            }
        }

        function renderPlayerCards() {
            const container = document.getElementById("playerCards");

            if (myCards.length === 0) {
                container.innerHTML = '<div class="empty-hand">Kartlarƒ±nƒ±z yoxdur</div>';
                return;
            }

            container.innerHTML = '';

            let canAttack = false;
            let isDefender = false;
            let canTransfer = false;

            if (gameState && gameState.isGameActive && currentUser) {
                const myPlayer = gameState.players.find(p => p.userId === currentUser.userId);

                if (myPlayer) {
                    isDefender = myPlayer.isDefender;
                    const isMainAttacker = myPlayer.isAttacker;
                    const hasCardsOnTable = (gameState.tableCards && gameState.tableCards.length > 0) ||
                        (gameState.defendedCards && gameState.defendedCards.length > 0);

                    if (!isDefender) {
                        if (isMainAttacker || hasCardsOnTable) {
                            canAttack = true;
                        }
                    }

                    // ‚úÖ YENƒ∞ - Transfer yoxlamasƒ±
                    if (isDefender && gameState.transferEnabled && gameState.tableCards && gameState.tableCards.length === 1) {
                        canTransfer = true;
                    }
                }
            }

            myCards.forEach(card => {
                const cardElement = createCardElement(card, false, true);

                cardElement.draggable = true;
                cardElement.classList.add('draggable');
                cardElement.addEventListener('dragstart', (e) => handleDragStart(e, card));
                cardElement.addEventListener('dragend', handleDragEnd);

                // ‚úÖ YENƒ∞ - Transfer highlight
                if (canTransfer && gameState.tableCards) {
                    const firstTableCard = gameState.tableCards[0];
                    if (card.rank === firstTableCard.rank) {
                        cardElement.classList.add('transfer-highlight');
                        cardElement.onclick = function () {
                            transferAttack(card);
                        };
                    }
                }

                if (canAttack) {
                    const tableRanks = new Set();

                    if (gameState.tableCards) {
                        gameState.tableCards.forEach(c => tableRanks.add(c.rank));
                    }

                    if (gameState.defendedCards) {
                        gameState.defendedCards.forEach(pair => {
                            tableRanks.add(pair.attackCard.rank);
                            tableRanks.add(pair.defendCard.rank);
                        });
                    }

                    const canPlayThisCard = tableRanks.size === 0 || tableRanks.has(card.rank);

                    if (canPlayThisCard) {
                        cardElement.style.cursor = 'pointer';
                        cardElement.style.border = '3px solid rgba(239, 68, 68, 0.8)';
                        cardElement.style.boxShadow = '0 0 15px rgba(239, 68, 68, 0.5)';

                        cardElement.onclick = function () {
                            attackWithCard(card);
                        };
                    } else {
                        cardElement.style.opacity = '0.5';
                        cardElement.style.cursor = 'not-allowed';
                    }
                }

                container.appendChild(cardElement);
            });
        }

        function createCardElement(card, isSelected = false, isClickable = false) {
            const suit = card.suit.toLowerCase();
            const rank = rankNames[card.rank] || card.rank;
            const suitIcon = suitIcons[card.suit];

            const cardDiv = document.createElement('div');
            cardDiv.className = `card ${suit} ${isSelected ? 'selected' : ''}`;
            cardDiv.innerHTML = `
                    <div class="card-rank">${rank}</div>
                    <div class="card-suit">${suitIcon}</div>
                    <div class="card-rank">${rank}</div>
                `;

            return cardDiv;
        }

        // ============ Drag & Drop ============

        function handleDragStart(e, card) {
            const isMyCard = myCards.some(c => c.rank === card.rank && c.suit === card.suit);

            if (!isMyCard) {
                e.preventDefault();
                return;
            }

            draggedCard = card;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', JSON.stringify(card));
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('.card-drop-zone').forEach(zone => {
                zone.classList.remove('drag-over');
            });
        }

        async function handleDropOnZone(dropZone) {
            if (!draggedCard) return;

            const attackRank = dropZone.getAttribute('data-attack-rank');
            const attackSuit = dropZone.getAttribute('data-attack-suit');

            if (!attackRank || !attackSuit) {
                showMessage("X…ôta: H√ºcum kartƒ± tapƒ±lmadƒ±", "error");
                return;
            }

            try {
                await connection.invoke("Defend", [{
                    AttackCard: { rank: attackRank, suit: attackSuit },
                    DefendCard: draggedCard
                }]);
                showMessage("M√ºdafi…ô g√∂nd…ôrildi! ‚úÖ", "success");
            } catch (err) {
                showMessage("M√ºdafi…ô alƒ±nmadƒ± ‚ùå", "error");
            }

            draggedCard = null;
        }

        // ============ Game Actions ============

        async function attackWithCard(card) {
            if (!gameState || !currentUser) return;

            const myPlayer = gameState.players.find(p => p.userId === currentUser.userId);
            if (!myPlayer) return;

            if (myPlayer.isDefender) {
                showMessage("M√ºdafi…ô√ßi h√ºcum ed…ô bilm…ôz", "warning");
                return;
            }

            const hasCardsOnTable = (gameState.tableCards && gameState.tableCards.length > 0) ||
                (gameState.defendedCards && gameState.defendedCards.length > 0);

            if (!hasCardsOnTable && !myPlayer.isAttacker) {
                showMessage("ƒ∞lk h√ºcumu yalnƒ±z saldƒ±ran ed…ô bil…ôr", "warning");
                return;
            }

            try {
                await connection.invoke("Attack", [card]);
                showMessage(myPlayer.isAttacker ? "H√ºcum g√∂nd…ôrildi! ‚öîÔ∏è" : "∆èlav…ô h√ºcum! ‚ûï", "success");
            } catch (err) {
                showMessage("H√ºcum alƒ±nmadƒ±: " + err.toString(), "error");
            }
        }

        // ‚úÖ YENƒ∞ - Transfer Function
        async function transferAttack(card) {
            if (!gameState || !gameState.transferEnabled) {
                showMessage("Transfer m√ºmk√ºn deyil", "error");
                return;
            }

            try {
                await connection.invoke("TransferAttack", card);
                showMessage("Transfer g√∂nd…ôrildi! üîÑ", "success");
            } catch (err) {
                showMessage("Transfer alƒ±nmadƒ±: " + err.toString(), "error");
            }
        }
        // ‚úÖ YENƒ∞ - Update Action Buttons (Beaten + TakeCards + Pass)
        function updateActionButtons(state) {
            const beatenBtn = document.getElementById("beatenBtn");
            const takeBtn = document.getElementById("takeCardsBtn");

            if (!state.isGameActive || !currentUser) {
                beatenBtn.classList.add("hidden");
                takeBtn.classList.add("hidden");
                return;
            }

            const hasUndefendedCards = state.tableCards && state.tableCards.length > 0;
            const hasDefendedCards = state.defendedCards && state.defendedCards.length > 0;
            const hasAnyCards = hasUndefendedCards || hasDefendedCards;

            const myPlayer = state.players.find(p => p.userId === currentUser.userId);
            if (!myPlayer) {
                beatenBtn.classList.add("hidden");
                takeBtn.classList.add("hidden");
                return;
            }

            const isAttacker = myPlayer.isAttacker;
            const isDefender = myPlayer.isDefender;

            // ‚úÖ BEATEN - Yalnƒ±z Attacker + B√ºt√ºn kartlar m√ºdafi…ô olunubsa
            if (isAttacker && !hasUndefendedCards && hasDefendedCards) {
                beatenBtn.classList.remove("hidden");
                beatenBtn.textContent = "‚úÖ Beaten";
            } else {
                beatenBtn.classList.add("hidden");
            }

            // ‚úÖ TAKECARDS - Defender v…ô Attacker + Masada kart varsa
            if ((isDefender || isAttacker) && hasAnyCards) {
                takeBtn.classList.remove("hidden");

                if (isDefender) {
                    takeBtn.textContent = "üì• G√∂t√ºrm…ôk ist…ôyir…ôm";
                } else if (isAttacker) {
                    takeBtn.textContent = "üì• G√∂t√ºrm…ôsin…ô razƒ±yam";
                }
            } else {
                takeBtn.classList.add("hidden");
            }

            console.log('üéõÔ∏è Buttons updated:', {
                isAttacker,
                isDefender,
                beaten: !beatenBtn.classList.contains('hidden'),
                takeCards: !takeBtn.classList.contains('hidden')
            });
        }
        // ============ Button Event Listeners ============

        document.getElementById("beatenBtn").addEventListener("click", async () => {
            try {
                await connection.invoke("Beaten");
                console.log('‚úÖ Beaten sent');
            } catch (err) {
                showMessage("Beaten alƒ±nmadƒ±", "error");
                console.error(err);
            }
        });

        document.getElementById("takeCardsBtn").addEventListener("click", async () => {
            try {
                await connection.invoke("TakeCards");
                console.log('‚úÖ TakeCards vote sent');
            } catch (err) {
                showMessage("S…ôs verm…ôk alƒ±nmadƒ±", "error");
                console.error(err);
            }
        });
        document.getElementById("leaveRoomBtn").addEventListener("click", async () => {
            if (!confirm("Otaqdan √ßƒ±xmaq ist…ôdiyiniz…ô …ôminsiniz?")) return;
            try {
                await connection.invoke("LeaveRoom");
            } catch (err) {
                showMessage("Otaqdan √ßƒ±xmaq alƒ±nmadƒ±", "error");
            }
        });

        function showMessage(text, type = "info") {
            const container = document.getElementById("messages");
            const msg = document.createElement("div");
            msg.className = `message ${type}`;
            msg.textContent = text;
            container.appendChild(msg);

            setTimeout(() => {
                msg.style.animation = "slideIn 0.3s ease-out reverse";
                setTimeout(() => msg.remove(), 300);
            }, 4000);
        }
        function backToGames() {
            window.parent.postMessage({ type: 'BACK_TO_GAMES', payload: {} }, '*');
        }
        // init();
        console.log('‚úÖ Durak Game Ready! Drag & Drop + Beaten Active.');
    </script>
</body>

</html>
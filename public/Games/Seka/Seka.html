<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="title">Seka Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.1/signalr.min.js"></script>
    <link rel="stylesheet" href="./Seka.css">

</head>

<body>
    <div class="container">
        <!-- HEADER -->
        <div class="header">
            <button class="back-btn" onclick="backToGames()">
                ‚Üê
            </button>
            <h1 class="game-header-text">
                <img class="header-cards" src="./images/3tuzHeader.png" alt="Three aces cards" data-i18n-attr="alt:headerAlt">
                <span class="header-title">SEKA</span>
            </h1>
            <!-- <div class="header-subtitle">PROFESSIONAL CARD GAME</div> -->
            <div class="user-info">
                <!-- <div><strong id="userName">Loading...</strong></div> -->
                <div class="balance"><span id="userBalance">0</span></div>
            </div>
        </div>


        <!-- ROOM LIST SECTION -->
        <div id="roomListSection" class="room-list-section">
            <h2 style="color: #ffd700; margin: 10px 0 15px 10px" data-i18n="allRooms">All Rooms</h2>
            <div class="room-grid" id="roomGrid">
                <div class="loading loading--seka">
                    <div class="seka-loader">
                        <div class="table-surface" aria-hidden="true">
                            <div class="felt-sheen"></div>
                            <div class="felt-noise"></div>
                            <div class="table-light"></div>
                        </div>

                        <div class="card-fan" aria-hidden="true">
                            <div class="ace-card heart">
                                <span class="corner">A</span>
                                <span class="pip">‚ô•</span>
                                <span class="corner corner--br">A</span>
                            </div>
                            <div class="ace-card spade">
                                <span class="corner">A</span>
                                <span class="pip">‚ô†</span>
                                <span class="corner corner--br">A</span>
                            </div>
                            <div class="ace-card club">
                                <span class="corner">A</span>
                                <span class="pip">‚ô£</span>
                                <span class="corner corner--br">A</span>
                            </div>
                        </div>

                        <!-- <div class="chip-tower chip-tower--left" aria-hidden="true">
                            <span class="chip chip--ruby"></span>
                            <span class="chip chip--gold"></span>
                            <span class="chip chip--emerald"></span>
                        </div>

                        <div class="chip-tower chip-tower--right" aria-hidden="true">
                            <span class="chip chip--platinum"></span>
                            <span class="chip chip--ruby"></span>
                        </div>

                        <div class="cash-fan" aria-hidden="true">
                            <div class="bill bill-1"></div>
                            <div class="bill bill-2"></div>
                            <div class="bill bill-3"></div>
                        </div> -->

                        <div class="coin-orbit" aria-hidden="true">
                            <span class="coin coin--near"></span>
                            <span class="coin coin--far"></span>
                        </div>

                        <div class="loader-brand">
                            <span class="brand-label" data-i18n="sekaBrand">Seka</span>
                        </div>

                        <div class="loader-progress">
                            <div class="progress-track" aria-hidden="true">
                                <div class="progress-fill"></div>
                            </div>
                            <div class="loader-status" data-i18n="roomsLoading">Rooms loading...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- GAME SECTION -->
        <div id="gameSection" class="game-section">
            <div class="game-header">
                <!-- <div>
                    <h2 class="room-name">Room: <span id="currentRoomName">-</span></h2>
                </div> -->
                <button class="btn btn-leave btn-top" id="leaveBtn" data-i18n="exit">Exit</button>

                <!-- <div class="room-limit-info" id="roomLimitInfo">
                    POT LIMIT
                </div> -->
            </div>

            <!-- POKER TABLE -->
            <div class="poker-table" id="pokerTable">
                <div class="table-center">
                    <div class="pot-amount"><span data-i18n="pot">POT:</span> <span id="potAmount">0</span></div>
                    <div class="current-bet" style="display: none;"><span data-i18n="currentBet">Current bet:</span> <span id="currentBetAmount">0</span>
                    </div>
                </div>
            </div>

            <!-- HAND CARDS -->

            <!-- ACTIONS -->
            <!-- <div class="actions">

                <button class="btn btn-call" id="callBtn" disabled>
                    Call (<span id="callAmount">0</span> ‚Çº)
                </button>
                <div class="raise-slider-container" id="raiseSliderContainer">
                    <div class="slider-header">
                        <span class="slider-label">Raise M…ôbl…ôƒüi:</span>
                        <span class="slider-value" id="raiseValue">0 ‚Çº</span>
                    </div>
                    <input type="range" id="raiseSlider" class="raise-slider" min="0" max="1000" step="0.10" value="0"
                        disabled>
                    <div class="slider-limits">
                        <span id="sliderMin">Min: 0‚Çº</span>
                        <span id="sliderMax">Max: 1000‚Çº</span>
                    </div>
                    <button class="btn btn-raise" id="raiseBtn" disabled>Raise</button>
                </div>
                <button class="btn btn-fold" id="foldBtn" disabled>Fold</button>


                <button class="btn" id="allInBtn" disabled style="background: #f59e0b; color: #fff;">All-In üî•</button>

                <button class="btn btn-showdown-call" id="showdownCallBtn" disabled>
                    Showdown Call
                </button>

            </div> -->
            <div class="actions">
                <div class="actions-top">

                    <div class="my-cards">
                        <div class="hand-cards" id="handCards"></div>
                        <div style="text-align: center; margin-top: 10px;">
                            <div id="handScore" style="
                        display: none;
                        color: #ffd700;
                        background-color:#424242;
                        border: 2px solid #2b2b2b;
                        border-radius: 7px;
                        margin: 19px 0 4px 0;
                        font-weight: bold;
                        text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
                    ">
                                <span data-i18n="score">Score:</span> 0
                            </div>
                            <!-- <div class="hand-cards" id="handCards"></div> -->
                        </div>
                    </div>
                </div>
                <div class="actions-overlay-inner">
                    <div class="overlay-top-row">
                        <button class="overlay-btn overlay-raise-display" id="raiseBtn" disabled>
                            <div class="small-up" data-i18n="raise">Raise</div>
                            <div class="big-amount" id="raiseValue">0 </div>
                        </button>

                        <button class="overlay-btn overlay-confirm" id="callBtn" disabled>
                            <div class="check">‚úî</div>
                            <div class="label" data-i18n="call">Call</div>
                            <div class="small-amount" id="callAmount">0</div>
                        </button>

                        <button class="overlay-btn overlay-fold" id="foldBtn" disabled>
                            <div class="cross">‚úñ </div>
                            <div class="label" data-i18n="fold">Fold</div>
                        </button>
                    </div>

                    <div class="overlay-secondary-row">
                        <!-- <div id="overlayHand" class="overlay-hand-cards" aria-hidden="false"></div> -->
                        <!-- <div class="overlay-action-smalls"> -->
                        <!-- <button class="overlay-sm-btn" id="overlayRaiseBtn">Raise</button> -->

                        <!-- </div> -->
                        <button class="overlay-sm-btn" id="allInBtn" disabled data-i18n="allIn">All-In üî•</button>
                        <button class="overlay-sm-btn" id="showdownCallBtn" disabled data-i18n="showdown">Showdown</button>
                    </div>

                    <div class="overlay-slider-row">
                        <div class="slider-track">
                            <input type="range" id="raiseSlider" min="0" max="1000" step="0.01" value="0">
                        </div>
                        <!-- <div class="overlay-multipliers">
                            <button class="mult-btn" data-mul="2">x2<br><span>200</span></button>
                            <button class="mult-btn" data-mul="5">x5<br><span>250</span></button>
                            <button class="mult-btn" data-mul="10">x10<br><span>250</span></button>

                            <button class="mult-btn" data-mul="max" id="overlayMaxBtn">MAX<br><span>250</span></button>
                        </div> -->
                    </div>
                </div>
            </div>
            <!-- PLAYERS LIST -->
            <div class="players-list" style="display: none;">
                <h3 data-i18n="players">Players</h3>
                <div id="playersList"></div>
            </div>
        </div>
    </div>

    <!-- ROOM TIMER BADGE -->
    <div class="room-timer-badge hidden" id="roomTimerBadge">
        üïê <span id="roomTimerValue">120</span><span data-i18n="secondsSuffix">s</span>
    </div>

    <!-- REDIRECT OVERLAY -->
    <div class="redirect-overlay" id="redirectOverlay">
        <div class="redirect-content">
            <h2 data-i18n="redirecting">üîÑ Redirecting</h2>
            <p id="redirectMessage" style="color: #fff; font-size: 1.2rem;"></p>
            <div class="spinner"></div>
        </div>
    </div>

    <!-- ACTIONS OVERLAY (minimal, mobile-first, sits above everything) -->



    <script>
        const I18N = {
            en: {
                title: "Seka Game",
                headerAlt: "Three aces cards",
                sekaBrand: "Seka",
                loading: "Loading...",
                allRooms: "All Rooms",
                roomsLoading: "Rooms Loading...",
                exit: "Exit",
                pot: "POT:",
                currentBet: "Current bet:",
                score: "Score:",
                raise: "Raise",
                call: "Call",
                fold: "Fold",
                allIn: "All-In üî•",
                showdown: "Showdown",
                players: "Players",
                secondsSuffix: "s",
                redirecting: "üîÑ Redirecting",
                sekaRoom: "Seka Room",
                playersShort: "players",
                roomPlayersLabel: "Players:",
                betLabel: "Bet:",
                betRangeLabel: "Bet Range:",
                join: "Join",
                full: "‚ùå Full",
                noRooms: "No suitable rooms found",
                maxPlayersLabel: "Max: {count} players",
                limitPot: "POT LIMIT",
                limitNo: "NO LIMIT",
                maxBetLabel: "Max bet: {amount}",
                roomSmall: "Small Room",
                roomStandard: "Standard Room",
                roomMedium: "Medium Room",
                roomHigh: "High Room",
                roomPremium: "Premium Room",
                roomElite: "Elite Room",
                roomVip: "VIP Room",
                roomMaster: "Master Room",
                roomChampion: "Champion Room",
                gameStarted: "Game started",
                waitingStart: "Waiting",
                joinedRoom: "You joined the room!",
                connectionError: "Connection error: {error}",
                joinError: "Join error: {error}",
                leaveError: "Leave error: {error}",
                connectionNotReady: "Connection not ready",
                leftRoom: "You left the room",
                playerJoined: "{name} joined",
                playerLeft: "{name} left",
                gameStartedMsg: "Game started! üéÆ",
                cardsDealt: "Cards dealt!",
                playerBet: "{name} {action}: {amount}‚Çº",
                betAction: "made a bet",
                showdownCallAction: "made a showdown call",
                playerRaised: "{name} raised: {amount}",
                playerFolded: "{name} folded",
                playerAllIn: "{name} ALL-IN! {amount}",
                showdownStarting: "Showdown starting...",
                showdownCallError: "Showdown Call error: {error}",
                showdownError: "Showdown error: {error}",
                timeUpAutoFold: "Your time is up! Auto-fold...",
                enterValidAmount: "Enter a valid amount",
                raiseRange: "Raise range: {min} - {max}",
                leaveConfirm: "Are you sure you want to leave the room?",
                allInConfirm: "Are you sure you want to go ALL-IN?",
                foldError: "Fold error: {error}",
                callError: "Call error: {error}",
                raiseError: "Raise error: {error}",
                allInError: "All-in error: {error}",
                betError: "Bet error: {error}",
                minBet: "Minimum bet: {amount}",
                maxBet: "Maximum bet: {amount}",
                waiting: "Waiting...",
                youLabel: " (You)",
                foldTag: "[FOLD]",
                betShortLabel: "Bet",
                handWaiting: "Waiting...",
                winnerBannerTitle: "{name} WON!",
                commissionLabel: "Commission: {amount}",
                winnersLabel: "üéä Winners: {names} üéä",
                eachWon: "Each won: {amount}",
                winnerLabel: "üéä Winner: {name} üéä",
                earningsLabel: "Winnings: {amount}",
                commission20: "Commission (20%): {amount}",
                callWithAmount: "CALL({amount}‚Çº)",
                callWithEntry: "Call({amount}‚Çº)"
            },
            tr: {
                title: "Seka Oyunu",
                headerAlt: "√ú√ß as kartƒ±",
                sekaBrand: "Seka",
                loading: "Y√ºkleniyor...",
                allRooms: "T√ºm Odalar",
                roomsLoading: "Odalar y√ºkleniyor...",
                exit: "√áƒ±kƒ±≈ü",
                pot: "POT:",
                currentBet: "G√ºncel bahis:",
                score: "Puan:",
                raise: "Artƒ±r",
                call: "G√∂r",
                fold: "Pas",
                allIn: "All-In üî•",
                showdown: "Showdown",
                players: "Oyuncular",
                secondsSuffix: "sn",
                redirecting: "üîÑ Y√∂nlendiriliyor",
                sekaRoom: "Seka Odasƒ±",
                playersShort: "oyuncu",
                roomPlayersLabel: "Oyuncular:",
                betLabel: "Bahis:",
                betRangeLabel: "Bahis Aralƒ±ƒüƒ±:",
                join: "Katƒ±l",
                full: "‚ùå Dolu",
                noRooms: "Uygun oda bulunamadƒ±",
                maxPlayersLabel: "Maks: {count} oyuncu",
                limitPot: "POT LIMIT",
                limitNo: "NO LIMIT",
                maxBetLabel: "Maks bahis: {amount}",
                roomSmall: "K√º√ß√ºk Oda",
                roomStandard: "Standart Oda",
                roomMedium: "Orta Oda",
                roomHigh: "Y√ºksek Oda",
                roomPremium: "Premium Oda",
                roomElite: "Elit Oda",
                roomVip: "VIP Oda",
                roomMaster: "Master Oda",
                roomChampion: "≈ûampiyon Oda",
                gameStarted: "Oyun ba≈üladƒ±",
                waitingStart: "Bekliyor",
                joinedRoom: "Odaya katƒ±ldƒ±nƒ±z!",
                connectionError: "Baƒülantƒ± hatasƒ±: {error}",
                joinError: "Katƒ±lma hatasƒ±: {error}",
                leaveError: "√áƒ±kƒ±≈ü hatasƒ±: {error}",
                connectionNotReady: "Baƒülantƒ± hazƒ±r deƒüil",
                leftRoom: "Odadan √ßƒ±ktƒ±nƒ±z",
                playerJoined: "{name} katƒ±ldƒ±",
                playerLeft: "{name} √ßƒ±ktƒ±",
                gameStartedMsg: "Oyun ba≈üladƒ±! üéÆ",
                cardsDealt: "Kartlar daƒüƒ±tƒ±ldƒ±!",
                playerBet: "{name} {action}: {amount}‚Çº",
                betAction: "bahis yaptƒ±",
                showdownCallAction: "showdown √ßaƒürƒ±sƒ± yaptƒ±",
                playerRaised: "{name} artƒ±rdƒ±: {amount}",
                playerFolded: "{name} pas ge√ßti",
                playerAllIn: "{name} ALL-IN! {amount}",
                showdownStarting: "Showdown ba≈ülƒ±yor...",
                showdownCallError: "Showdown Call hatasƒ±: {error}",
                showdownError: "Showdown hatasƒ±: {error}",
                timeUpAutoFold: "S√ºreniz bitti! Otomatik pas...",
                enterValidAmount: "Ge√ßerli bir miktar girin",
                raiseRange: "Artƒ±rma aralƒ±ƒüƒ±: {min} - {max}",
                leaveConfirm: "Odadan √ßƒ±kmak istediƒüinize emin misiniz?",
                allInConfirm: "ALL-IN yapmak istediƒüinize emin misiniz?",
                foldError: "Pas hatasƒ±: {error}",
                callError: "G√∂rme hatasƒ±: {error}",
                raiseError: "Artƒ±rma hatasƒ±: {error}",
                allInError: "All-in hatasƒ±: {error}",
                betError: "Bahis hatasƒ±: {error}",
                minBet: "Minimum bahis: {amount}",
                maxBet: "Maksimum bahis: {amount}",
                waiting: "Bekleniyor...",
                youLabel: " (Siz)",
                foldTag: "[PAS]",
                betShortLabel: "Bahis",
                handWaiting: "Bekleyin...",
                winnerBannerTitle: "{name} KAZANDI!",
                commissionLabel: "Komisyon: {amount}",
                winnersLabel: "üéä Kazananlar: {names} üéä",
                eachWon: "Ki≈üi ba≈üƒ± kazan√ß: {amount}",
                winnerLabel: "üéä Kazanan: {name} üéä",
                earningsLabel: "Kazan√ß: {amount}",
                commission20: "Komisyon (20%): {amount}",
                callWithAmount: "G√ñR({amount}‚Çº)",
                callWithEntry: "G√∂r({amount}‚Çº)"
            },
            hi: {
                title: "‡§∏‡•á‡§ï‡§æ ‡§ñ‡•á‡§≤",
                headerAlt: "‡§§‡•Ä‡§® ‡§á‡§ï‡•ç‡§ï‡•ã‡§Ç ‡§ï‡•á ‡§™‡§§‡•ç‡§§‡•á",
                sekaBrand: "‡§∏‡•á‡§ï‡§æ",
                loading: "‡§≤‡•ã‡§° ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à...",
                allRooms: "‡§∏‡§≠‡•Ä ‡§ï‡§Æ‡§∞‡•á",
                roomsLoading: "‡§ï‡§Æ‡§∞‡•á ‡§≤‡•ã‡§° ‡§π‡•ã ‡§∞‡§π‡•á ‡§π‡•à‡§Ç...",
                exit: "‡§¨‡§æ‡§π‡§∞ ‡§ú‡§æ‡§è‡§Ç",
                pot: "‡§™‡•â‡§ü:",
                currentBet: "‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§¶‡§æ‡§Ç‡§µ:",
                score: "‡§∏‡•ç‡§ï‡•ã‡§∞:",
                raise: "‡§∞‡§æ‡§á‡§ú‡§º",
                call: "‡§ï‡•â‡§≤",
                fold: "‡§´‡•ã‡§≤‡•ç‡§°",
                allIn: "‡§ë‡§≤-‡§á‡§® üî•",
                showdown: "‡§∂‡•ã‡§°‡§æ‡§â‡§®",
                players: "‡§ñ‡§ø‡§≤‡§æ‡§°‡§º‡•Ä",
                secondsSuffix: "s",
                redirecting: "üîÑ ‡§∞‡•Ä‡§°‡§æ‡§Ø‡§∞‡•á‡§ï‡•ç‡§ü ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à",
                sekaRoom: "‡§∏‡•á‡§ï‡§æ ‡§∞‡•Ç‡§Æ",
                playersShort: "‡§ñ‡§ø‡§≤‡§æ‡§°‡§º‡•Ä",
                roomPlayersLabel: "‡§ñ‡§ø‡§≤‡§æ‡§°‡§º‡•Ä:",
                betLabel: "‡§¶‡§æ‡§Ç‡§µ:",
                betRangeLabel: "‡§¶‡§æ‡§Ç‡§µ ‡§∏‡•Ä‡§Æ‡§æ:",
                join: "‡§ú‡•â‡§á‡§®",
                full: "‚ùå ‡§´‡•Å‡§≤",
                noRooms: "‡§â‡§™‡§Ø‡•Å‡§ï‡•ç‡§§ ‡§ï‡§Æ‡§∞‡•á ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡•á",
                maxPlayersLabel: "‡§Ö‡§ß‡§ø‡§ï‡§§‡§Æ: {count} ‡§ñ‡§ø‡§≤‡§æ‡§°‡§º‡•Ä",
                limitPot: "POT LIMIT",
                limitNo: "NO LIMIT",
                maxBetLabel: "‡§Ö‡§ß‡§ø‡§ï‡§§‡§Æ ‡§¶‡§æ‡§Ç‡§µ: {amount}",
                roomSmall: "‡§õ‡•ã‡§ü‡§æ ‡§ï‡§Æ‡§∞‡§æ",
                roomStandard: "‡§Æ‡§æ‡§®‡§ï ‡§ï‡§Æ‡§∞‡§æ",
                roomMedium: "‡§Æ‡§ß‡•ç‡§Ø‡§Æ ‡§ï‡§Æ‡§∞‡§æ",
                roomHigh: "‡§â‡§ö‡•ç‡§ö ‡§ï‡§Æ‡§∞‡§æ",
                roomPremium: "‡§™‡•ç‡§∞‡•Ä‡§Æ‡§ø‡§Ø‡§Æ ‡§ï‡§Æ‡§∞‡§æ",
                roomElite: "‡§è‡§≤‡•Ä‡§ü ‡§ï‡§Æ‡§∞‡§æ",
                roomVip: "‡§µ‡•Ä‡§Ü‡§à‡§™‡•Ä ‡§ï‡§Æ‡§∞‡§æ",
                roomMaster: "‡§Æ‡§æ‡§∏‡•ç‡§ü‡§∞ ‡§ï‡§Æ‡§∞‡§æ",
                roomChampion: "‡§ö‡•à‡§Ç‡§™‡§ø‡§Ø‡§® ‡§ï‡§Æ‡§∞‡§æ",
                gameStarted: "‡§ñ‡•á‡§≤ ‡§∂‡•Å‡§∞‡•Ç",
                waitingStart: "‡§™‡•ç‡§∞‡§§‡•Ä‡§ï‡•ç‡§∑‡§æ",
                joinedRoom: "‡§Ü‡§™ ‡§ï‡§Æ‡§∞‡•á ‡§Æ‡•á‡§Ç ‡§∂‡§æ‡§Æ‡§ø‡§≤ ‡§π‡•ã ‡§ó‡§è!",
                connectionError: "‡§ï‡§®‡•á‡§ï‡•ç‡§∂‡§® ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: {error}",
                joinError: "‡§ú‡•â‡§á‡§® ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: {error}",
                leaveError: "‡§®‡§ø‡§ï‡§æ‡§∏ ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: {error}",
                connectionNotReady: "‡§ï‡§®‡•á‡§ï‡•ç‡§∂‡§® ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à",
                leftRoom: "‡§Ü‡§™ ‡§ï‡§Æ‡§∞‡•á ‡§∏‡•á ‡§®‡§ø‡§ï‡§≤ ‡§ó‡§è",
                playerJoined: "{name} ‡§∂‡§æ‡§Æ‡§ø‡§≤ ‡§π‡•Å‡§Ü",
                playerLeft: "{name} ‡§®‡§ø‡§ï‡§≤ ‡§ó‡§Ø‡§æ",
                gameStartedMsg: "‡§ñ‡•á‡§≤ ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•Å‡§Ü! üéÆ",
                cardsDealt: "‡§ï‡§æ‡§∞‡•ç‡§° ‡§¨‡§æ‡§Ç‡§ü‡•á ‡§ó‡§è!",
                playerBet: "{name} {action}: {amount}‚Çº",
                betAction: "‡§®‡•á ‡§¶‡§æ‡§Ç‡§µ ‡§≤‡§ó‡§æ‡§Ø‡§æ",
                showdownCallAction: "‡§®‡•á ‡§∂‡•ã‡§°‡§æ‡§â‡§® ‡§ï‡•â‡§≤ ‡§ï‡§ø‡§Ø‡§æ",
                playerRaised: "{name} ‡§®‡•á ‡§∞‡§æ‡§á‡§ú‡§º ‡§ï‡§ø‡§Ø‡§æ: {amount}",
                playerFolded: "{name} ‡§®‡•á ‡§´‡•ã‡§≤‡•ç‡§° ‡§ï‡§ø‡§Ø‡§æ",
                playerAllIn: "{name} ‡§ë‡§≤-‡§á‡§®! {amount}",
                showdownStarting: "‡§∂‡•ã‡§°‡§æ‡§â‡§® ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à...",
                showdownCallError: "‡§∂‡•ã‡§°‡§æ‡§â‡§® ‡§ï‡•â‡§≤ ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: {error}",
                showdownError: "‡§∂‡•ã‡§°‡§æ‡§â‡§® ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: {error}",
                timeUpAutoFold: "‡§Ü‡§™‡§ï‡§æ ‡§∏‡§Æ‡§Ø ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§! ‡§ë‡§ü‡•ã-‡§´‡•ã‡§≤‡•ç‡§°...",
                enterValidAmount: "‡§Æ‡§æ‡§®‡•ç‡§Ø ‡§∞‡§æ‡§∂‡§ø ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç",
                raiseRange: "‡§∞‡§æ‡§á‡§ú‡§º ‡§∏‡•Ä‡§Æ‡§æ: {min} - {max}",
                leaveConfirm: "‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§µ‡§æ‡§ï‡§à ‡§ï‡§Æ‡§∞‡•á ‡§∏‡•á ‡§®‡§ø‡§ï‡§≤‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?",
                allInConfirm: "‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§µ‡§æ‡§ï‡§à ‡§ë‡§≤-‡§á‡§® ‡§ú‡§æ‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?",
                foldError: "‡§´‡•ã‡§≤‡•ç‡§° ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: {error}",
                callError: "‡§ï‡•â‡§≤ ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: {error}",
                raiseError: "‡§∞‡§æ‡§á‡§ú‡§º ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: {error}",
                allInError: "‡§ë‡§≤-‡§á‡§® ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: {error}",
                betError: "‡§¶‡§æ‡§Ç‡§µ ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: {error}",
                minBet: "‡§®‡•ç‡§Ø‡•Ç‡§®‡§§‡§Æ ‡§¶‡§æ‡§Ç‡§µ: {amount}",
                maxBet: "‡§Ö‡§ß‡§ø‡§ï‡§§‡§Æ ‡§¶‡§æ‡§Ç‡§µ: {amount}",
                waiting: "‡§™‡•ç‡§∞‡§§‡•Ä‡§ï‡•ç‡§∑‡§æ...",
                youLabel: " (‡§Ü‡§™)",
                foldTag: "[‡§´‡•ã‡§≤‡•ç‡§°]",
                betShortLabel: "‡§¶‡§æ‡§Ç‡§µ",
                handWaiting: "‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•ç‡§∞‡§§‡•Ä‡§ï‡•ç‡§∑‡§æ ‡§ï‡§∞‡•á‡§Ç...",
                winnerBannerTitle: "{name} ‡§ú‡•Ä‡§§ ‡§ó‡§Ø‡§æ!",
                commissionLabel: "‡§ï‡§Æ‡•Ä‡§∂‡§®: {amount}",
                winnersLabel: "üéä ‡§µ‡§ø‡§ú‡•á‡§§‡§æ: {names} üéä",
                eachWon: "‡§™‡•ç‡§∞‡§§‡•ç‡§Ø‡•á‡§ï ‡§®‡•á ‡§ú‡•Ä‡§§‡§æ: {amount}",
                winnerLabel: "üéä ‡§µ‡§ø‡§ú‡•á‡§§‡§æ: {name} üéä",
                earningsLabel: "‡§ú‡•Ä‡§§: {amount}",
                commission20: "‡§ï‡§Æ‡•Ä‡§∂‡§® (20%): {amount}",
                callWithAmount: "‡§ï‡•â‡§≤({amount}‚Çº)",
                callWithEntry: "‡§ï‡•â‡§≤({amount}‚Çº)"
            },
            ru: {
                title: "–ò–≥—Ä–∞ –°–µ–∫–∞",
                headerAlt: "–¢—Ä–∏ —Ç—É–∑–∞",
                sekaBrand: "–°–µ–∫–∞",
                loading: "–ó–∞–≥—Ä—É–∑–∫–∞...",
                allRooms: "–í—Å–µ –∫–æ–º–Ω–∞—Ç—ã",
                roomsLoading: "–ö–æ–º–Ω–∞—Ç—ã –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è...",
                exit: "–í—ã–π—Ç–∏",
                pot: "–ü–æ—Ç:",
                currentBet: "–¢–µ–∫—É—â–∞—è —Å—Ç–∞–≤–∫–∞:",
                score: "–û—á–∫–∏:",
                raise: "–†–µ–π–∑",
                call: "–ö–æ–ª–ª",
                fold: "–§–æ–ª–¥",
                allIn: "–û–ª–ª-–∏–Ω üî•",
                showdown: "–®–æ—É–¥–∞—É–Ω",
                players: "–ò–≥—Ä–æ–∫–∏",
                secondsSuffix: "—Å",
                redirecting: "üîÑ –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ",
                sekaRoom: "–ö–æ–º–Ω–∞—Ç–∞ –°–µ–∫–∞",
                playersShort: "–∏–≥—Ä–æ–∫–æ–≤",
                roomPlayersLabel: "–ò–≥—Ä–æ–∫–∏:",
                betLabel: "–°—Ç–∞–≤–∫–∞:",
                betRangeLabel: "–î–∏–∞–ø–∞–∑–æ–Ω —Å—Ç–∞–≤–æ–∫:",
                join: "–í–æ–π—Ç–∏",
                full: "‚ùå –ü–æ–ª–Ω–∞—è",
                noRooms: "–ü–æ–¥—Ö–æ–¥—è—â–∏—Ö –∫–æ–º–Ω–∞—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω–æ",
                maxPlayersLabel: "–ú–∞–∫—Å: {count} –∏–≥—Ä–æ–∫–æ–≤",
                limitPot: "POT LIMIT",
                limitNo: "NO LIMIT",
                maxBetLabel: "–ú–∞–∫—Å —Å—Ç–∞–≤–∫–∞: {amount}",
                roomSmall: "–ú–∞–ª–µ–Ω—å–∫–∞—è –∫–æ–º–Ω–∞—Ç–∞",
                roomStandard: "–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –∫–æ–º–Ω–∞—Ç–∞",
                roomMedium: "–°—Ä–µ–¥–Ω—è—è –∫–æ–º–Ω–∞—Ç–∞",
                roomHigh: "–í—ã—Å–æ–∫–∞—è –∫–æ–º–Ω–∞—Ç–∞",
                roomPremium: "–ü—Ä–µ–º–∏—É–º –∫–æ–º–Ω–∞—Ç–∞",
                roomElite: "–≠–ª–∏—Ç–Ω–∞—è –∫–æ–º–Ω–∞—Ç–∞",
                roomVip: "VIP –∫–æ–º–Ω–∞—Ç–∞",
                roomMaster: "–ú–∞—Å—Ç–µ—Ä –∫–æ–º–Ω–∞—Ç–∞",
                roomChampion: "–ß–µ–º–ø–∏–æ–Ω—Å–∫–∞—è –∫–æ–º–Ω–∞—Ç–∞",
                gameStarted: "–ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å",
                waitingStart: "–û–∂–∏–¥–∞–Ω–∏–µ",
                joinedRoom: "–í—ã –≤–æ—à–ª–∏ –≤ –∫–æ–º–Ω–∞—Ç—É!",
                connectionError: "–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è: {error}",
                joinError: "–û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞: {error}",
                leaveError: "–û—à–∏–±–∫–∞ –≤—ã—Ö–æ–¥–∞: {error}",
                connectionNotReady: "–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –Ω–µ –≥–æ—Ç–æ–≤–æ",
                leftRoom: "–í—ã –≤—ã—à–ª–∏ –∏–∑ –∫–æ–º–Ω–∞—Ç—ã",
                playerJoined: "{name} –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è",
                playerLeft: "{name} –≤—ã—à–µ–ª",
                gameStartedMsg: "–ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å! üéÆ",
                cardsDealt: "–ö–∞—Ä—Ç—ã —Ä–æ–∑–¥–∞–Ω—ã!",
                playerBet: "{name} {action}: {amount}‚Çº",
                betAction: "—Å–¥–µ–ª–∞–ª —Å—Ç–∞–≤–∫—É",
                showdownCallAction: "—Å–¥–µ–ª–∞–ª —à–æ—É–¥–∞—É–Ω-–∫–æ–ª–ª",
                playerRaised: "{name} –ø–æ–¥–Ω—è–ª: {amount}",
                playerFolded: "{name} —Å–±—Ä–æ—Å–∏–ª",
                playerAllIn: "{name} –û–õ–õ-–ò–ù! {amount}",
                showdownStarting: "–®–æ—É–¥–∞—É–Ω –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è...",
                showdownCallError: "–û—à–∏–±–∫–∞ Showdown Call: {error}",
                showdownError: "–û—à–∏–±–∫–∞ —à–æ—É–¥–∞—É–Ω–∞: {error}",
                timeUpAutoFold: "–í—Ä–µ–º—è –≤—ã—à–ª–æ! –ê–≤—Ç–æ-—Ñ–æ–ª–¥...",
                enterValidAmount: "–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—É–º–º—É",
                raiseRange: "–î–∏–∞–ø–∞–∑–æ–Ω —Ä–µ–π–∑–∞: {min} - {max}",
                leaveConfirm: "–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –≤—ã–π—Ç–∏ –∏–∑ –∫–æ–º–Ω–∞—Ç—ã?",
                allInConfirm: "–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –ø–æ–π—Ç–∏ –æ–ª–ª-–∏–Ω?",
                foldError: "–û—à–∏–±–∫–∞ —Ñ–æ–ª–¥–∞: {error}",
                callError: "–û—à–∏–±–∫–∞ –∫–æ–ª–ª–∞: {error}",
                raiseError: "–û—à–∏–±–∫–∞ —Ä–µ–π–∑–∞: {error}",
                allInError: "–û—à–∏–±–∫–∞ –æ–ª–ª-–∏–Ω: {error}",
                betError: "–û—à–∏–±–∫–∞ —Å—Ç–∞–≤–∫–∏: {error}",
                minBet: "–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—Ç–∞–≤–∫–∞: {amount}",
                maxBet: "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å—Ç–∞–≤–∫–∞: {amount}",
                waiting: "–û–∂–∏–¥–∞–Ω–∏–µ...",
                youLabel: " (–í—ã)",
                foldTag: "[–§–û–õ–î]",
                betShortLabel: "–°—Ç–∞–≤–∫–∞",
                handWaiting: "–ü–æ–¥–æ–∂–¥–∏—Ç–µ...",
                winnerBannerTitle: "{name} –ü–û–ë–ï–î–ò–õ!",
                commissionLabel: "–ö–æ–º–∏—Å—Å–∏—è: {amount}",
                winnersLabel: "üéä –ü–æ–±–µ–¥–∏—Ç–µ–ª–∏: {names} üéä",
                eachWon: "–ö–∞–∂–¥—ã–π –≤—ã–∏–≥—Ä–∞–ª: {amount}",
                winnerLabel: "üéä –ü–æ–±–µ–¥–∏—Ç–µ–ª—å: {name} üéä",
                earningsLabel: "–í—ã–∏–≥—Ä—ã—à: {amount}",
                commission20: "–ö–æ–º–∏—Å—Å–∏—è (20%): {amount}",
                callWithAmount: "–ö–û–õ–õ({amount}‚Çº)",
                callWithEntry: "–ö–æ–ª–ª({amount}‚Çº)"
            },
            ar: {
                title: "ŸÑÿπÿ®ÿ© ÿ≥ŸäŸÉÿß",
                headerAlt: "ÿ´ŸÑÿßÿ´ÿ© ÿ¢ÿ≥ÿßÿ™",
                sekaBrand: "ÿ≥ŸäŸÉÿß",
                loading: "ÿ¨ÿßÿ±Ÿç ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ...",
                allRooms: "ŸÉŸÑ ÿßŸÑÿ∫ÿ±ŸÅ",
                roomsLoading: "Ÿäÿ™ŸÖ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ∫ÿ±ŸÅ...",
                exit: "ÿÆÿ±Ÿàÿ¨",
                pot: "ÿßŸÑŸàÿπÿßÿ°:",
                currentBet: "ÿßŸÑÿ±ŸáÿßŸÜ ÿßŸÑÿ≠ÿßŸÑŸä:",
                score: "ÿßŸÑŸÜŸÇÿßÿ∑:",
                raise: "ÿ±ŸÅÿπ",
                call: "ŸÖÿ¨ÿßÿ±ÿßÿ©",
                fold: "ÿßŸÜÿ≥ÿ≠ÿßÿ®",
                allIn: "ÿßŸÑŸÉŸÑ ŸÅŸä üî•",
                showdown: "ÿßŸÑŸÖŸàÿßÿ¨Ÿáÿ©",
                players: "ÿßŸÑŸÑÿßÿπÿ®ŸàŸÜ",
                secondsSuffix: "ÿ´",
                redirecting: "üîÑ ÿ¨ÿßÿ±Ÿç ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ™Ÿàÿ¨ŸäŸá",
                sekaRoom: "ÿ∫ÿ±ŸÅÿ© ÿ≥ŸäŸÉÿß",
                playersShort: "ŸÑÿßÿπÿ®",
                roomPlayersLabel: "ÿßŸÑŸÑÿßÿπÿ®ŸàŸÜ:",
                betLabel: "ÿßŸÑÿ±ŸáÿßŸÜ:",
                betRangeLabel: "ŸÜÿ∑ÿßŸÇ ÿßŸÑÿ±ŸáÿßŸÜ:",
                join: "ÿßŸÜÿ∂ŸÖ",
                full: "‚ùå ŸÖŸÖÿ™ŸÑÿ¶ÿ©",
                noRooms: "ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ∫ÿ±ŸÅ ŸÖŸÜÿßÿ≥ÿ®ÿ©",
                maxPlayersLabel: "ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ: {count} ŸÑÿßÿπÿ®",
                limitPot: "ÿ≠ÿØ ÿßŸÑŸàÿπÿßÿ°",
                limitNo: "ÿ®ÿØŸàŸÜ ÿ≠ÿØ",
                maxBetLabel: "ÿ£ŸÇÿµŸâ ÿ±ŸáÿßŸÜ: {amount}",
                roomSmall: "ÿ∫ÿ±ŸÅÿ© ÿµÿ∫Ÿäÿ±ÿ©",
                roomStandard: "ÿ∫ÿ±ŸÅÿ© ŸÇŸäÿßÿ≥Ÿäÿ©",
                roomMedium: "ÿ∫ÿ±ŸÅÿ© ŸÖÿ™Ÿàÿ≥ÿ∑ÿ©",
                roomHigh: "ÿ∫ÿ±ŸÅÿ© ÿπÿßŸÑŸäÿ©",
                roomPremium: "ÿ∫ÿ±ŸÅÿ© ÿ®ÿ±ŸäŸÖŸäŸàŸÖ",
                roomElite: "ÿ∫ÿ±ŸÅÿ© ŸÜÿÆÿ®ÿ©",
                roomVip: "ÿ∫ÿ±ŸÅÿ© ŸÉÿ®ÿßÿ± ÿßŸÑÿ¥ÿÆÿµŸäÿßÿ™",
                roomMaster: "ÿ∫ÿ±ŸÅÿ© ŸÖÿßÿ≥ÿ™ÿ±",
                roomChampion: "ÿ∫ÿ±ŸÅÿ© ÿ®ÿ∑ŸÑ",
                gameStarted: "ÿ®ÿØÿ£ÿ™ ÿßŸÑŸÑÿπÿ®ÿ©",
                waitingStart: "ÿ®ÿßŸÜÿ™ÿ∏ÿßÿ±",
                joinedRoom: "ŸÑŸÇÿØ ÿßŸÜÿ∂ŸÖŸÖÿ™ ÿ•ŸÑŸâ ÿßŸÑÿ∫ÿ±ŸÅÿ©!",
                connectionError: "ÿÆÿ∑ÿ£ ÿßÿ™ÿµÿßŸÑ: {error}",
                joinError: "ÿÆÿ∑ÿ£ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ: {error}",
                leaveError: "ÿÆÿ∑ÿ£ ÿßŸÑÿÆÿ±Ÿàÿ¨: {error}",
                connectionNotReady: "ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ∫Ÿäÿ± ÿ¨ÿßŸáÿ≤",
                leftRoom: "ŸÑŸÇÿØ ÿ∫ÿßÿØÿ±ÿ™ ÿßŸÑÿ∫ÿ±ŸÅÿ©",
                playerJoined: "{name} ÿßŸÜÿ∂ŸÖ",
                playerLeft: "{name} ÿ∫ÿßÿØÿ±",
                gameStartedMsg: "ÿ®ÿØÿ£ÿ™ ÿßŸÑŸÑÿπÿ®ÿ©! üéÆ",
                cardsDealt: "ÿ™ŸÖ ÿ™Ÿàÿ≤Ÿäÿπ ÿßŸÑÿ®ÿ∑ÿßŸÇÿßÿ™!",
                playerBet: "{name} {action}: {amount}‚Çº",
                betAction: "ŸÇÿßŸÖ ÿ®ÿßŸÑÿ±ŸáÿßŸÜ",
                showdownCallAction: "ŸÇÿßŸÖ ÿ®ŸÜÿØÿßÿ° ÿßŸÑŸÖŸàÿßÿ¨Ÿáÿ©",
                playerRaised: "{name} ÿ±ŸÅÿπ: {amount}",
                playerFolded: "{name} ÿßŸÜÿ≥ÿ≠ÿ®",
                playerAllIn: "{name} ÿßŸÑŸÉŸÑ ŸÅŸä! {amount}",
                showdownStarting: "ÿ™ÿ®ÿØÿ£ ÿßŸÑŸÖŸàÿßÿ¨Ÿáÿ©...",
                showdownCallError: "ÿÆÿ∑ÿ£ ŸÜÿØÿßÿ° ÿßŸÑŸÖŸàÿßÿ¨Ÿáÿ©: {error}",
                showdownError: "ÿÆÿ∑ÿ£ ÿßŸÑŸÖŸàÿßÿ¨Ÿáÿ©: {error}",
                timeUpAutoFold: "ÿßŸÜÿ™ŸáŸâ ŸàŸÇÿ™ŸÉ! ÿßŸÜÿ≥ÿ≠ÿßÿ® ÿ™ŸÑŸÇÿßÿ¶Ÿä...",
                enterValidAmount: "ÿ£ÿØÿÆŸÑ ŸÖÿ®ŸÑÿ∫Ÿãÿß ÿµÿ≠Ÿäÿ≠Ÿãÿß",
                raiseRange: "ŸÜÿ∑ÿßŸÇ ÿßŸÑÿ±ŸÅÿπ: {min} - {max}",
                leaveConfirm: "ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ÿ£ŸÜŸÉ ÿ™ÿ±ŸäÿØ ŸÖÿ∫ÿßÿØÿ±ÿ© ÿßŸÑÿ∫ÿ±ŸÅÿ©ÿü",
                allInConfirm: "ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ÿ£ŸÜŸÉ ÿ™ÿ±ŸäÿØ ÿßŸÑÿ∞Ÿáÿßÿ® ÿ®ŸÉŸÑ ÿßŸÑÿ±ÿµŸäÿØÿü",
                foldError: "ÿÆÿ∑ÿ£ ÿßŸÑÿßŸÜÿ≥ÿ≠ÿßÿ®: {error}",
                callError: "ÿÆÿ∑ÿ£ ÿßŸÑŸÖÿ¨ÿßÿ±ÿßÿ©: {error}",
                raiseError: "ÿÆÿ∑ÿ£ ÿßŸÑÿ±ŸÅÿπ: {error}",
                allInError: "ÿÆÿ∑ÿ£ ÿßŸÑŸÉŸÑ ŸÅŸä: {error}",
                betError: "ÿÆÿ∑ÿ£ ÿßŸÑÿ±ŸáÿßŸÜ: {error}",
                minBet: "ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ÿØŸÜŸâ ŸÑŸÑÿ±ŸáÿßŸÜ: {amount}",
                maxBet: "ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑŸÑÿ±ŸáÿßŸÜ: {amount}",
                waiting: "ÿ®ÿßŸÜÿ™ÿ∏ÿßÿ±...",
                youLabel: " (ÿ£ŸÜÿ™)",
                foldTag: "[ÿßŸÜÿ≥ÿ≠ÿßÿ®]",
                betShortLabel: "ÿ±ŸáÿßŸÜ",
                handWaiting: "Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±...",
                winnerBannerTitle: "{name} ŸÅÿßÿ≤!",
                commissionLabel: "ÿßŸÑÿπŸÖŸàŸÑÿ©: {amount}",
                winnersLabel: "üéä ÿßŸÑŸÅÿßÿ¶ÿ≤ŸàŸÜ: {names} üéä",
                eachWon: "ÿ±ÿ®ÿ≠ ŸÉŸÑ Ÿàÿßÿ≠ÿØ: {amount}",
                winnerLabel: "üéä ÿßŸÑŸÅÿßÿ¶ÿ≤: {name} üéä",
                earningsLabel: "ÿßŸÑŸÖŸÉÿ≥ÿ®: {amount}",
                commission20: "ÿßŸÑÿπŸÖŸàŸÑÿ© (20%): {amount}",
                callWithAmount: "ŸÖÿ¨ÿßÿ±ÿßÿ©({amount}‚Çº)",
                callWithEntry: "ŸÖÿ¨ÿßÿ±ÿßÿ©({amount}‚Çº)"
            },
            uz: {
                title: "Seka o'yini",
                headerAlt: "Uchta tuz",
                sekaBrand: "Seka",
                loading: "Yuklanmoqda...",
                allRooms: "Barcha xonalar",
                roomsLoading: "Xonalar yuklanmoqda...",
                exit: "Chiqish",
                pot: "POT:",
                currentBet: "Joriy garov:",
                score: "Ochko:",
                raise: "Ko'tarish",
                call: "Call",
                fold: "Fold",
                allIn: "All-In üî•",
                showdown: "Showdown",
                players: "O'yinchilar",
                secondsSuffix: "s",
                redirecting: "üîÑ Yo'naltirilmoqda",
                sekaRoom: "Seka xonasi",
                playersShort: "o'yinchi",
                roomPlayersLabel: "O'yinchilar:",
                betLabel: "Garov:",
                betRangeLabel: "Garov oralig'i:",
                join: "Qo'shilish",
                full: "‚ùå To'la",
                noRooms: "Mos xona topilmadi",
                maxPlayersLabel: "Maks: {count} o'yinchi",
                limitPot: "POT LIMIT",
                limitNo: "NO LIMIT",
                maxBetLabel: "Maks garov: {amount}",
                roomSmall: "Kichik xona",
                roomStandard: "Standart xona",
                roomMedium: "O'rta xona",
                roomHigh: "Yuqori xona",
                roomPremium: "Premium xona",
                roomElite: "Elit xona",
                roomVip: "VIP xona",
                roomMaster: "Master xona",
                roomChampion: "Champion xona",
                gameStarted: "O'yin boshlandi",
                waitingStart: "Kutilmoqda",
                joinedRoom: "Xonaga qo'shildingiz!",
                connectionError: "Ulanish xatosi: {error}",
                joinError: "Qo'shilish xatosi: {error}",
                leaveError: "Chiqish xatosi: {error}",
                connectionNotReady: "Ulanish tayyor emas",
                leftRoom: "Xonadan chiqdingiz",
                playerJoined: "{name} qo'shildi",
                playerLeft: "{name} chiqdi",
                gameStartedMsg: "O'yin boshlandi! üéÆ",
                cardsDealt: "Kartalar tarqatildi!",
                playerBet: "{name} {action}: {amount}‚Çº",
                betAction: "garov qildi",
                showdownCallAction: "showdown chaqirdi",
                playerRaised: "{name} ko'tardi: {amount}",
                playerFolded: "{name} fold qildi",
                playerAllIn: "{name} ALL-IN! {amount}",
                showdownStarting: "Showdown boshlanmoqda...",
                showdownCallError: "Showdown Call xatosi: {error}",
                showdownError: "Showdown xatosi: {error}",
                timeUpAutoFold: "Vaqtingiz tugadi! Avto-fold...",
                enterValidAmount: "To'g'ri miqdor kiriting",
                raiseRange: "Ko'tarish oralig'i: {min} - {max}",
                leaveConfirm: "Xonadan chiqishni xohlaysizmi?",
                allInConfirm: "ALL-IN qilishni xohlaysizmi?",
                foldError: "Fold xatosi: {error}",
                callError: "Call xatosi: {error}",
                raiseError: "Ko'tarish xatosi: {error}",
                allInError: "All-in xatosi: {error}",
                betError: "Garov xatosi: {error}",
                minBet: "Minimal garov: {amount}",
                maxBet: "Maksimal garov: {amount}",
                waiting: "Kutilmoqda...",
                youLabel: " (Siz)",
                foldTag: "[FOLD]",
                betShortLabel: "Garov",
                handWaiting: "Iltimos kuting...",
                winnerBannerTitle: "{name} YUTDI!",
                commissionLabel: "Komissiya: {amount}",
                winnersLabel: "üéä G'oliblar: {names} üéä",
                eachWon: "Har biri yutdi: {amount}",
                winnerLabel: "üéä G'olib: {name} üéä",
                earningsLabel: "Yutuq: {amount}",
                commission20: "Komissiya (20%): {amount}",
                callWithAmount: "CALL({amount}‚Çº)",
                callWithEntry: "Call({amount}‚Çº)"
            }
        };

        let currentLanguage = "en";

        function normalizeLanguage(lang) {
            if (!lang) return "en";
            const value = String(lang).toLowerCase();
            if (value.startsWith("tr") || value.includes("turkish") || value.includes("t√ºrk")) return "tr";
            if (value.startsWith("hi") || value.startsWith("in") || value.includes("hindi") || value.includes("indian")) return "hi";
            if (value.startsWith("ru") || value.includes("russian")) return "ru";
            if (value.startsWith("ar") || value.includes("arabic")) return "ar";
            if (value.startsWith("uz") || value.includes("uzbek")) return "uz";
            if (value.startsWith("en") || value.includes("english")) return "en";
            return "en";
        }

        function t(key, vars = {}) {
            const dict = I18N[currentLanguage] || I18N.en;
            const template = dict[key] || I18N.en[key] || key;
            return template.replace(/\{(\w+)\}/g, (_, k) => (vars[k] !== undefined ? vars[k] : ""));
        }

        function applyStaticTranslations() {
            document.querySelectorAll("[data-i18n]").forEach(el => {
                const key = el.getAttribute("data-i18n");
                if (key) el.textContent = t(key);
            });

            document.querySelectorAll("[data-i18n-attr]").forEach(el => {
                const raw = el.getAttribute("data-i18n-attr");
                if (!raw) return;
                raw.split(";").forEach(pair => {
                    const [attr, key] = pair.split(":").map(s => s && s.trim());
                    if (!attr || !key) return;
                    el.setAttribute(attr, t(key));
                });
            });
        }

        function setLanguage(langInput) {
            currentLanguage = normalizeLanguage(langInput);
            document.documentElement.lang = currentLanguage;
            document.documentElement.dir = currentLanguage === "ar" ? "rtl" : "ltr";

            applyStaticTranslations();
            // const userNameEl = document.getElementById("userName");
            // if (userNameEl && !currentUserData) userNameEl.textContent = t('loading');
            if (typeof loadRoomList === "function") loadRoomList();
            if (typeof displayHand === "function") displayHand();
        }


        let currentUserToken = null;
        let currentUserData = null;

        console.log('üÉè [SEKA] Script y√ºkl…ôndi');

        window.addEventListener('message', (event) => {
            console.log('üì® [SEKA] Message alƒ±ndƒ±:', event.data);

            const incomingLanguage = event?.data?.payload?.language;
            if (incomingLanguage) {
                setLanguage(incomingLanguage);
            }

            if (event.data && event.data.type === 'INIT_USER') {
                console.log('‚úÖ [SEKA] INIT_USER q…ôbul edildi');

                currentUserData = event.data.payload;
                currentUserToken = currentUserData.token;

                console.log('üë§ [SEKA] User:', currentUserData.username);
                console.log('üé´ [SEKA] Token:', currentUserToken ? 'VAR' : 'YOX');

                // UI-ƒ± yenil…ô
                // document.getElementById('userName').textContent = currentUserData.username;
                document.getElementById('userBalance').textContent = currentUserData.balance.toFixed(2);

                console.log('üöÄ [SEKA] initializeSignalR() √ßaƒüƒ±rƒ±lƒ±r...');
                // SignalR ba≈ülat
                initializeSignalR();
            }
        });

        // ============================================
        // getToken funksiyasƒ±nƒ± d…ôyi≈üdir
        // ============================================
        function getToken() {
            return currentUserToken || "";
        }


        // ‚úÖ ∆èv…ôzin…ô bunu …ôlav…ô et:
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üìÑ [SEKA] DOM loaded');
            setLanguage(currentLanguage);
            setupEventListeners();
            console.log('‚úÖ [SEKA] Event listeners quruldu, user data g√∂zl…ônilir...');
        });



        // ==================== GLOBAL VARIABLES ====================
        let connection = null;
        let currentUserId = 0;
        let currentRoomId = null;
        let myHand = [];
        let currentTurnUserId = 0;
        let currentGameBet = 0;
        let myCurrentBet = 0;
        let myBalance = 0;
        let potAmount = 0;
        let roomLimitType = 'PotLimit';
        let maxRaiseAmount = 0;
        let lastRaiserId = 0;
        let raiseCount = 0;
        let currentTimer = null;
        let turnTimeRemaining = 0;
        let roomEntryFee = 0;
        let pendingBets = {};
        let isInSvara = false;
        let svaraRound = 0;

        function updateActionButtons(gameState) {
            if (!gameState) return;

            // ‚úÖ Backend-d…ôn g…ôl…ôn m…ôlumatlardan buttons hesabla
            const isTurn = (gameState.currentTurnUserId === currentUserId);
            const canFold = isTurn;
            const canRaise = isTurn && (gameState.canCall || gameState.currentBet === 0);
            const canAllIn = isTurn && myBalance < gameState.currentBet;

            console.log('üé¨ updateActionButtons:', {
                isTurn: isTurn,
                canFold: canFold,
                canCall: gameState.canCall,
                canRaise: canRaise,
                canShowdownCall: gameState.canShowdownCall,
                canAllIn: canAllIn
            });

            // ============ FOLD ============
            const foldBtn = document.getElementById('foldBtn');
            if (foldBtn) {
                foldBtn.disabled = !canFold;
                foldBtn.style.opacity = canFold ? '1' : '0.5';
            }

            // ============ CALL ============
            const callBtn = document.getElementById('callBtn');
            if (callBtn) {
                callBtn.disabled = !gameState.canCall;
                callBtn.style.opacity = gameState.canCall ? '1' : '0.5';
                if (gameState.canCall && gameState.callAmount > 0) {
                    callBtn.innerHTML = t('callWithAmount', { amount: gameState.callAmount.toFixed(2) });
                } else {
                    callBtn.innerHTML = t('callWithEntry', { amount: gameState.entryFee.toFixed(2) });
                }
            }

            // ============ RAISE ============
            const raiseBtn = document.getElementById('raiseBtn');
            const raiseSlider = document.getElementById('raiseSlider');
            if (raiseBtn && raiseSlider) {
                raiseBtn.disabled = !canRaise;
                raiseBtn.style.opacity = canRaise ? '1' : '0.5';
                raiseSlider.disabled = !canRaise;

                if (gameState.minRaise !== undefined && gameState.maxRaise !== undefined) {
                    const minVal = parseFloat(gameState.minRaise.toFixed(2));
                    const maxVal = parseFloat(gameState.maxRaise.toFixed(2));
                    raiseSlider.min = minVal;
                    raiseSlider.max = maxVal;
                    raiseSlider.value = minVal;
                    // document.getElementById('sliderMin').textContent = `Min: ${minVal.toFixed(2)}‚Çº`;
                    // document.getElementById('sliderMax').textContent = `Max: ${maxVal.toFixed(2)}‚Çº`;
                    document.getElementById('raiseValue').textContent = `${minVal.toFixed(2)}`;
                }
            }

            // ============ ALL-IN ============
            const allInBtn = document.getElementById('allInBtn');
            if (allInBtn) {
                allInBtn.disabled = !canAllIn;
                allInBtn.style.opacity = canAllIn ? '1' : '0.5';
            }

            // ============ SHOWDOWN CALL ============

            const showdownCallBtn = document.getElementById('showdownCallBtn');
            if (showdownCallBtn) {
                // ‚úÖ currentBet = 0 olarsa v…ô ya canShowdownCall false olarsa disabled
                const isShowdownDisabled = gameState.currentBet === 0 || !gameState.canShowdownCall;

                showdownCallBtn.disabled = isShowdownDisabled;
                showdownCallBtn.style.opacity = !isShowdownDisabled ? '1' : '0.5';

                if (!isShowdownDisabled) {
                    showdownCallBtn.classList.add('golden-glow');
                } else {
                    showdownCallBtn.classList.remove('golden-glow');
                }
            }

            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            console.log('‚úÖ Buttons updated');
            console.log(`üî¥ FOLD: ${canFold ? '‚úÖ' : '‚ùå'}`);
            console.log(`üìû CALL: ${gameState.canCall ? '‚úÖ' : '‚ùå'}`);
            console.log(`üìà RAISE: ${canRaise ? '‚úÖ' : '‚ùå'}`);
            console.log(`üî• ALL - IN: ${canAllIn ? '‚úÖ' : '‚ùå'}`);
            console.log(`‚≠ê SHOWDOWN: ${gameState.canShowdownCall ? '‚úÖ' : '‚ùå'}`);
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        }

        // ==================== INIT ====================
        window.addEventListener('load', async () => {
            setupEventListeners();
            await initializeSignalR();
        });

        window.addEventListener('load', async () => {
            console.log('üìÑ Page loaded');
            setupEventListeners();
            await initializeSignalR();
        });

        function setupEventListeners() {
            ['foldBtn', 'callBtn', 'allInBtn', 'raiseBtn', 'showdownCallBtn', 'leaveBtn'].forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    const handlers = {
                        'foldBtn': fold,
                        'callBtn': call,
                        'allInBtn': allIn,
                        'raiseBtn': raise,
                        'showdownCallBtn': showdownCall,
                        'leaveBtn': leaveRoom
                    };
                    if (handlers[id]) btn.addEventListener('click', handlers[id]);
                }
            });

            const slider = document.getElementById('raiseSlider');
            if (slider) slider.addEventListener('input', () => {
                const raiseValue = document.getElementById('raiseValue');
                if (raiseValue) raiseValue.textContent = parseFloat(slider.value).toFixed(2);
            });
        }


        // ==================== SIGNALR CONNECTION ====================
        async function initializeSignalR() {
            try {
                console.log('üîå SignalR ba≈ülanƒüƒ±c...');

                connection = new signalR.HubConnectionBuilder()
                    .withUrl("https://nehemiah-paginal-alan.ngrok-free.dev/sekaHub", { accessTokenFactory: () => getToken() })
                    .withAutomaticReconnect()
                    .build();

                setupSignalRHandlers();

                // ‚úÖ START ET V∆è G√ñZL∆è
                await connection.start();
                console.log("‚úÖ SignalR connected");

                // ‚úÖ SONRA ROOM Lƒ∞ST Y√úK L∆è
                await new Promise(resolve => setTimeout(resolve, 500)); // 500ms g√∂zl…ô
                await loadRoomList();
                console.log('‚úÖ Room list loaded');

            } catch (error) {
                console.error("‚ùå SignalR error:", error);
                showMessage(t('connectionError', { error: error.message }), "error");

                // ‚úÖ YENƒ∞D∆èN C∆èHD ET
                setTimeout(() => initializeSignalR(), 3000);
            }
        }



        // ==================== SIGNALR HANDLERS ====================
        function setupSignalRHandlers() {
            if (!connection) {
                console.error("‚ùå Connection is null!");
                return;
            }

            console.log('üì° Setting up SignalR handlers...');

            connection.on("UserData", (data) => {
                currentUserId = data.userId;
                myBalance = data.balance;
                // const userNameEl = document.getElementById('userName');
                const userBalanceEl = document.getElementById('userBalance');
                // if (userNameEl) userNameEl.textContent = data.username;
                if (userBalanceEl) userBalanceEl.textContent = data.balance.toFixed(2);
                console.log('‚úÖ UserData received:', data);
            });

            connection.on("BalanceUpdated", (balance) => {
                myBalance = balance;
                const userBalanceEl = document.getElementById('userBalance');
                if (userBalanceEl) userBalanceEl.textContent = balance.toFixed(2);
            });

            connection.on("ShowCardsOnTable", (players) => {
                console.log('üé¥ Showing cards on table:', players);
                showCardsOnTable(players);
            });

            connection.on("WinnerAnnounced", (data) => {
                console.log('üèÜ Winner announced:', data);
                highlightWinner(data.winnerUserId);
                showWinnerBanner(data);
                setTimeout(() => clearWinnerDisplay(), 5000);
            });

            connection.on("GameReset", () => {
                resetGameUI();
                clearWinnerDisplay();
            });

            connection.on("JoinedRoom", (data) => {
                currentRoomId = data.roomId;
                roomLimitType = data.limitType || 'PotLimit';
                roomEntryFee = data.entryFee || 0;

                console.log('‚úÖ Joined room:', {
                    roomId: data.roomId,
                    entryFee: roomEntryFee,
                    limitType: roomLimitType
                });

                // const roomNameEl = document.getElementById('currentRoomName');
                // if (roomNameEl) roomNameEl.textContent = data.roomName;

                // const limitInfo = document.getElementById('roomLimitInfo');
                // if (limitInfo) {
                //     limitInfo.textContent = roomLimitType === 'PotLimit' ? 'POT LIMIT' : 'NO LIMIT';
                //     limitInfo.classList.toggle('no-limit', roomLimitType !== 'PotLimit');
                // }
                const roomListSection = document.getElementById('roomListSection');
                const gameSection = document.getElementById('gameSection');
                if (roomListSection) roomListSection.style.display = 'none';
                if (gameSection) gameSection.classList.add('active');
                document.getElementsByClassName("header")[0].style.display = 'none';

                if (data.hand && data.hand.length > 0) {
                    myHand = data.hand;
                    displayHand();
                }


                showMessage(t('joinedRoom'), "success");
            });

            connection.on("RoomStartTimer", (remainingSeconds) => {
                console.log('‚è±Ô∏è Room start timer:', remainingSeconds);
                const badge = document.getElementById('roomTimerBadge');
                const value = document.getElementById('roomTimerValue');
                if (badge && value) {
                    badge.classList.remove('hidden');
                    value.textContent = remainingSeconds;
                    badge.classList.toggle('warning', remainingSeconds <= 10);
                }
            });

            connection.on("RoomStartTimeout", (message) => {
                const badge = document.getElementById('roomTimerBadge');
                if (badge) badge.classList.add('hidden');
                // fold();
                showMessage(message, "success");
            });

            connection.on("RoomStarting", (message) => {
                const badge = document.getElementById('roomTimerBadge');
                if (badge) badge.classList.add('hidden');
                showMessage(message, "success");
            });

            connection.on("JoinError", (message) => showMessage(message, "error"));
            connection.on("LeaveError", (message) => showMessage(message, "error"));

            connection.on("PlayerJoined", (playerName) => {
                showMessage(t('playerJoined', { name: playerName }), "info");
                loadRoomList();
            });

            connection.on("PlayerLeft", (playerName) => {
                showMessage(t('playerLeft', { name: playerName }), "info");
                loadRoomList();
            });

            connection.on("PlayersList", (players) => {
                updatePlayersList(players);
                updatePlayersOnTable(players);
            });

            connection.on("PotUpdated", (data) => {
                console.log('üí∞ PotUpdated received:', data);

                // ‚úÖ DATA Tƒ∞Pƒ∞ KONTROL
                let potValue = 0;

                if (typeof data === 'number') {
                    // ESKI FORMAT: PotUpdated(amount) - sayƒ± olarak
                    potValue = data;
                    console.log('üìä Pot (number):', potValue);
                } else if (typeof data === 'object' && data.potAmount !== undefined) {
                    // YENƒ∞ FORMAT: PotUpdated({potAmount, currentPot, frozenPot, ...})
                    potValue = data.potAmount || 0;
                    console.log('üìä Pot (object):', {
                        potAmount: data.potAmount,
                        currentPot: data.currentPot,
                        frozenPot: data.frozenPot,
                        totalPot: data.totalPot
                    });
                } else {
                    console.warn('‚ö†Ô∏è PotUpdated data format unknown:', data);
                    return;
                }

                // ‚úÖ GLOBAL VARIABLE G√úNCELLE
                potAmount = potValue;

                // ‚úÖ POT DISPLAY G√úNCELLE
                const potEl = document.getElementById('potAmount');
                if (potEl) {
                    potEl.textContent = potValue.toFixed(2);
                    potEl.style.color = potValue > 0 ? '#FFD700' : '#888';

                    // ‚úÖ ANIMATION
                    potEl.style.animation = 'none';
                    setTimeout(() => {
                        potEl.style.animation = 'potPulse 0.5s ease';
                    }, 10);

                    console.log('‚úÖ Pot display g√ºncellendi: ' + potValue.toFixed(2) + '‚Çº');
                } else {
                    console.warn('‚ö†Ô∏è potAmount element not found');
                }

                // ‚úÖ SLIDER LIMITLERINI G√úNCELLE
                updateSliderLimits();
            });

            connection.on("RoomFull", (message) => showMessage(message, "info"));
            connection.on("RoomDeleted", (roomId) => loadRoomList());

            connection.on("GameStarted", () => {
                const badge = document.getElementById('roomTimerBadge');
                if (badge) badge.classList.add('hidden');
                showMessage(t('gameStartedMsg'), "success");
                resetGameUI();
                raiseCount = 0;
                lastRaiserId = 0;
            });

            connection.on("CardsDealt", (data) => {
                myHand = data.hand;
                displayHand();
                showMessage(t('cardsDealt'), "info");
            });

            connection.on("PlayerBet", (data) => {
                console.log('üì¢ PlayerBet received:', data);

                // ‚úÖ POT G√úNCELLE (eƒüer varsa)
                if (data.potAmount !== undefined) {
                    potAmount = data.potAmount;
                    const potEl = document.getElementById('potAmount');
                    if (potEl) {
                        potEl.textContent = data.potAmount.toFixed(2);
                        potEl.style.color = '#FFD700';
                        // console.log(‚Å†‚ÄØ‚úÖ PlayerBet'ten Pot g√ºncellemeldi: ${data.potAmount.toFixed(2)}‚Çº‚ÄØ‚Å†);
                    }

                    // ‚úÖ SLIDER LIMITLERINI G√úNCELLE
                    updateSliderLimits();
                }

                // ‚úÖ OYUNCU BET ƒ∞NFOSU
                const actionKey = data.isShowdownCall ? 'showdownCallAction' : 'betAction';
                const message = t('playerBet', {
                    name: data.playerName,
                    action: t(actionKey),
                    amount: data.amount.toFixed(2)
                });
                showMessage(message, "info");

                console.log('üí∞ Pot ≈üimdi: ' + potAmount.toFixed(2) + '‚Çº');
            });

            connection.on("PlayerRaised", (data) => {
                showMessage(t('playerRaised', { name: data.playerName, amount: data.amount.toFixed(2) }), "info");
                raiseCount++;
                lastRaiserId = data.userId;
            });

            connection.on("PlayerFolded", (playerName) => {
                showMessage(t('playerFolded', { name: playerName }), "info");
            });

            connection.on("PlayerAllIn", (playerName, amount) => {
                showMessage(t('playerAllIn', { name: playerName, amount: amount.toFixed(2) }), "success");
            });

            connection.on("BetError", (message) => showMessage(message, "error"));
            connection.on("FoldError", (message) => showMessage(message, "error"));
            connection.on("ActionError", (message) => showMessage(message, "error"));
            connection.on("RaiseError", (message) => showMessage(message, "error"));

            connection.on("ShowdownStart", (players) => showShowdown(players));
            connection.on("ShowdownRequested", () => showMessage(t('showdownStarting'), "info"));
            connection.on("ShowdownCallMade", (data) => showMessage(data.message, "success"));
            connection.on("ForceShowdown", (data) => showMessage(data.message, "info"));
            connection.on("GameOver", (data) => handleGameOver(data));

            connection.on("NewRound", () => {
                raiseCount = 0;
                lastRaiserId = 0;
            });

            connection.on("LeftRoom", () => {
                const badge = document.getElementById('roomTimerBadge');
                if (badge) badge.classList.add('hidden');
                currentRoomId = null;
                myHand = [];
                roomEntryFee = 0;
                const gameSection = document.getElementById('gameSection');
                const roomListSection = document.getElementById('roomListSection');
                if (gameSection) gameSection.classList.remove('active');
                if (roomListSection) roomListSection.style.display = 'block';
                document.getElementsByClassName("header")[0].style.display = 'flex';

                loadRoomList();
                showMessage(t('leftRoom'), "info");
            });

            connection.on("PlayerEmoji", (data) => showFloatingEmoji(data.userId, data.emoji));
            connection.on("PlayerTimeout", (data) => {
                showMessage(data.message, "error");
                stopTurnTimer();
            });

            connection.on("GameState", (state) => {
                console.log('üéÆ GameState received:', state);

                currentTurnUserId = state.currentTurnUserId;
                currentGameBet = state.currentBet;
                myCurrentBet = state.myCurrentBet || 0;
                raiseCount = state.raiseCount || 0;
                lastRaiserId = state.lastRaiserId || 0;
                roomEntryFee = state.entryFee || roomEntryFee;
                potAmount = state.potAmount || 0;

                if (state.limitType) roomLimitType = state.limitType;

                const potEl = document.getElementById('potAmount');
                if (potEl) {
                    potEl.textContent = state.potAmount.toFixed(2);
                    potEl.style.color = state.potAmount > 0 ? '#FFD700' : '#888';
                    console.log('‚úÖ GameStateten Pot g√ºncellemeldi: ' + state.potAmount.toFixed(2) + '‚Çº');
                }

                const betEl = document.getElementById('currentBetAmount');
                if (betEl) betEl.textContent = state.currentBet.toFixed(2);

                const scoreDisplay = document.getElementById('handScore');
                if (scoreDisplay && state.myHandScore > 0) {
                    scoreDisplay.textContent = `${t('score')} ${state.myHandScore}`;
                    scoreDisplay.style.display = 'block';
                }

                const callAmountEl = document.getElementById('callAmount');
                if (callAmountEl) callAmountEl.textContent = state.callAmount.toFixed(2);

                if (state.turnTimeRemaining && state.currentTurnUserId === currentUserId) {
                    turnTimeRemaining = state.turnTimeRemaining;
                    startTurnTimer();
                } else {
                    stopTurnTimer();
                }

                updateSliderLimits();
                updateActionButtons(state);
            });

            console.log('‚úÖ All handlers registered');
        }
        function findPlayerElement(userId) {
            const avatars = document.querySelectorAll('.player-avatar');
            for (const avatar of avatars) {
                const onclickAttr = avatar.getAttribute('onclick');
                if (onclickAttr && onclickAttr.includes(`toggleEmojiPopup(${userId})`)) {
                    return avatar.parentElement;
                }
            }
            return null;
        }
        // function getToken() {
        //     const raw = document.cookie
        //         .split("; ")
        //         .find(row => row.startsWith("AuthToken="))
        //         ?.split("=")[1];
        //     return raw ? decodeURIComponent(raw).trim() : "";
        // }
        // ==================== QUICK JOIN ====================
        async function loadQuickJoinButtons() {
            try {
                console.log('üìã Loading quick join buttons...');

                const templates = [
                    { fee: 0.20, nameKey: "roomSmall", maxPlayers: 5, isPotLimit: true },
                    { fee: 0.50, nameKey: "roomStandard", maxPlayers: 5, isPotLimit: true },
                    { fee: 1.00, nameKey: "roomMedium", maxPlayers: 5, isPotLimit: true },
                    { fee: 2.00, nameKey: "roomHigh", maxPlayers: 5, isPotLimit: false },
                    { fee: 5.00, nameKey: "roomPremium", maxPlayers: 5, isPotLimit: false },
                    { fee: 10.00, nameKey: "roomElite", maxPlayers: 5, isPotLimit: false },
                    { fee: 20.00, nameKey: "roomVip", maxPlayers: 5, isPotLimit: false },
                    { fee: 50.00, nameKey: "roomMaster", maxPlayers: 5, isPotLimit: false },
                    { fee: 100.00, nameKey: "roomChampion", maxPlayers: 5, isPotLimit: false }
                ];

                grid.innerHTML = templates.map(item => `
            <div class="quick-join-btn" onclick="quickJoin(${item.fee}, ${item.isPotLimit})">
                <div class="name">${t(item.nameKey)}</div>
                <div class="fee">${item.fee.toFixed(2)}</div>
                <div class="players">${t('maxPlayersLabel', { count: item.maxPlayers })}</div>
                <div class="limit-type">${item.isPotLimit ? t('limitPot') : t('limitNo')}</div>
                <div style="font-size: 0.7rem; color: #94a3b8; margin-top: 5px;">
                    ${t('maxBetLabel', { amount: (item.fee * 20).toFixed(2) })}
                </div>
            </div>
        `).join('');

                console.log('‚úÖ Quick join buttons loaded');
            } catch (error) {
                console.error("‚ùå Template error:", error);
            }
        }
        async function quickJoin(entryFee, isPotLimit) {
            try {
                await connection.invoke("QuickJoin", entryFee, isPotLimit);
            } catch (error) {
                showMessage(t('joinError', { error: error.message }), "error");
            }
        }

        // ==================== ROOM LIST ====================
        // ==================== ROOM LIST ====================
        async function loadRoomList() {
            try {
                // ‚úÖ Connection hazƒ±r mƒ± yoxla
                if (!connection || connection.state !== signalR.HubConnectionState.Connected) {
                    console.warn('‚ö†Ô∏è Connection not ready, waiting...');
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    return loadRoomList();
                }

                console.log('üìã Loading room list...');
                const rooms = await connection.invoke("GetRoomList");
                const grid = document.getElementById('roomGrid');
                if (!grid) {
                    console.warn('‚ö†Ô∏è roomGrid not found');
                    return;
                }

                // ‚úÖ SADECE NO LIMIT OLAN OTAQLAR
                const filteredRooms = rooms.filter(room => room.limitType !== 'PotLimit');

                // <div class="room-avatar">${('R').charAt(0).toUpperCase()}</div>
                // <div class="limit-badge">NO LIMIT</div>
                grid.innerHTML = filteredRooms.length === 0
                    ? `<div class="loading">${t('noRooms')}</div>`
                    : filteredRooms.map(room => `
                <div class="room-card ${room.isFull ? 'full' : ''}">

                    <div class="room-top">
                        <div style="flex:1">
                            <h3 class="room-title">${t('sekaRoom')}</h3>
                            <div class="room-sub">${room.maxPlayers} ${t('playersShort')} ‚Ä¢ ${room.isGameStarted ? t('gameStarted') : t('waitingStart')}</div>
                        </div>
                    </div>

                    <div class="room-info">
                        <span>${t('roomPlayersLabel')}</span>
                        <span class="room-players">${room.playerCount}/${room.maxPlayers}</span>
                    </div>

                    <div class="players-bar" aria-hidden="true">
                        <div class="players-progress" style="width: ${Math.round((room.playerCount / Math.max(1, room.maxPlayers)) * 100)}%;"></div>
                    </div>

                    <div class="room-info" style="margin-top:10px;">
                        <span>${t('betLabel')}</span>
                        <span class="room-entry">${room.entryFee.toFixed(2)}</span>
                    </div>
                    <div class="room-info" style="margin-top:10px;">
                        <span>${t('betRangeLabel')}</span>
                        <span class="room-entry">${(room.entryFee * 20).toFixed(2)} - ${(room.entryFee * 100).toFixed(2)}</span>
                    </div>

                    <div class="room-meta">

                        <div style="flex:1;text-align:right;">
                            <button class="join-btn" onclick="joinRoom('${room.roomId}')" ${room.isFull || room.isGameStarted ? 'disabled' : ''}>
                                ${room.isFull ? t('full') : t('join')}
                                </button>
                                </div>
                                </div>
                                </div>
                                `).join('');

                // <div class="meta-pill">Maks: ${room.maxPlayers}</div>
                console.log(`‚úÖ ${filteredRooms.length} NO LIMIT otaq y√ºkl…ôndi`);
            } catch (error) {
                console.error("‚ùå Room list error:", error);
                setTimeout(() => loadRoomList(), 2000);
            }
        }


        async function joinRoom(roomId) {
            try {
                if (!connection || connection.state !== signalR.HubConnectionState.Connected) {
                    showMessage(t('connectionNotReady'), "error");
                    return;
                }
                await connection.invoke("JoinRoom", roomId, null);
            } catch (error) {
                showMessage(t('joinError', { error: error.message }), "error");
            }
        }

        async function leaveRoom() {
            if (!currentRoomId || !confirm(t('leaveConfirm'))) return;
            try {
                if (!connection || connection.state !== signalR.HubConnectionState.Connected) {
                    showMessage(t('connectionNotReady'), "error");
                    return;
                }
                await connection.invoke("LeaveRoom");
            } catch (error) {
                showMessage(t('leaveError', { error: error.message }), "error");
            }
        }
        // ==================== GAME ACTIONS ====================
        async function fold() {
            try {
                if (!connection || connection.state !== signalR.HubConnectionState.Connected) return;
                await connection.invoke("Fold");
                stopTurnTimer();
            } catch (error) {
                showMessage(t('foldError', { error: error.message }), "error");
            }
        }

        async function call() {
            try {
                if (!connection || connection.state !== signalR.HubConnectionState.Connected) return;
                await connection.invoke("Call");
                stopTurnTimer();
            } catch (error) {
                showMessage(t('callError', { error: error.message }), "error");
            }
        }

        async function raise() {
            const slider = document.getElementById('raiseSlider');
            const amount = parseFloat(slider.value);

            if (!amount || amount <= 0) {
                showMessage(t('enterValidAmount'), "error");
                return;
            }

            let minRaise = currentGameBet === 0 ? roomEntryFee : currentGameBet * 2;
            let maxRaise = roomLimitType === 'PotLimit' ? Math.min(potAmount + currentGameBet, myBalance) : myBalance;

            if (amount < minRaise || amount > maxRaise) {
                showMessage(t('raiseRange', { min: minRaise.toFixed(2), max: maxRaise.toFixed(2) }), "error");
                return;
            }

            try {
                if (!connection || connection.state !== signalR.HubConnectionState.Connected) return;
                await connection.invoke("Raise", amount);
                slider.value = slider.min;
                stopTurnTimer();
            } catch (error) {
                showMessage(t('raiseError', { error: error.message }), "error");
            }
        }

        async function allIn() {
            if (confirm(t('allInConfirm'))) {
                try {
                    if (!connection || connection.state !== signalR.HubConnectionState.Connected) return;
                    await connection.invoke("AllIn");
                    stopTurnTimer();
                } catch (error) {
                    showMessage(t('allInError', { error: error.message }), "error");
                }
            }
        }

        async function showdownCall() {
            try {
                if (!connection || connection.state !== signalR.HubConnectionState.Connected) return;
                await connection.invoke("ShowdownCall");
                stopTurnTimer();
            } catch (error) {
                showMessage(t('showdownCallError', { error: error.message }), "error");
            }
        }

        async function requestShowdown() {
            try {
                await connection.invoke("RequestShowdown");
                stopTurnTimer();
            } catch (error) {
                showMessage(t('showdownError', { error: error.message }), "error");
            }
        }



        async function sendEmoji(emoji) {
            try {
                await connection.invoke("SendEmoji", emoji);
            } catch (error) {
                console.error("‚ùå Emoji error:", error);
            }
        }

        // ==================== TIMER FUNCTIONS ====================
        function startTurnTimer() {
            stopTurnTimer();
            if (currentTurnUserId !== currentUserId || turnTimeRemaining <= 0) return;

            currentTimer = setInterval(() => {
                turnTimeRemaining--;
                updateAllPlayerTimers();

                if (turnTimeRemaining <= 0) {
                    stopTurnTimer();
                    // Avtomatik fold
                    if (currentTurnUserId === currentUserId) {
                        showMessage(t('timeUpAutoFold'), "error");
                        fold(); // Avtomatik fold funksiyasƒ±nƒ± √ßaƒüƒ±r
                    }
                }
            }, 1000);

            updateAllPlayerTimers();
        }
        function stopTurnTimer() {
            if (currentTimer) {
                clearInterval(currentTimer);
                currentTimer = null;
            }
            document.querySelectorAll('.timer-badge').forEach(badge => badge.remove());
        }

        function updateAllPlayerTimers() {
            document.querySelectorAll('.player-avatar').forEach(avatar => {
                const onclickAttr = avatar.getAttribute('onclick');
                if (!onclickAttr) return;

                const match = onclickAttr.match(/toggleEmojiPopup\((\d+)\)/);
                if (!match) return;

                const userId = parseInt(match[1]);
                const oldBadge = avatar.querySelector('.timer-badge');
                if (oldBadge) oldBadge.remove();

                if (userId === currentTurnUserId && turnTimeRemaining > 0) {
                    const badge = document.createElement('div');
                    badge.className = 'timer-badge';
                    if (turnTimeRemaining <= 3) badge.classList.add('warning');
                    badge.textContent = turnTimeRemaining;
                    avatar.appendChild(badge);
                }
            });
        }
        // function updateBetSliderLimits() {
        //     const slider = document.getElementById('betSlider');
        //     const minSpan = document.getElementById('betSliderMin');
        //     const maxSpan = document.getElementById('betSliderMax');

        //     // ‚úÖ Minimum: room entry fee
        //     const minBet = roomEntryFee;

        //     // ‚úÖ Maksimum: room entry fee √ó 20 v…ô balans
        //     let maxBet = roomEntryFee * 20;
        //     if (roomLimitType === 'PotLimit') {
        //         maxBet = Math.min(maxBet, potAmount + currentGameBet);
        //     }
        //     maxBet = Math.min(maxBet, myBalance);

        //     slider.min = minBet;
        //     slider.max = maxBet;
        //     slider.value = minBet;
        //     slider.step = 0.10;

        //     minSpan.textContent = `Min: ${minBet.toFixed(2)}`;
        //     maxSpan.textContent = `Max: ${maxBet.toFixed(2)}`;

        //     document.getElementById('betValue').textContent = `${minBet.toFixed(2)} `;
        //     document.getElementById('betAmount').textContent = `${minBet.toFixed(2)} `;
        // }

        async function bet() {
            const slider = document.getElementById('betSlider');
            const amount = parseFloat(slider.value);

            if (amount < roomEntryFee) {
                showMessage(t('minBet', { amount: roomEntryFee.toFixed(2) }), "error");
                return;
            }

            if (amount > roomEntryFee * 20) {
                showMessage(t('maxBet', { amount: (roomEntryFee * 20).toFixed(2) }), "error");
                return;
            }

            try {
                await connection.invoke("Bet", amount);
                stopTurnTimer();
            } catch (error) {
                showMessage(t('betError', { error: error.message }), "error");
            }
        }
        // ==================== SLIDER LIMITS ====================
        function updateSliderLimits() {
            const slider = document.getElementById('raiseSlider');
            // const sliderMin = document.getElementById('sliderMin');
            // const sliderMax = document.getElementById('sliderMax');

            // ‚úÖ Mƒ∞Nƒ∞MUM RAISE
            let minRaise;
            if (currentGameBet === 0) {
                // ƒ∞lk m…ôrc - entry fee
                minRaise = roomEntryFee > 0 ? roomEntryFee : 0.10;
            } else {
                // Raise - current bet √ó 2
                minRaise = currentGameBet * 2;
            }

            // ‚úÖ MAKSƒ∞MUM RAISE - LIMIT N√ñV√úN∆è G√ñR∆è
            let maxRaise;
            if (roomLimitType === 'PotLimit') {
                // Pot Limit: pot + current bet, amma balansd–∞–Ω √ßox ola bilm…ôz
                const potLimit = potAmount + currentGameBet;
                maxRaise = Math.min(potLimit, myBalance);
            } else {
                // No Limit: yalnƒ±z balans limiti
                maxRaise = myBalance;
            }

            // ‚úÖ ∆èg…ôr maksimum minimumdan azdƒ±rsa (kifay…ôt q…ôd…ôr balans yoxdur)
            if (maxRaise < minRaise) {
                maxRaise = myBalance;
                minRaise = Math.min(minRaise, myBalance);
            }

            // ‚úÖ Slider-i t…ôyin et
            slider.min = minRaise.toFixed(2);
            slider.max = maxRaise.toFixed(2);
            slider.value = minRaise.toFixed(2);
            slider.step = "0.10";

            // sliderMin.textContent = `Min: ${minRaise.toFixed(2)}`;
            // sliderMax.textContent = `Max: ${maxRaise.toFixed(2)}`;

            updateSliderValue();

            console.log('üìä Slider Limits:', {
                minRaise: minRaise.toFixed(2),
                maxRaise: maxRaise.toFixed(2),
                currentBet: currentGameBet,
                pot: potAmount,
                balance: myBalance,
                limitType: roomLimitType
            });
        }

        function updateSliderValue() {
            const slider = document.getElementById('raiseSlider');
            const value = parseFloat(slider.value);
            const raiseValue = document.getElementById('raiseValue');
            if (raiseValue) raiseValue.textContent = value.toFixed(2);
        }

        // ==================== UI UPDATES ====================
        function displayHand() {
            const container = document.getElementById('handCards');
            const scoreDisplay = document.getElementById('handScore');

            if (!myHand || myHand.length === 0) {
                container.innerHTML = '';
                if (scoreDisplay) scoreDisplay.style.display = 'none';
                return;
            }

            const handScore = calculateHandScore(myHand);

            const getSuitClass = (suit) => {
                if (suit === '‚ô•') return 'hearts';
                if (suit === '‚ô¶') return 'diamonds';
                if (suit === '‚ô£') return 'clubs';
                if (suit === '‚ô†') return 'spades';
                const n = suit.toLowerCase();
                if (n.includes('heart') || n.includes('√ºr…ôk')) return 'hearts';
                if (n.includes('diamond') || n.includes('karo')) return 'diamonds';
                if (n.includes('club') || n.includes('√ß…ôt…ôn…ô')) return 'clubs';
                if (n.includes('spade') || n.includes('pika')) return 'spades';
                return 'hearts';
            };

            container.innerHTML = myHand.map(card => `
        <div class="card ${getSuitClass(card.suit)}">
            <div class="card-rank">${card.rank}</div>
            <div class="card-suit">${card.suit}</div>
        </div>
    `).join('');

            if (scoreDisplay) {
                scoreDisplay.textContent = `${t('score')} ${handScore}`;
                scoreDisplay.style.display = 'block';
            }

            console.log('üÉè Hand displayed:', myHand, 'Score:', handScore);
        }
        // ‚úÖ YENƒ∞ - Frontend xal hesablama funksiyasƒ±
        function calculateHandScore(hand) {
            if (!hand || hand.length !== 3) return 0;

            // ‚úÖ Kart d…ôy…ôri funksiyasƒ±
            const getCardValue = (rank) => {
                if (rank === 'A') return 11;
                if (['K', 'Q', 'J'].includes(rank)) return 10;
                return parseInt(rank) || 0;
            };

            // ‚úÖ R…ông…ô g√∂r…ô qrupla≈üdƒ±r
            const suitGroups = {};
            hand.forEach(card => {
                if (!suitGroups[card.suit]) suitGroups[card.suit] = [];
                suitGroups[card.suit].push(card);
            });

            // ‚úÖ Fiqura g√∂r…ô qrupla≈üdƒ±r
            const rankGroups = {};
            hand.forEach(card => {
                if (!rankGroups[card.rank]) rankGroups[card.rank] = [];
                rankGroups[card.rank].push(card);
            });

            // ‚úÖ 1. √ú√áL√ú (3 eyni fiqur) - hamƒ±sƒ±nƒ± topla
            const triple = Object.values(rankGroups).find(g => g.length === 3);
            if (triple) {
                return triple.reduce((sum, card) => sum + getCardValue(card.rank), 0);
            }

            // ‚úÖ 2. C√úT (2 eyni fiqur) - c√ºt√º topla + …ôn y√ºks…ôk kartƒ± …ôlav…ô et
            const pair = Object.values(rankGroups).find(g => g.length === 2);
            if (pair) {
                const pairSum = pair.reduce((sum, card) => sum + getCardValue(card.rank), 0);
                const singleCard = hand.find(c => c.rank !== pair[0].rank);
                return pairSum + getCardValue(singleCard.rank);
            }

            // ‚úÖ 3. FLUSH (3 eyni r…ông) - hamƒ±sƒ±nƒ± topla
            const flush = Object.values(suitGroups).find(g => g.length === 3);
            if (flush) {
                return flush.reduce((sum, card) => sum + getCardValue(card.rank), 0);
            }

            // ‚úÖ 4. 2 eyni r…ông - yalnƒ±z onlarƒ± topla
            const suitPair = Object.values(suitGroups).find(g => g.length === 2);
            if (suitPair) {
                return suitPair.reduce((sum, card) => sum + getCardValue(card.rank), 0);
            }

            // ‚úÖ 5. He√ß biri - yalnƒ±z …ôn y√ºks…ôk kart
            return Math.max(...hand.map(card => getCardValue(card.rank)));
        }

        // ==================== CSS GOLD GLOW EFFECT ====================
        const goldGlowStyle = document.createElement('style');
        goldGlowStyle.textContent = `
    #showdownCallBtn.golden-glow {
        background: linear-gradient(135deg, #ffd700, #ffed4e) !important;
        color: #000 !important;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.8),
                    0 0 40px rgba(255, 215, 0, 0.6),
                    inset 0 0 20px rgba(255, 255, 255, 0.3) !important;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3) !important;
        animation: goldPulse 1.5s ease-in-out infinite;
        font-weight: bold !important;
        border: 2px solid rgba(255, 215, 0, 0.8) !important;
    }

    @keyframes goldPulse {
        0%, 100% {
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8),
                        0 0 40px rgba(255, 215, 0, 0.6),
                        inset 0 0 20px rgba(255, 255, 255, 0.3);
            transform: scale(1);
        }
        50% {
            box-shadow: 0 0 30px rgba(255, 215, 0, 1),
                        0 0 60px rgba(255, 215, 0, 0.8),
                        inset 0 0 30px rgba(255, 255, 255, 0.5);
            transform: scale(1.02);
        }
    }

    #showdownCallBtn:disabled {
        background: #4b5563 !important;
        color: #94a3b8 !important;
        box-shadow: none !important;
        animation: none !important;
        border: 2px solid #64748b !important;
    }
`;
        document.head.appendChild(goldGlowStyle);

        function updatePlayersList(players) {
            const list = document.getElementById('playersList');
            list.innerHTML = players.map(p => `
        <div class="player-item">
            <div>
                <strong style="color: ${p.userId === currentUserId ? '#ffd700' : '#fff'};">
                    ${p.name}${p.userId === currentUserId ? t('youLabel') : ''}
                </strong>
                ${p.hasFolded ? ` <span style="color: #dc2626;">${t('foldTag')}</span>` : ''}
            </div>
            <div>
                <span style="color: #4ade80;">${p.balance.toFixed(2)}</span>
                ${p.currentBet > 0 ? `<span style="color: #ffd700;"> | ${t('betShortLabel')}: ${p.currentBet.toFixed(2)}</span>` : ''}
            </div>
                </div>
        `).join('');
        }



        function showCardsOnTable(playersData) {
            const table = document.getElementById('pokerTable');

            // ‚úÖ H…ôr oyun√ßu √º√ß√ºn kartlarƒ± g√∂st…ôr
            table.querySelectorAll('.player-spot').forEach(spot => {
                const avatar = spot.querySelector('.player-avatar');
                if (!avatar) return;

                const onclickAttr = avatar.getAttribute('onclick');
                if (!onclickAttr) return;

                const match = onclickAttr.match(/toggleEmojiPopup\((\d+)\)/);
                if (!match) return;

                const userId = parseInt(match[1]);

                // Bu oyun√ßunun m…ôlumatƒ±nƒ± tap
                const playerData = playersData.find(p => p.userId === userId);
                if (!playerData) return;

                // K√∂hn…ô kartlarƒ± sil
                const oldCards = spot.querySelector('.player-cards-reveal');
                if (oldCards) oldCards.remove();

                // ‚úÖ Kartlarƒ± g√∂st…ôr
                const cardsContainer = document.createElement('div');
                cardsContainer.className = 'player-cards-reveal';
                cardsContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            animation: revealCards 0.5s ease-out;
        `;

                const getSuitClass = (suit) => {
                    if (suit === '‚ô•') return 'hearts';
                    if (suit === '‚ô¶') return 'diamonds';
                    if (suit === '‚ô£') return 'clubs';
                    if (suit === '‚ô†') return 'spades';
                    return 'hearts';
                };

                cardsContainer.innerHTML = `
            <div style="display: flex; gap: 5px;">
                ${playerData.hand.map(card => `
                    <div class="player-card-mini ${getSuitClass(card.suit)}">
                        <div class="rank">${card.rank}</div>
                        <div class="suit">${card.suit}</div>
                    </div>
                `).join('')}
            </div>
            <div style="
                color: #ffd700;
                font-size: 0.9rem;
                font-weight: bold;
                text-shadow: 0 0 8px rgba(255, 215, 0, 0.8);
                background: rgba(0,0,0,0.7);
                padding: 4px 10px;
                border-radius: 8px;
            ">
                ${playerData.handValue.handName}<br>
                ${t('score')} ${playerData.handScore}
            </div>
        `;

                spot.appendChild(cardsContainer);
            });
        }

        // ‚úÖ CSS animasiya …ôlav…ô et
        const style = document.createElement('style');
        style.textContent = `
            @keyframes revealCards {
                from {
                    opacity: 0;
                    transform: scale(0.8);
                }
                to {
                    opacity: 1;
                    transform: scale(1);
                }
            }
    
            .player-cards-reveal {
                position: relative;
                z-index: 10;
            }
        `;
        document.head.appendChild(style);

        function highlightWinner(winnerUserId) {
            document.querySelectorAll('.player-avatar').forEach(avatar => {
                const onclickAttr = avatar.getAttribute('onclick');
                if (!onclickAttr) return;

                const match = onclickAttr.match(/toggleEmojiPopup\((\d+)\)/);
                if (!match) return;

                const userId = parseInt(match[1]);

                if (userId === winnerUserId) {
                    avatar.style.cssText = `
                box-shadow: 0 0 30px #ffd700, 0 0 60px #ffd700;
                border-color: #ffd700;
                animation: winnerPulse 1s infinite;
            `;

                    // Tac …ôlav…ô et
                    const crown = document.createElement('div');
                    crown.textContent = 'üëë';
                    crown.style.cssText = `
                position: absolute;
                top: -15px;
                left: 50%;
                transform: translateX(-50%);
                font-size: 2rem;
                animation: bounce 0.5s infinite;
            `;
                    avatar.appendChild(crown);
                }
            });
        }

        function showWinnerBanner(data) {
            const banner = document.createElement('div');
            banner.id = 'winnerBanner';
            banner.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, rgba(255, 215, 0, 0.95), rgba(255, 165, 0, 0.95));
        padding: 40px 60px;
        border-radius: 20px;
        z-index: 3000;
        text-align: center;
        box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        animation: bannerAppear 0.5s ease-out;
        border: 5px solid #fff;
    `;

            banner.innerHTML = `
        <div style="font-size: 3rem; margin-bottom: 20px;">üèÜ</div>
        <div style="font-size: 2.5rem; font-weight: bold; color: #000; margin-bottom: 15px;">
            ${t('winnerBannerTitle', { name: data.winnerName })}
        </div>
        <div style="font-size: 2rem; color: #1a1a1a; margin-bottom: 10px;">
            ${data.amount.toFixed(2)}
        </div>
        <div style="font-size: 1.2rem; color: #333;">
            ${data.reason}
        </div>
        <div style="font-size: 0.9rem; color: #666; margin-top: 10px;">
            ${t('commissionLabel', { amount: data.commission.toFixed(2) })}
        </div>
    `;

            document.body.appendChild(banner);
        }

        function clearWinnerDisplay() {
            // Banner-i sil
            const banner = document.getElementById('winnerBanner');
            if (banner) banner.remove();

            // Avatar vurƒüulamalarƒ±nƒ± sil
            document.querySelectorAll('.player-avatar').forEach(avatar => {
                avatar.style.cssText = '';
                const crown = avatar.querySelector('div');
                if (crown && crown.textContent === 'üëë') {
                    crown.remove();
                }
            });

            // Kartlarƒ± gizl…ôt
            document.querySelectorAll('.player-cards-reveal').forEach(cards => {
                cards.style.opacity = '0';
                setTimeout(() => cards.remove(), 500);
            });
        }

        // ‚úÖ CSS animasiyalar
        const winnerStyle = document.createElement('style');
        winnerStyle.textContent = `
    @keyframes winnerPulse {
        0%, 100% {
            box-shadow: 0 0 30px #ffd700, 0 0 60px #ffd700;
        }
        50% {
            box-shadow: 0 0 50px #ffd700, 0 0 100px #ffd700;
        }
    }
    
    @keyframes bounce {
        0%, 100% {
            transform: translateX(-50%) translateY(0);
        }
        50% {
            transform: translateX(-50%) translateY(-10px);
        }
    }
    
    @keyframes bannerAppear {
        from {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.5);
        }
        to {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }
    }
`;
        document.head.appendChild(winnerStyle);

        // function updatePlayersOnTable(players) {
        //     const table = document.getElementById('pokerTable');

        //     // ‚úÖ K√ñHN∆è PLAYER SPOT-LARI Sƒ∞L
        //     table.querySelectorAll('.player-spot').forEach(el => el.remove());

        //     if (!players || players.length === 0) return;

        //     // ‚úÖ CARƒ∞ ƒ∞STƒ∞FAD∆è√áƒ∞Nƒ∞ TAP
        //     const currentUserIndex = players.findIndex(p => p.userId === currentUserId);
        //     if (currentUserIndex === -1) return;

        //     // ‚úÖ OYUN√áULARI SIRALA - Cari istifad…ô√ßi a≈üaƒüƒ±da (bottom)
        //     const reorderedPlayers = [
        //         players[currentUserIndex], // Bottom (m…ôn)
        //         ...players.slice(currentUserIndex + 1), // Saƒüdan ba≈ülayaraq
        //         ...players.slice(0, currentUserIndex) // Soldan ba≈ülayaraq
        //     ];

        //     // ‚úÖ POZƒ∞Sƒ∞YALAR (Saat …ôqr…ôbi)
        //     const positions = [
        //         'bottom',      // 0 - Cari istifad…ô√ßi
        //         'left',        // 1 - Sol
        //         'top-left',    // 2 - Sol yuxarƒ±
        //         'top',         // 3 - Yuxarƒ±
        //         'top-right',   // 4 - Saƒü yuxarƒ±
        //         'right'        // 5 - Saƒü
        //     ];

        //     reorderedPlayers.forEach((player, index) => {
        //         if (index >= positions.length) return;

        //         const spot = document.createElement('div');
        //         spot.className = `player-spot ${positions[index]}`;

        //         const isCurrentUser = player.userId === currentUserId;

        //         // ‚úÖ Kartlarƒ± g√∂st…ôr
        //         let cardsHTML = '';
        //         if (isCurrentUser && myHand.length > 0) {
        //             const handScore = calculateHandScore(myHand);
        //             cardsHTML = `
        //         <div style="display: flex; flex-direction: column; align-items: center; gap: 5px;">
        //             <div style="display: flex; gap: 5px;">
        //                 ${myHand.map(card => `
        //                     <div style="width: 40px; height: 56px; background: #fff; border-radius: 5px; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 0.8rem; font-weight: bold; color: ${card.suit === '‚ô•' || card.suit === '‚ô¶' ? '#dc2626' : '#000'};">
        //                         <div>${card.rank}</div>
        //                         <div style="font-size: 1rem;">${card.suit}</div>
        //                     </div>
        //                 `).join('')}
        //             </div>
        //             <div style="color: #ffd700; font-size: 0.85rem; font-weight: bold; text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);">
        //                 Xal: ${handScore}
        //             </div>
        //         </div>
        //     `;
        //         }

        //         spot.innerHTML = `
        //     <div style="display: flex; align-items: center; gap: 10px; ${positions[index] === 'bottom' ? 'flex-direction: column;' : ''}">
        //         <div style="display: flex; flex-direction: column; align-items: center; gap: 5px;">
        //             <div class="player-avatar ${player.isActive && !player.hasFolded ? 'active' : ''} ${player.hasFolded ? 'folded' : ''}"
        //                  onclick="toggleEmojiPopup(${player.userId})">
        //                 ${player.name.charAt(0).toUpperCase()}
        //                 <div class="emoji-popup" id="emojiPopup${player.userId}">
        //                     <div class="emoji-grid">
        //                         <button class="emoji-btn" onclick="sendEmoji('üòÄ')">üòÄ</button>
        //                         <button class="emoji-btn" onclick="sendEmoji('üòé')">üòé</button>
        //                         <button class="emoji-btn" onclick="sendEmoji('üòÇ')">üòÇ</button>
        //                         <button class="emoji-btn" onclick="sendEmoji('üî•')">üî•</button>
        //                         <button class="emoji-btn" onclick="sendEmoji('üëç')">üëç</button>
        //                         <button class="emoji-btn" onclick="sendEmoji('üí™')">üí™</button>
        //                         <button class="emoji-btn" onclick="sendEmoji('üéâ')">üéâ</button>
        //                         <button class="emoji-btn" onclick="sendEmoji('‚ù§Ô∏è')">‚ù§Ô∏è</button>
        //                     </div>
        //                 </div>
        //             </div>
        //             <div class="player-name">${player.name}</div>
        //             ${player.currentBet > 0 ? `<div class="player-bet">${player.currentBet.toFixed(2)}‚Çº</div>` : ''}
        //         </div>
        //         ${cardsHTML}
        //     </div>
        // `;
        //         console.log('BET:', player.currentBet);

        //         table.appendChild(spot);
        //     });

        //     // ‚úÖ Timer-i yenil…ô
        //     if (currentTurnUserId === currentUserId && turnTimeRemaining > 0) {
        //         updateAllPlayerTimers();
        //     }
        // }


        function updatePlayersOnTable(players) {
            const table = document.getElementById('pokerTable');

            // ‚úÖ K√ñHN∆è PLAYER SPOT-LARI Sƒ∞L
            table.querySelectorAll('.player-spot').forEach(el => el.remove());

            // ‚úÖ MAKSƒ∞MUM 6 OYUN√áU YERƒ∞
            const MAX_SPOTS = 6;

            // ‚úÖ POZƒ∞Sƒ∞YALAR (Saat …ôqr…ôbi)
            const positions = [
                'bottom',      // 0 - Cari istifad…ô√ßi
                'left',        // 1 - Sol
                'top-left',    // 2 - Sol yuxarƒ±
                'top',         // 3 - Yuxarƒ±
                'top-right',   // 4 - Saƒü yuxarƒ±
                'right'        // 5 - Saƒü
            ];

            let reorderedPlayers = [];

            if (players && players.length > 0) {
                // ‚úÖ CARƒ∞ ƒ∞STƒ∞FAD∆è√áƒ∞Nƒ∞ TAP
                const currentUserIndex = players.findIndex(p => p.userId === currentUserId);

                if (currentUserIndex !== -1) {
                    // ‚úÖ OYUN√áULARI SIRALA - Cari istifad…ô√ßi a≈üaƒüƒ±da (bottom)
                    reorderedPlayers = [
                        players[currentUserIndex], // Bottom (m…ôn)
                        ...players.slice(currentUserIndex + 1), // Saƒüdan ba≈ülayaraq
                        ...players.slice(0, currentUserIndex) // Soldan ba≈ülayaraq
                    ];
                } else {
                    reorderedPlayers = players;
                }
            }

            // ‚úÖ B√úT√úN 6 SPOT-U YARAT
            for (let index = 0; index < MAX_SPOTS; index++) {
                const spot = document.createElement('div');
                spot.className = `player-spot ${positions[index]}`;

                const player = reorderedPlayers[index];

                if (!player) {
                    // ‚úÖ BO≈û SPOT - PLACEHOLDER
                    spot.innerHTML = `
                <div style="display: flex; align-items: center; gap: 10px; ${positions[index] === 'bottom' ? 'flex-direction: column;' : ''}">
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 5px;">
                        <div class="player-avatar" style="opacity: 0.3; cursor: default; background: rgba(255, 255, 255, 0.1);">
                            ?
                        </div>
                        <div class="player-name" style="color: #64748b; font-style: italic;">${t('waiting')}</div>
                    </div>
                </div>
            `;
                } else {
                    // ‚úÖ OYUN√áU VAR
                    const isCurrentUser = player.userId === currentUserId;

                    // ‚úÖ Kartlarƒ± g√∂st…ôr
                    let cardsHTML = '';
                    if (isCurrentUser && myHand.length > 0) {
                        const handScore = calculateHandScore(myHand);
                        cardsHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 5px;">
                        <div style="display: flex; gap: 5px;">
                            ${myHand.map(card => `
                                <div style="width: 40px; height: 56px; background: #fff; border-radius: 5px; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 0.8rem; font-weight: bold; color: ${card.suit === '‚ô•' || card.suit === '‚ô¶' ? '#dc2626' : '#000'};">
                                    <div>${card.rank}</div>
                                    <div style="font-size: 1rem;">${card.suit}</div>
                                </div>
                            `).join('')}
                        </div>
                        <div style="color: #ffd700; font-size: 0.85rem; font-weight: bold; text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);">
                            ${t('score')} ${handScore}
                        </div>
                    </div>
                `;
                    }

                    spot.innerHTML = `
                <div style="display: flex; align-items: center; gap: 10px; ${positions[index] === 'bottom' ? 'flex-direction: column;' : ''}">
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 5px;">
                        <div class="player-avatar ${player.isActive && !player.hasFolded ? 'active' : ''} ${player.hasFolded ? 'folded' : ''}"
                             onclick="toggleEmojiPopup(${player.userId})">
                            ${player.name.charAt(0).toUpperCase()}
                            <div class="emoji-popup" id="emojiPopup${player.userId}">
                                <div class="emoji-grid">
                                    <button class="emoji-btn" onclick="sendEmoji('üòÄ')">üòÄ</button>
                                    <button class="emoji-btn" onclick="sendEmoji('üòé')">üòé</button>
                                    <button class="emoji-btn" onclick="sendEmoji('üòÇ')">üòÇ</button>
                                    <button class="emoji-btn" onclick="sendEmoji('üî•')">üî•</button>
                                    <button class="emoji-btn" onclick="sendEmoji('üëç')">üëç</button>
                                    <button class="emoji-btn" onclick="sendEmoji('üí™')">üí™</button>
                                    <button class="emoji-btn" onclick="sendEmoji('üéâ')">üéâ</button>
                                    <button class="emoji-btn" onclick="sendEmoji('‚ù§Ô∏è')">‚ù§Ô∏è</button>
                                </div>
                            </div>
                        </div>
                        <div class="player-name">${player.name}</div>
                        ${player.currentBet > 0 ? `<div class="player-bet">${player.currentBet.toFixed(2)}</div>` : ''}
                    </div>
                    ${cardsHTML}
                </div>
            `;
                }

                table.appendChild(spot);
            }

            // ‚úÖ Timer-i yenil…ô
            if (currentTurnUserId === currentUserId && turnTimeRemaining > 0) {
                updateAllPlayerTimers();
            }
        }



        function toggleEmojiPopup(userId) {
            if (userId !== currentUserId) return;
            const popup = document.getElementById(`emojiPopup${userId}`);
            if (popup) {
                popup.classList.toggle('active');
                if (popup.classList.contains('active')) {
                    setTimeout(() => popup.classList.remove('active'), 5000);
                }
            }
        }

        function showFloatingEmoji(userId, emoji) {
            const spot = Array.from(document.querySelectorAll('.player-spot')).find(el => {
                const avatar = el.querySelector('.player-avatar');
                return avatar && avatar.getAttribute('onclick')?.includes(userId.toString());
            });

            if (!spot) return;

            const floater = document.createElement('div');
            floater.className = 'floating-emoji';
            floater.textContent = emoji;
            floater.style.left = '50%';
            floater.style.top = '50%';
            spot.appendChild(floater);
            setTimeout(() => floater.remove(), 2000);
        }

        // ==================== SHOWDOWN ====================
        function showShowdown(players) {
            const overlay = document.getElementById('showdownOverlay');
            const container = document.getElementById('showdownPlayers');

            const getSuitClass = (suit) => {
                if (suit === '‚ô•') return 'hearts';
                if (suit === '‚ô¶') return 'diamonds';
                if (suit === '‚ô£') return 'clubs';
                if (suit === '‚ô†') return 'spades';
                const n = suit.toLowerCase();
                if (n.includes('heart') || n.includes('√ºr…ôk')) return 'hearts';
                if (n.includes('diamond') || n.includes('karo')) return 'diamonds';
                if (n.includes('club') || n.includes('√ß…ôt…ôn…ô')) return 'clubs';
                if (n.includes('spade') || n.includes('pika')) return 'spades';
                return 'hearts';
            };

            container.innerHTML = players.map(p => {
                // ‚úÖ XALI HESABLA
                const handScore = calculateHandScore(p.hand);

                return `
            <div class="showdown-player">
                <div class="showdown-player-header">
                    <div class="showdown-player-name">${p.name}</div>
                    <div style="font-size: 1.5rem; color: #ffd700;">
                        ${t('score')} ${handScore}
                    </div>
                </div>
                <div class="showdown-hand-name">${p.handValue?.rank || t('handWaiting')}</div>
                <div class="showdown-cards">
                    ${p.hand.map(card => `
                        <div class="showdown-card ${getSuitClass(card.suit)}">
                            <div style="font-size: 1.8rem;">${card.rank}</div>
                            <div style="font-size: 2rem;">${card.suit}</div>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
            }).join('');

            overlay.classList.add('active');
        }
        function handleGameOver(data) {
            const winnerDiv = document.getElementById('showdownWinner');

            const getSuitClass = (suit) => {
                if (suit === '‚ô•') return 'hearts';
                if (suit === '‚ô¶') return 'diamonds';
                if (suit === '‚ô£') return 'clubs';
                if (suit === '‚ô†') return 'spades';
                const normalized = suit.toLowerCase();
                if (normalized.includes('heart') || normalized.includes('√ºr…ôk')) return 'hearts';
                if (normalized.includes('diamond') || normalized.includes('karo')) return 'diamonds';
                if (normalized.includes('club') || normalized.includes('√ß…ôt…ôn…ô')) return 'clubs';
                if (normalized.includes('spade') || normalized.includes('pika')) return 'spades';
                return 'hearts';
            };

            if (data.results && data.results.length > 0) {
                const container = document.getElementById('showdownPlayers');

                container.innerHTML = data.results.map(p => {
                    // ‚úÖ XALI HESABLA
                    const handScore = calculateHandScore(p.hand);

                    return `
                <div class="showdown-player ${p.isWinner ? 'winner' : ''}">
                    <div class="showdown-player-header">
                        <div class="showdown-player-name ${p.isWinner ? 'winner' : ''}">
                            ${p.rank}. ${p.name}
                        </div>
                        ${p.isWinner ? '<div style="color: #ffd700; font-size: 2rem;">üëë</div>' : ''}
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <div class="showdown-hand-name">${p.handName}</div>
                        <div style="font-size: 1.3rem; color: #ffd700; font-weight: bold;">
                            ${t('score')} ${handScore}
                        </div>
                    </div>
                    <div class="showdown-cards">
                        ${p.hand.map(card => `
                            <div class="showdown-card ${getSuitClass(card.suit)}">
                                <div style="font-size: 1.8rem;">${card.rank}</div>
                                <div style="font-size: 2rem;">${card.suit}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
                }).join('');
            }

            if (data.winners) {
                winnerDiv.innerHTML = `
            ${t('winnersLabel', { names: data.winners.join(', ') })}<br>
            ${t('eachWon', { amount: data.amount.toFixed(2) })}
            <div class="commission-info">${t('commission20', { amount: data.commission.toFixed(2) })}</div>
        `;
            } else {
                winnerDiv.innerHTML = `
            ${t('winnerLabel', { name: data.winner })}<br>
            ${t('earningsLabel', { amount: data.amount.toFixed(2) })}
            <div class="commission-info">${t('commission20', { amount: data.commission.toFixed(2) })}</div>
        `;
            }

            document.getElementById('showdownOverlay').classList.add('active');
        }
        function closeShowdown() {
            document.getElementById('showdownOverlay').classList.remove('active');
        }

        // ==================== UTILITY ====================
        function showMessage(text, type = 'info') {
            const msg = document.createElement('div');
            msg.className = `message ${type}`;
            msg.textContent = text;
            document.body.appendChild(msg);

            setTimeout(() => msg.remove(), 4000);
        }

        function resetGameUI() {
            myHand = [];
            displayHand();

            document.getElementById('potAmount').textContent = '0';
            document.getElementById('currentBetAmount').textContent = '0';
            document.getElementById('callAmount').textContent = '0';

            const buttons = ['foldBtn', 'callBtn', 'raiseBtn', 'allInBtn', 'showdownBtn', 'showdownCallBtn'];
            buttons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.disabled = true;
            });

            document.getElementById('raiseSlider').disabled = true;
            document.getElementById('raiseSlider').value = 0;
            updateSliderValue();

            stopTurnTimer();
            turnTimeRemaining = 0;

            // ‚úÖ YENƒ∞ - Pending bets v…ô svara reset
            document.querySelectorAll('.pending-bet').forEach(badge => badge.remove());
            isInSvara = false;
            svaraRound = 0;
        }
        const minimalStyles = document.createElement('style');
        minimalStyles.textContent = `
            .pending-bet {
                animation: pendingPulse 1.5s infinite;
            }

            @keyframes pendingPulse {
                0%, 100% {
                    transform: scale(1);
                    box-shadow: 0 4px 15px rgba(255, 215, 0, 0.6);
                }
                50% {
                    transform: scale(1.05);
                    box-shadow: 0 6px 25px rgba(255, 215, 0, 0.9);
                }
            }
        `;
        document.head.appendChild(minimalStyles);

        function backToGames() {
            window.parent.postMessage({ type: 'BACK_TO_GAMES', payload: {} }, '*');
        }

    </script>
</body>

</html>

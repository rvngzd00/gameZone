<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üé∞ Poker Casino</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/7.0.0/signalr.min.js"></script>
    <link rel="stylesheet" href="./Poker.css">
</head>

<body>
    <div class="container">
        <div class="header">
            <button class="back-btn" onclick="backToGames()">
                ‚Üê
            </button>
            <h1 class="header-title" data-i18n="header_title">POKER</h1>
            <!-- <div class="subtitle">üî¥ No-Limit | üü¢ Limit | üü° Pot-Limit</div> -->
            <div class="user-info">
                <!-- <div id="userName">Y√ºkl…ônir...</div> -->
                <div class="balance"><span id="userBalance">0</span></div>
            </div>
        </div>
        <!-- <div class="user-info">
        </div> -->

        <!-- Buy-in Se√ßimi Modal -->
        <div id="buyInModal"
            style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 9999; align-items: center; justify-content: center;">
            <div
                style="background: #1e293b; padding: 30px; border-radius: 15px; max-width: 400px; width: 90%; box-shadow: 0 10px 50px rgba(0,0,0,0.7);">
                <h3 style="color: #10b981; margin-bottom: 20px; text-align: center; font-size: 1.5rem;"
                    data-i18n="buyin_title">üí∞ Buy-in Amount</h3>

                <div style="margin-bottom: 20px;">
                    <label id="buyInLabel"
                        style="color: #94a3b8; font-size: 14px; display: block; margin-bottom: 8px; font-weight: 600;">
                        Amount (Min: <span id="minBuyIn">0</span> - Max: <span id="maxBuyIn">0</span>)
                    </label>
                    <input type="number" id="buyInInput" style="
                    width: 100%;
                    padding: 12px;
                    border-radius: 8px;
                    border: 2px solid #334155;
                    background: #0f172a;
                    color: white;
                    font-size: 16px;
                    font-weight: bold;
                    box-sizing: border-box;
                " placeholder="Enter amount" inputmode="numeric" data-i18n-placeholder="buyin_placeholder" />
                </div>

                <!-- Hazƒ±r m…ôbl…ôƒül…ôr -->
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 20px;">
                    <button onclick="setQuickBuyIn('min')" style="
                    padding: 10px;
                    background: linear-gradient(135deg, #3b82f6, #1e40af);
                    border: 2px solid transparent;
                    border-radius: 8px;
                    color: white;
                    cursor: pointer;
                    font-weight: 600;
                    transition: all 0.3s;
                " onmouseover="this.style.borderColor='#60a5fa'" onmouseout="this.style.borderColor='transparent'">
                        üîΩ <span data-i18n="min">Min</span>
                    </button>
                    <button onclick="setQuickBuyIn('mid')" style="
                    padding: 10px;
                    background: linear-gradient(135deg, #f59e0b, #d97706);
                    border: 2px solid transparent;
                    border-radius: 8px;
                    color: white;
                    cursor: pointer;
                    font-weight: 600;
                    transition: all 0.3s;
                " onmouseover="this.style.borderColor='#fbbf24'" onmouseout="this.style.borderColor='transparent'">
                        ‚öñÔ∏è <span data-i18n="mid">Mid</span>
                    </button>
                    <button onclick="setQuickBuyIn('max')" style="
                    padding: 10px;
                    background: linear-gradient(135deg, #10b981, #059669);
                    border: 2px solid transparent;
                    border-radius: 8px;
                    color: white;
                    cursor: pointer;
                    font-weight: 600;
                    transition: all 0.3s;
                " onmouseover="this.style.borderColor='#6ee7b7'" onmouseout="this.style.borderColor='transparent'">
                        üîº <span data-i18n="max">Max</span>
                    </button>
                </div>

                <div style="display: flex; gap: 12px;">
                    <button onclick="closeBuyInModal()" style="
                    flex: 1;
                    padding: 12px;
                    background: linear-gradient(135deg, #6b7280, #4b5563);
                    border: none;
                    border-radius: 8px;
                    color: white;
                    font-weight: 600;
                    cursor: pointer;
                    transition: all 0.3s;
                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        ‚ùå <span data-i18n="cancel">Cancel</span>
                    </button>
                    <button onclick="confirmBuyIn()" style="
                    flex: 1;
                    padding: 12px;
                    background: linear-gradient(135deg, #10b981, #059669);
                    border: none;
                    border-radius: 8px;
                    color: white;
                    font-weight: 600;
                    cursor: pointer;
                    transition: all 0.3s;
                " onmouseover="this.style.transform='scale(1.05); box-shadow=0 10px 25px rgba(16, 185, 129, 0.6);'"
                        onmouseout="this.style.transform='scale(1)'">
                        ‚úÖ <span data-i18n="confirm">Confirm</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Re-buy Modal -->
        <div id="reBuyModal" style="display: none;">
            <div
                style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 9999; display: flex; align-items: center; justify-content: center;">
                <div
                    style="background: #1e293b; padding: 30px; border-radius: 15px; max-width: 400px; width: 90%; box-shadow: 0 10px 50px rgba(0,0,0,0.5);">
                    <h3 style="color: #fbbf24; margin-bottom: 20px; text-align: center; font-size: 24px;"
                        data-i18n="rebuy_title">üîÑ Re-buy Amount</h3>

                    <div style="margin-bottom: 20px;">
                        <label id="reBuyLabel"
                            style="color: #94a3b8; font-size: 14px; display: block; margin-bottom: 8px;">
                            Amount (Min: <span id="reBuyMinAmount">0</span>- Max: <span
                                id="reBuyMaxAmount">0</span>)
                        </label>
                        <input type="number" id="reBuyInput"
                            style="width: 100%; padding: 12px; border-radius: 8px; border: 2px solid #334155; background: #0f172a; color: white; font-size: 16px; box-sizing: border-box;"
                            placeholder="Enter amount" data-i18n-placeholder="rebuy_placeholder">
                    </div>

                    <!-- Hazƒ±r m…ôbl…ôƒül…ôr -->
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 20px;">
                        <button onclick="setQuickReBuy('min')"
                            style="padding: 10px; background: #f59e0b; border: none; border-radius: 8px; color: white; cursor: pointer; font-weight: 600;">
                            <span data-i18n="min">Min</span>
                        </button>
                        <button onclick="setQuickReBuy('mid')"
                            style="padding: 10px; background: #f59e0b; border: none; border-radius: 8px; color: white; cursor: pointer; font-weight: 600;">
                            <span data-i18n="mid">Mid</span>
                        </button>
                        <button onclick="setQuickReBuy('max')"
                            style="padding: 10px; background: #f59e0b; border: none; border-radius: 8px; color: white; cursor: pointer; font-weight: 600;">
                            <span data-i18n="max">Max</span>
                        </button>
                    </div>

                    <div style="display: flex; gap: 12px;">
                        <button onclick="closeReBuyModal()"
                            style="flex: 1; padding: 12px; background: #ef4444; border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer;">
                            <span data-i18n="cancel">Cancel</span>
                        </button>
                        <button onclick="confirmReBuy()"
                            style="flex: 1; padding: 12px; background: #10b981; border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer;">
                            <span data-i18n="confirm">Confirm</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>


        <div class="rebuy-countdown-banner" id="rebuyCountdownBanner">
            <div style="font-size: 1.2rem; margin-bottom: 10px;" data-i18n="rebuy_time">‚è≥ RE-BUY TIME</div>
            <div class="rebuy-countdown-timer" id="rebuyCountdownTimer">20</div>
            <div style="font-size: 0.9rem;" id="rebuyWaitingPlayers"></div>
        </div>

        <div id="roomListSection">
            <!-- <h2 style="margin-bottom: 15px;">Poker Otaqlarƒ±</h2> -->
            <div class="room-grid" id="roomGrid">
                <div class="poker-loader" id="pokerLoader">
                    <div class="poker-loader__table">
                        <div class="poker-loader__spotlight"></div>
                        <div class="poker-loader__glow"></div>

                        <div class="loader-card card-left" data-rank="A" data-suit="‚ô•">
                            <!-- <span class="loader-card-rank">A</span> -->
                            <span class="loader-card-suit red">‚ô•</span>
                        </div>
                        <div class="loader-card card-right" data-rank="K" data-suit="‚ô†">
                            <!-- <span class="loader-card-rank">K</span> -->
                            <span class="loader-card-suit black">‚ô†</span>
                        </div>

                        <div class="loader-chip-stack chip-red"></div>
                        <div class="loader-chip-stack chip-blue"></div>
                        <div class="loader-chip-stack chip-gold"></div>
                    </div>

                    <div class="poker-loader__text">
                        <div class="loader-eyebrow" data-i18n="loading_title">Game loading</div>

                        <div class="loader-progress">
                            <div class="loader-progress__bar"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="gameSection" class="game-section">
            <div class="game-info-bar">
                <h2>
                    <span id="gameTypeIcon">üéÆ</span>
                    <span id="currentRoomName">-</span>
                </h2>
                <div class="game-type-description" id="gameTypeDescription">No-Limit Texas Hold'em</div>
                <div class="game-balance-info">
                    <span data-i18n="balance_label">Balance</span>: <span id="gameBalance">0</span> AZN |
                    <span data-i18n="chips_label">Chips</span>: <span id="playerChips" style="color: #4ade80;">0</span>
                </div>
            </div>

            <div class="poker-table" id="pokerTable">
                <div class="table-center">
                    <div class="pot-amount"><span data-i18n="pot_label">POT</span>: <span id="potAmount">0</span></div>
                    <div class="current-bet-display"><span data-i18n="bet_label">Bet</span>: <span id="currentBet">0</span>
                    </div>
                    <div class="community-cards-area" id="communityCards"></div>
                </div>
            </div>

            <div class="hand-cards" id="handCards">
                <div style="color: #ffd700; text-align: center;" data-i18n="wait_cards">Waiting for your cards...</div>
            </div>

            <div class="actions">
                <button class="btn btn-fold" id="foldBtn" onclick="playerAction('fold')" disabled
                    data-i18n="fold">FOLD</button>
                <button class="btn btn-check" id="checkBtn" onclick="playerAction('check')" disabled
                    data-i18n="check">CHECK</button>
                <button class="btn btn-call" id="callBtn" onclick="playerAction('call')" disabled>
                    <span data-i18n="call">CALL</span> <span id="callAmount" style="font-weight: bold; color: #ffd700;"></span>
                </button>
                <button class="btn btn-raise" id="raiseBtn" onclick="openRaisePanel()" disabled
                    data-i18n="raise">RAISE</button>
                <button class="btn btn-rebuy" id="reBuyBtn" onclick="reBuy()" style="display: none;"
                    data-i18n="rebuy_btn">üí∞ RE-BUY</button>
                <button class="btn btn-allin" id="allinBtn" onclick="playerAction('allin')" disabled
                    data-i18n="allin">ALL-IN</button>
                <button class="btn btn-leave" onclick="leaveRoom()" data-i18n="leave">‚ùå EXIT</button>
            </div>
        </div>
    </div>

    <div class="raise-slider-panel" id="raiseSliderPanel">
        <div class="raise-slider-content">
            <div class="raise-amount-display" id="raiseAmountDisplay">$100</div>
            <div class="raise-slider-info">
                <div id="raiseInfoText">Min: <span id="raiseMinAmount">20</span> | Max: <span
                        id="raiseMaxAmount">1000</span></div>
            </div>
            <input type="range" id="raiseSlider" class="raise-slider" min="20" max="1000" step="10" value="100">
            <div class="raise-slider-buttons">
                <button class="btn-slider-ok" onclick="confirmRaise()" data-i18n="ok">‚úì OK</button>
                <button class="btn-slider-cancel" onclick="closeRaisePanel()" data-i18n="cancel_text">‚úó CANCEL</button>
            </div>
        </div>
    </div>

    <script>

        let currentUserToken = null;
        let currentUserData = null;

        console.log('‚ô† [POKER] Script y√ºkl…ôndi');

        let currentLanguage = 'en';

        const translations = {
            en: {
                title: 'üé∞ Poker Casino',
                header_title: 'POKER',
                buyin_title: 'üí∞ Buy-in Amount',
                buyin_label: 'Amount (Min: {min}‚Çº - Max: {max}‚Çº)',
                buyin_placeholder: 'Enter amount',
                rebuy_title: 'üîÑ Re-buy Amount',
                rebuy_label: 'Amount (Min: {min}‚Çº - Max: {max}‚Çº)',
                rebuy_placeholder: 'Enter amount',
                min: 'Min',
                mid: 'Mid',
                max: 'Max',
                cancel: 'Cancel',
                confirm: 'Confirm',
                rebuy_time: '‚è≥ RE-BUY TIME',
                loading: 'Loading...',
                loading_title: 'Game loading',
                loading_subtitle: 'Dealer is setting the felt...',
                loading_charm: 'Two fresh cards, a stack of chips, and your moment to shine.',
                loading_ready: 'Table ready ‚Äî place your bets!',
                balance_label: 'Balance',
                chips_label: 'Chips',
                pot_label: 'POT',
                bet_label: 'Bet',
                wait_cards: 'Waiting for your cards...',
                fold: 'FOLD',
                check: 'CHECK',
                call: 'CALL',
                raise: 'RAISE',
                rebuy_btn: 'üí∞ RE-BUY',
                allin: 'ALL-IN',
                leave: '‚ùå EXIT',
                ok: '‚úì OK',
                cancel_text: '‚úó CANCEL',
                raise_info: 'Min: {min} | Max: {max}',
                room_empty: 'No active rooms right now',
                players_label: 'Players',
                buyin_label_short: 'Buy-in',
                blinds_label: 'Blinds',
                game_active: 'üéÆ Game in progress',
                game_waiting: '‚úÖ Waiting',
                badge_nolimit: 'üî¥ NO-LIMIT',
                badge_limit: 'üü¢ LIMIT',
                badge_potlimit: 'üü° POT-LIMIT',
                join: 'üéØ JOIN',
                join_success: 'You joined the room!',
                timeout_self: '‚è∞ Time is up! Auto FOLD.',
                timeout_other: '‚è∞ {player} timed out (Auto-fold)',
                game_started: 'üéÆ Game started!',
                rebuy_prompt: 'üí∞ Chips are finished! Re-buy now',
                rebuy_success: '‚úÖ {amount}‚Çº added! New chips: {chips}‚Çº',
                rebuy_player: 'üí∞ {player} re-bought',
                waiting_players: 'Waiting: {players}',
                game_over: 'üèÜ {winner} won!\n{hand}\n+{amount} AZN\nCommission: {commission} AZN',
                hand_reset: 'Ready for a new hand',
                cards_arrived: 'üé¥ Your cards arrived!',
                connection_error: 'Connection error: {message}',
                room_info_not_found: 'Room info not found',
                room_info_fail: 'Room info could not be retrieved: {message}',
                invalid_amount: 'Enter a valid amount!',
                min_buyin: 'Minimum buy-in: {min}‚Çº',
                max_buyin: 'Maximum buy-in: {max}‚Çº',
                room_id_missing: 'Room ID not found',
                join_fail: 'Could not join the room: {message}',
                rebuy_modal_fail: 'Re-buy modal could not be opened',
                rebuy_invalid_amount: 'Enter a valid amount',
                min_rebuy: 'Minimum re-buy: {min}‚Çº',
                max_rebuy: 'Maximum re-buy: {max}‚Çº',
                rebuy_fail: 'Re-buy failed: {message}',
                leave_confirm: 'Are you sure you want to leave the room?',
                action_error: 'Error: {message}',
                rebuy_error: 'Re-buy error: {message}',
                auto_fold: '‚è∞ Time is up! AUTO-FOLD executed',
                fold_missing: 'Fold button is not available or disabled',
                room_joined: '{player} joined the room',
                room_left: '{player} left the room',
                room_kicked: '{player} was removed from the room',
                game_type_nolimit: 'No-Limit Texas Hold\'em - Unlimited betting',
                game_type_limit: 'Limit Texas Hold\'em - Fixed betting limits',
                game_type_potlimit: 'Pot-Limit - Max bet = Pot size',
                player_empty: 'Empty',
                chips_text: '{chips} chips',
                bet_text: 'Bet: {bet}',
                fold_status: 'FOLD'
            },
            tr: {
                title: 'üé∞ Poker Casino',
                header_title: 'POKER',
                buyin_title: 'üí∞ Buy-in Tutarƒ±',
                buyin_label: 'Tutar (Min: {min}‚Çº - Max: {max}‚Çº)',
                buyin_placeholder: 'Tutar girin',
                rebuy_title: 'üîÑ Re-buy Tutarƒ±',
                rebuy_label: 'Tutar (Min: {min}‚Çº - Max: {max}‚Çº)',
                rebuy_placeholder: 'Tutar girin',
                min: 'Min',
                mid: 'Orta',
                max: 'Max',
                cancel: 'ƒ∞ptal',
                confirm: 'Onayla',
                rebuy_time: '‚è≥ RE-BUY S√úRESƒ∞',
                loading: 'Y√ºkleniyor...',
                loading_title: 'Oyun y√ºkleniyor',
                loading_subtitle: 'Krupiye masayƒ± hazƒ±rlƒ±yor...',
                loading_charm: 'ƒ∞ki taze kart, bir fi≈ü yƒ±ƒüƒ±nƒ± ve sahne senin.',
                loading_ready: 'Masa hazƒ±r ‚Äî bahislerini koy!',
                balance_label: 'Bakiye',
                chips_label: 'Fi≈ü',
                pot_label: 'POT',
                bet_label: 'Bahis',
                wait_cards: 'Kartlarƒ±nƒ±z bekleniyor...',
                fold: 'FOLD',
                check: 'CHECK',
                call: 'CALL',
                raise: 'RAISE',
                rebuy_btn: 'üí∞ RE-BUY',
                allin: 'ALL-IN',
                leave: '‚ùå √áIK',
                ok: '‚úì TAMAM',
                cancel_text: '‚úó ƒ∞PTAL',
                raise_info: 'Min: {min} | Max: {max}',
                room_empty: '≈ûu anda aktif oda yok',
                players_label: 'Oyuncular',
                buyin_label_short: 'Buy-in',
                blinds_label: 'Blinds',
                game_active: 'üéÆ Oyun devam ediyor',
                game_waiting: '‚úÖ Bekleniyor',
                badge_nolimit: 'üî¥ Limitsiz',
                badge_limit: 'üü¢ Limit',
                badge_potlimit: 'üü° Pot-Limit',
                join: 'üéØ KATIL',
                join_success: 'Odaya katƒ±ldƒ±nƒ±z!',
                timeout_self: '‚è∞ S√ºre bitti! Otomatik FOLD.',
                timeout_other: '‚è∞ {player} s√ºresi doldu (Auto-fold)',
                game_started: 'üéÆ Oyun ba≈üladƒ±!',
                rebuy_prompt: 'üí∞ Fi≈üler bitti! Re-buy yapƒ±n',
                rebuy_success: '‚úÖ {amount}‚Çº eklendi! Yeni fi≈üler: {chips}‚Çº',
                rebuy_player: 'üí∞ {player} re-buy yaptƒ±',
                waiting_players: 'Bekleyen: {players}',
                game_over: 'üèÜ {winner} kazandƒ±!\n{hand}\n+{amount} AZN\nKomisyon: {commission} AZN',
                hand_reset: 'Yeni el i√ßin hazƒ±r',
                cards_arrived: 'üé¥ Kartlarƒ±nƒ±z geldi!',
                connection_error: 'Baƒülantƒ± hatasƒ±: {message}',
                room_info_not_found: 'Oda bilgisi bulunamadƒ±',
                room_info_fail: 'Oda bilgisi alƒ±namadƒ±: {message}',
                invalid_amount: 'Ge√ßerli bir tutar girin!',
                min_buyin: 'Minimum buy-in: {min}‚Çº',
                max_buyin: 'Maksimum buy-in: {max}‚Çº',
                room_id_missing: 'Oda ID bulunamadƒ±',
                join_fail: 'Odaya katƒ±lamadƒ±nƒ±z: {message}',
                rebuy_modal_fail: 'Re-buy penceresi a√ßƒ±lamadƒ±',
                rebuy_invalid_amount: 'Ge√ßerli bir tutar girin',
                min_rebuy: 'Minimum re-buy: {min}‚Çº',
                max_rebuy: 'Maksimum re-buy: {max}‚Çº',
                rebuy_fail: 'Re-buy alƒ±namadƒ±: {message}',
                leave_confirm: 'Odayƒ± terk etmek istediƒüinize emin misiniz?',
                action_error: 'Hata: {message}',
                rebuy_error: 'Re-buy hatasƒ±: {message}',
                auto_fold: '‚è∞ S√ºre bitti! AUTO-FOLD yapƒ±ldƒ±',
                fold_missing: 'Fold d√ºƒümesi yok veya devre dƒ±≈üƒ±',
                room_joined: '{player} odaya katƒ±ldƒ±',
                room_left: '{player} odadan √ßƒ±ktƒ±',
                room_kicked: '{player} odadan √ßƒ±karƒ±ldƒ±',
                game_type_nolimit: 'No-Limit Texas Hold\'em - Limitsiz bahis',
                game_type_limit: 'Limit Texas Hold\'em - Sabit bahis limitleri',
                game_type_potlimit: 'Pot-Limit - Maksimum bahis = Pot',
                player_empty: 'Bo≈ü',
                chips_text: '{chips} chips',
                bet_text: 'Bahis: {bet}',
                fold_status: 'FOLD'
            },
            hi: {
                title: 'üé∞ ‡§™‡•ã‡§ï‡§∞ ‡§ï‡•à‡§∏‡•Ä‡§®‡•ã',
                header_title: 'POKER',
                buyin_title: 'üí∞ ‡§¨‡§æ‡§Ø-‡§á‡§® ‡§∞‡§æ‡§∂‡§ø',
                buyin_label: '‡§∞‡§æ‡§∂‡§ø (‡§®‡•ç‡§Ø‡•Ç‡§®‡§§‡§Æ: {min}‚Çº - ‡§Ö‡§ß‡§ø‡§ï‡§§‡§Æ: {max}‚Çº)',
                buyin_placeholder: '‡§∞‡§æ‡§∂‡§ø ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç',
                rebuy_title: 'üîÑ ‡§∞‡•Ä-‡§¨‡§æ‡§Ø ‡§∞‡§æ‡§∂‡§ø',
                rebuy_label: '‡§∞‡§æ‡§∂‡§ø (‡§®‡•ç‡§Ø‡•Ç‡§®‡§§‡§Æ: {min}‚Çº - ‡§Ö‡§ß‡§ø‡§ï‡§§‡§Æ: {max}‚Çº)',
                rebuy_placeholder: '‡§∞‡§æ‡§∂‡§ø ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç',
                min: '‡§®‡•ç‡§Ø‡•Ç‡§®‡§§‡§Æ',
                mid: '‡§Æ‡§ß‡•ç‡§Ø',
                max: '‡§Ö‡§ß‡§ø‡§ï‡§§‡§Æ',
                cancel: '‡§∞‡§¶‡•ç‡§¶ ‡§ï‡§∞‡•á‡§Ç',
                confirm: '‡§™‡•Å‡§∑‡•ç‡§ü‡§ø ‡§ï‡§∞‡•á‡§Ç',
                rebuy_time: '‚è≥ ‡§∞‡•Ä-‡§¨‡§æ‡§Ø ‡§∏‡§Æ‡§Ø',
                loading: '‡§≤‡•ã‡§° ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à...',
                loading_title: '‡§ó‡•á‡§Æ ‡§≤‡•ã‡§° ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à',
                loading_subtitle: '‡§°‡•Ä‡§≤‡§∞ ‡§Æ‡•á‡§ú‡§º ‡§∏‡§ú‡§æ ‡§∞‡§π‡§æ ‡§π‡•à...',
                loading_charm: '‡§¶‡•ã ‡§®‡§è ‡§™‡§§‡•ç‡§§‡•á, ‡§ö‡§ø‡§™‡•ç‡§∏ ‡§ï‡§æ ‡§¢‡•á‡§∞, ‡§Æ‡•å‡§ï‡§æ ‡§Ü‡§™‡§ï‡§æ ‡§π‡•à‡•§',
                loading_ready: '‡§ü‡•á‡§¨‡§≤ ‡§§‡•à‡§Ø‡§æ‡§∞ ‚Äî ‡§¶‡§æ‡§Ç‡§µ ‡§≤‡§ó‡§æ‡§è‡§Ç!',
                balance_label: '‡§¨‡•à‡§≤‡•á‡§Ç‡§∏',
                chips_label: '‡§ö‡§ø‡§™‡•ç‡§∏',
                pot_label: '‡§™‡•â‡§ü',
                bet_label: '‡§∂‡§∞‡•ç‡§§',
                wait_cards: '‡§Ü‡§™‡§ï‡•á ‡§ï‡§æ‡§∞‡•ç‡§° ‡§ï‡§æ ‡§á‡§Ç‡§§‡§ú‡§æ‡§∞...',
                fold: 'FOLD',
                check: 'CHECK',
                call: 'CALL',
                raise: 'RAISE',
                rebuy_btn: 'üí∞ RE-BUY',
                allin: 'ALL-IN',
                leave: '‚ùå ‡§¨‡§æ‡§π‡§∞ ‡§ú‡§æ‡§è‡§Ç',
                ok: '‚úì ‡§†‡•Ä‡§ï',
                cancel_text: '‚úó ‡§∞‡§¶‡•ç‡§¶',
                raise_info: '‡§®‡•ç‡§Ø‡•Ç‡§®‡§§‡§Æ: {min} | ‡§Ö‡§ß‡§ø‡§ï‡§§‡§Æ: {max}',
                room_empty: '‡§Ö‡§≠‡•Ä ‡§ï‡•ã‡§à ‡§∏‡§ï‡•ç‡§∞‡§ø‡§Ø ‡§∞‡•Ç‡§Æ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à',
                players_label: '‡§ñ‡§ø‡§≤‡§æ‡§°‡§º‡•Ä',
                buyin_label_short: '‡§¨‡§æ‡§Ø-‡§á‡§®',
                blinds_label: '‡§¨‡•ç‡§≤‡§æ‡§á‡§Ç‡§°‡•ç‡§∏',
                game_active: 'üéÆ ‡§ó‡•á‡§Æ ‡§ö‡§≤ ‡§∞‡§π‡§æ ‡§π‡•à',
                game_waiting: '‚úÖ ‡§™‡•ç‡§∞‡§§‡•Ä‡§ï‡•ç‡§∑‡§æ ‡§Æ‡•á‡§Ç',
                badge_nolimit: 'üî¥ ‡§®‡•ã-‡§≤‡§ø‡§Æ‡§ø‡§ü',
                badge_limit: 'üü¢ ‡§≤‡§ø‡§Æ‡§ø‡§ü',
                badge_potlimit: 'üü° ‡§™‡•â‡§ü-‡§≤‡§ø‡§Æ‡§ø‡§ü',
                join: 'üéØ ‡§∂‡§æ‡§Æ‡§ø‡§≤ ‡§π‡•ã‡§Ç',
                join_success: '‡§Ü‡§™ ‡§∞‡•Ç‡§Æ ‡§Æ‡•á‡§Ç ‡§∂‡§æ‡§Æ‡§ø‡§≤ ‡§π‡•ã ‡§ó‡§è!',
                timeout_self: '‚è∞ ‡§∏‡§Æ‡§Ø ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§! ‡§ë‡§ü‡•ã FOLD.',
                timeout_other: '‚è∞ {player} ‡§ï‡§æ ‡§∏‡§Æ‡§Ø ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ (Auto-fold)',
                game_started: 'üéÆ ‡§ó‡•á‡§Æ ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•Å‡§Ü!',
                rebuy_prompt: 'üí∞ ‡§ö‡§ø‡§™‡•ç‡§∏ ‡§ñ‡§§‡•ç‡§Æ! ‡§∞‡•Ä-‡§¨‡§æ‡§Ø ‡§ï‡§∞‡•á‡§Ç',
                rebuy_success: '‚úÖ {amount}‚Çº ‡§ú‡•ã‡§°‡§º‡§æ ‡§ó‡§Ø‡§æ! ‡§®‡§è ‡§ö‡§ø‡§™‡•ç‡§∏: {chips}‚Çº',
                rebuy_player: 'üí∞ {player} ‡§®‡•á ‡§∞‡•Ä-‡§¨‡§æ‡§Ø ‡§ï‡§ø‡§Ø‡§æ',
                waiting_players: '‡§™‡•ç‡§∞‡§§‡•Ä‡§ï‡•ç‡§∑‡§æ ‡§Æ‡•á‡§Ç: {players}',
                game_over: 'üèÜ {winner} ‡§µ‡§ø‡§ú‡•á‡§§‡§æ!\n{hand}\n+{amount} AZN\n‡§ï‡§Æ‡•Ä‡§∂‡§®: {commission} AZN',
                hand_reset: '‡§®‡§à ‡§π‡•à‡§Ç‡§° ‡§ï‡•á ‡§≤‡§ø‡§è ‡§§‡•à‡§Ø‡§æ‡§∞',
                cards_arrived: 'üé¥ ‡§Ü‡§™‡§ï‡•á ‡§ï‡§æ‡§∞‡•ç‡§° ‡§Ü ‡§ó‡§è!',
                connection_error: '‡§ï‡§®‡•á‡§ï‡•ç‡§∂‡§® ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: {message}',
                room_info_not_found: '‡§∞‡•Ç‡§Æ ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡•Ä',
                room_info_fail: '‡§∞‡•Ç‡§Æ ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡•Ä: {message}',
                invalid_amount: '‡§Æ‡§æ‡§®‡•ç‡§Ø ‡§∞‡§æ‡§∂‡§ø ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç!',
                min_buyin: '‡§®‡•ç‡§Ø‡•Ç‡§®‡§§‡§Æ ‡§¨‡§æ‡§Ø-‡§á‡§®: {min}‚Çº',
                max_buyin: '‡§Ö‡§ß‡§ø‡§ï‡§§‡§Æ ‡§¨‡§æ‡§Ø-‡§á‡§®: {max}‚Çº',
                room_id_missing: '‡§∞‡•Ç‡§Æ ID ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ',
                join_fail: '‡§∞‡•Ç‡§Æ ‡§Æ‡•á‡§Ç ‡§∂‡§æ‡§Æ‡§ø‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã ‡§∏‡§ï‡•á: {message}',
                rebuy_modal_fail: '‡§∞‡•Ä-‡§¨‡§æ‡§Ø ‡§µ‡§ø‡§Ç‡§°‡•ã ‡§®‡§π‡•Ä‡§Ç ‡§ñ‡•Å‡§≤ ‡§∏‡§ï‡•Ä',
                rebuy_invalid_amount: '‡§Æ‡§æ‡§®‡•ç‡§Ø ‡§∞‡§æ‡§∂‡§ø ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç',
                min_rebuy: '‡§®‡•ç‡§Ø‡•Ç‡§®‡§§‡§Æ ‡§∞‡•Ä-‡§¨‡§æ‡§Ø: {min}‚Çº',
                max_rebuy: '‡§Ö‡§ß‡§ø‡§ï‡§§‡§Æ ‡§∞‡•Ä-‡§¨‡§æ‡§Ø: {max}‚Çº',
                rebuy_fail: '‡§∞‡•Ä-‡§¨‡§æ‡§Ø ‡§µ‡§ø‡§´‡§≤: {message}',
                leave_confirm: '‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§µ‡§æ‡§ï‡§à ‡§∞‡•Ç‡§Æ ‡§õ‡•ã‡§°‡§º‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?',
                action_error: '‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: {message}',
                rebuy_error: '‡§∞‡•Ä-‡§¨‡§æ‡§Ø ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: {message}',
                auto_fold: '‚è∞ ‡§∏‡§Æ‡§Ø ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§! AUTO-FOLD ‡§π‡•Å‡§Ü',
                fold_missing: 'Fold ‡§¨‡§ü‡§® ‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à ‡§Ø‡§æ ‡§®‡§ø‡§∑‡•ç‡§ï‡•ç‡§∞‡§ø‡§Ø ‡§π‡•à',
                room_joined: '{player} ‡§∞‡•Ç‡§Æ ‡§Æ‡•á‡§Ç ‡§∂‡§æ‡§Æ‡§ø‡§≤ ‡§π‡•Å‡§è',
                room_left: '{player} ‡§∞‡•Ç‡§Æ ‡§õ‡•ã‡§°‡§º ‡§ó‡§è',
                room_kicked: '{player} ‡§ï‡•ã ‡§∞‡•Ç‡§Æ ‡§∏‡•á ‡§π‡§ü‡§æ‡§Ø‡§æ ‡§ó‡§Ø‡§æ',
                game_type_nolimit: 'No-Limit Texas Hold\'em - ‡§Ö‡§∏‡•Ä‡§Æ‡§ø‡§§ ‡§∂‡§∞‡•ç‡§§',
                game_type_limit: 'Limit Texas Hold\'em - ‡§®‡§ø‡§∂‡•ç‡§ö‡§ø‡§§ ‡§∂‡§∞‡•ç‡§§ ‡§∏‡•Ä‡§Æ‡§æ‡§è‡§Ç',
                game_type_potlimit: 'Pot-Limit - ‡§Ö‡§ß‡§ø‡§ï‡§§‡§Æ ‡§∂‡§∞‡•ç‡§§ = ‡§™‡•â‡§ü',
                player_empty: '‡§ñ‡§æ‡§≤‡•Ä',
                chips_text: '{chips} chips',
                bet_text: '‡§∂‡§∞‡•ç‡§§: {bet}',
                fold_status: 'FOLD'
            },
            ru: {
                title: 'üé∞ –ü–æ–∫–µ—Ä –ö–∞–∑–∏–Ω–æ',
                header_title: 'POKER',
                buyin_title: 'üí∞ –°—É–º–º–∞ buy-in',
                buyin_label: '–°—É–º–º–∞ (–ú–∏–Ω: {min}‚Çº - –ú–∞–∫—Å: {max}‚Çº)',
                buyin_placeholder: '–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É',
                rebuy_title: 'üîÑ –°—É–º–º–∞ re-buy',
                rebuy_label: '–°—É–º–º–∞ (–ú–∏–Ω: {min}‚Çº - –ú–∞–∫—Å: {max}‚Çº)',
                rebuy_placeholder: '–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É',
                min: '–ú–∏–Ω',
                mid: '–°—Ä–µ–¥–Ω—è—è',
                max: '–ú–∞–∫—Å',
                cancel: '–û—Ç–º–µ–Ω–∞',
                confirm: '–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å',
                rebuy_time: '‚è≥ –í–†–ï–ú–Ø RE-BUY',
                loading: '–ó–∞–≥—Ä—É–∑–∫–∞...',
                loading_title: '–ò–≥—Ä–∞ –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è',
                loading_subtitle: '–î–∏–ª–µ—Ä –≥–æ—Ç–æ–≤–∏—Ç —Å—É–∫–Ω–æ...',
                loading_charm: '–î–≤–µ —Å–≤–µ–∂–∏–µ –∫–∞—Ä—Ç—ã, —Å—Ç–æ–ø–∫–∞ —Ñ–∏—à–µ–∫ –∏ –≤–∞—à –º–æ–º–µ–Ω—Ç.',
                loading_ready: '–°—Ç–æ–ª –≥–æ—Ç–æ–≤ ‚Äî –¥–µ–ª–∞–π—Ç–µ —Å—Ç–∞–≤–∫–∏!',
                balance_label: '–ë–∞–ª–∞–Ω—Å',
                chips_label: '–§–∏—à–∫–∏',
                pot_label: '–ë–ê–ù–ö',
                bet_label: '–°—Ç–∞–≤–∫–∞',
                wait_cards: '–û–∂–∏–¥–∞–Ω–∏–µ –≤–∞—à–∏—Ö –∫–∞—Ä—Ç...',
                fold: 'FOLD',
                check: 'CHECK',
                call: 'CALL',
                raise: 'RAISE',
                rebuy_btn: 'üí∞ RE-BUY',
                allin: 'ALL-IN',
                leave: '‚ùå –í–´–•–û–î',
                ok: '‚úì OK',
                cancel_text: '‚úó –û–¢–ú–ï–ù–ê',
                raise_info: '–ú–∏–Ω: {min} | –ú–∞–∫—Å: {max}',
                room_empty: '–°–µ–π—á–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∫–æ–º–Ω–∞—Ç',
                players_label: '–ò–≥—Ä–æ–∫–∏',
                buyin_label_short: 'Buy-in',
                blinds_label: '–ë–ª–∞–π–Ω–¥—ã',
                game_active: 'üéÆ –ò–≥—Ä–∞ –∏–¥–µ—Ç',
                game_waiting: '‚úÖ –û–∂–∏–¥–∞–Ω–∏–µ',
                badge_nolimit: 'üî¥ –ë–ï–ó–õ–ò–ú–ò–¢',
                badge_limit: 'üü¢ –õ–ò–ú–ò–¢',
                badge_potlimit: 'üü° –ü–û–¢-–õ–ò–ú–ò–¢',
                join: 'üéØ –í–û–ô–¢–ò',
                join_success: '–í—ã –≤–æ—à–ª–∏ –≤ –∫–æ–º–Ω–∞—Ç—É!',
                timeout_self: '‚è∞ –í—Ä–µ–º—è –≤—ã—à–ª–æ! –ê–≤—Ç–æ FOLD.',
                timeout_other: '‚è∞ –£ {player} –≤—ã—à–ª–æ –≤—Ä–µ–º—è (Auto-fold)',
                game_started: 'üéÆ –ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å!',
                rebuy_prompt: 'üí∞ –§–∏—à–∫–∏ –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å! –°–¥–µ–ª–∞–π—Ç–µ re-buy',
                rebuy_success: '‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ {amount}‚Çº! –ù–æ–≤—ã–µ —Ñ–∏—à–∫–∏: {chips}‚Çº',
                rebuy_player: 'üí∞ {player} —Å–¥–µ–ª–∞–ª re-buy',
                waiting_players: '–û–∂–∏–¥–∞—é—Ç: {players}',
                game_over: 'üèÜ {winner} –ø–æ–±–µ–¥–∏–ª!\n{hand}\n+{amount} AZN\n–ö–æ–º–∏—Å—Å–∏—è: {commission} AZN',
                hand_reset: '–ì–æ—Ç–æ–≤–æ –∫ –Ω–æ–≤–æ–π —Ä–∞–∑–¥–∞—á–µ',
                cards_arrived: 'üé¥ –í–∞—à–∏ –∫–∞—Ä—Ç—ã –ø—Ä–∏—à–ª–∏!',
                connection_error: '–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è: {message}',
                room_info_not_found: '–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∫–æ–º–Ω–∞—Ç–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞',
                room_info_fail: '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫–æ–º–Ω–∞—Ç—É: {message}',
                invalid_amount: '–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—É–º–º—É!',
                min_buyin: '–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π buy-in: {min}‚Çº',
                max_buyin: '–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π buy-in: {max}‚Çº',
                room_id_missing: 'ID –∫–æ–º–Ω–∞—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω',
                join_fail: '–ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ–π—Ç–∏: {message}',
                rebuy_modal_fail: '–û–∫–Ω–æ re-buy –Ω–µ –æ—Ç–∫—Ä—ã–ª–æ—Å—å',
                rebuy_invalid_amount: '–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—É–º–º—É',
                min_rebuy: '–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π re-buy: {min}‚Çº',
                max_rebuy: '–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π re-buy: {max}‚Çº',
                rebuy_fail: 'Re-buy –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω: {message}',
                leave_confirm: '–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –≤—ã–π—Ç–∏ –∏–∑ –∫–æ–º–Ω–∞—Ç—ã?',
                action_error: '–û—à–∏–±–∫–∞: {message}',
                rebuy_error: '–û—à–∏–±–∫–∞ re-buy: {message}',
                auto_fold: '‚è∞ –í—Ä–µ–º—è –≤—ã—à–ª–æ! AUTO-FOLD –≤—ã–ø–æ–ª–Ω–µ–Ω',
                fold_missing: '–ö–Ω–æ–ø–∫–∞ Fold –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ –∏–ª–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∞',
                room_joined: '{player} –≤–æ—à–µ–ª –≤ –∫–æ–º–Ω–∞—Ç—É',
                room_left: '{player} –≤—ã—à–µ–ª –∏–∑ –∫–æ–º–Ω–∞—Ç—ã',
                room_kicked: '{player} –±—ã–ª —É–¥–∞–ª–µ–Ω –∏–∑ –∫–æ–º–Ω–∞—Ç—ã',
                game_type_nolimit: 'No-Limit Texas Hold\'em - –ë–µ–∑–ª–∏–º–∏—Ç–Ω—ã–µ —Å—Ç–∞–≤–∫–∏',
                game_type_limit: 'Limit Texas Hold\'em - –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ª–∏–º–∏—Ç—ã',
                game_type_potlimit: 'Pot-Limit - –ú–∞–∫—Å —Å—Ç–∞–≤–∫–∞ = –±–∞–Ω–∫',
                player_empty: '–ü—É—Å—Ç–æ',
                chips_text: '{chips} chips',
                bet_text: '–°—Ç–∞–≤–∫–∞: {bet}',
                fold_status: 'FOLD'
            },
            ar: {
                title: 'üé∞ ŸÉÿßÿ≤ŸäŸÜŸà ÿ®ŸàŸÉÿ±',
                header_title: 'POKER',
                buyin_title: 'üí∞ ŸÖÿ®ŸÑÿ∫ ÿßŸÑÿ¥ÿ±ÿßÿ°',
                buyin_label: 'ÿßŸÑŸÖÿ®ŸÑÿ∫ (ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ÿØŸÜŸâ: {min}‚Çº - ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ: {max}‚Çº)',
                buyin_placeholder: 'ÿ£ÿØÿÆŸÑ ÿßŸÑŸÖÿ®ŸÑÿ∫',
                rebuy_title: 'üîÑ ŸÖÿ®ŸÑÿ∫ ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ¥ÿ±ÿßÿ°',
                rebuy_label: 'ÿßŸÑŸÖÿ®ŸÑÿ∫ (ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ÿØŸÜŸâ: {min}‚Çº - ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ: {max}‚Çº)',
                rebuy_placeholder: 'ÿ£ÿØÿÆŸÑ ÿßŸÑŸÖÿ®ŸÑÿ∫',
                min: 'ÿ£ÿØŸÜŸâ',
                mid: 'ŸÖÿ™Ÿàÿ≥ÿ∑',
                max: 'ÿ£ŸÇÿµŸâ',
                cancel: 'ÿ•ŸÑÿ∫ÿßÿ°',
                confirm: 'ÿ™ÿ£ŸÉŸäÿØ',
                rebuy_time: '‚è≥ ŸàŸÇÿ™ ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ¥ÿ±ÿßÿ°',
                loading: 'ÿ¨ÿßÿ± ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ...',
                loading_title: 'Ÿäÿ™ŸÖ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÑÿπÿ®ÿ©',
                loading_subtitle: 'ÿßŸÑŸÖŸàÿ≤ÿπ Ÿäÿ¨ŸáŸëÿ≤ ÿßŸÑÿ∑ÿßŸàŸÑÿ©...',
                loading_charm: 'Ÿàÿ±ŸÇÿ™ÿßŸÜ ÿ¨ÿØŸäÿØÿ™ÿßŸÜÿå ÿ±ÿ≤ŸÖÿ© ÿ¥ÿ±ÿßÿ¶ÿ≠ÿå ŸàŸÑÿ≠ÿ∏ÿ™ŸÉ ÿßŸÑŸÖŸÜÿ™ÿ∏ÿ±ÿ©.',
                loading_ready: 'ÿßŸÑÿ∑ÿßŸàŸÑÿ© ÿ¨ÿßŸáÿ≤ÿ© ‚Äî ÿ∂ÿπ ÿ±ŸáÿßŸÜŸÉ!',
                balance_label: 'ÿßŸÑÿ±ÿµŸäÿØ',
                chips_label: 'ÿßŸÑÿ¥ÿ±ÿßÿ¶ÿ≠',
                pot_label: 'POT',
                bet_label: 'ÿßŸÑÿ±ŸáÿßŸÜ',
                wait_cards: 'ÿ®ÿßŸÜÿ™ÿ∏ÿßÿ± ÿ£Ÿàÿ±ÿßŸÇŸÉ...',
                fold: 'FOLD',
                check: 'CHECK',
                call: 'CALL',
                raise: 'RAISE',
                rebuy_btn: 'üí∞ RE-BUY',
                allin: 'ALL-IN',
                leave: '‚ùå ÿÆÿ±Ÿàÿ¨',
                ok: '‚úì ŸÖŸàÿßŸÅŸÇ',
                cancel_text: '‚úó ÿ•ŸÑÿ∫ÿßÿ°',
                raise_info: 'ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ÿØŸÜŸâ: {min} | ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ: {max}',
                room_empty: 'ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ∫ÿ±ŸÅ ŸÜÿ¥ÿ∑ÿ© ÿ≠ÿßŸÑŸäÿßŸã',
                players_label: 'ÿßŸÑŸÑÿßÿπÿ®ŸàŸÜ',
                buyin_label_short: 'ÿ¥ÿ±ÿßÿ°',
                blinds_label: 'ÿßŸÑÿ±ŸáÿßŸÜÿßÿ™',
                game_active: 'üéÆ ÿßŸÑŸÑÿπÿ®ÿ© ÿ¨ÿßÿ±Ÿäÿ©',
                game_waiting: '‚úÖ ÿßŸÜÿ™ÿ∏ÿßÿ±',
                badge_nolimit: 'üî¥ ÿ®ŸÑÿß ÿ≠ÿØ',
                badge_limit: 'üü¢ ÿ≠ÿØ',
                badge_potlimit: 'üü° ÿ≠ÿØ ÿßŸÑÿ®Ÿàÿ™',
                join: 'üéØ ÿßŸÜÿ∂ŸÖ',
                join_success: 'ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÑŸÑÿ∫ÿ±ŸÅÿ©!',
                timeout_self: '‚è∞ ÿßŸÜÿ™ŸáŸâ ÿßŸÑŸàŸÇÿ™! ÿ™ŸÖ FOLD ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã.',
                timeout_other: '‚è∞ ÿßŸÜÿ™ŸáŸâ ŸàŸÇÿ™ {player} (Auto-fold)',
                game_started: 'üéÆ ÿ®ÿØÿ£ÿ™ ÿßŸÑŸÑÿπÿ®ÿ©!',
                rebuy_prompt: 'üí∞ ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑÿ¥ÿ±ÿßÿ¶ÿ≠! ŸÇŸÖ ÿ®ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ¥ÿ±ÿßÿ°',
                rebuy_success: '‚úÖ ÿ™ŸÖÿ™ ÿ•ÿ∂ÿßŸÅÿ© {amount}‚Çº! ÿßŸÑÿ¥ÿ±ÿßÿ¶ÿ≠ ÿßŸÑÿ¨ÿØŸäÿØÿ©: {chips}‚Çº',
                rebuy_player: 'üí∞ ŸÇÿßŸÖ {player} ÿ®ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ¥ÿ±ÿßÿ°',
                waiting_players: 'ÿ®ÿßŸÜÿ™ÿ∏ÿßÿ±: {players}',
                game_over: 'üèÜ ŸÅÿßÿ≤ {winner}!\n{hand}\n+{amount} AZN\nÿßŸÑÿπŸÖŸàŸÑÿ©: {commission} AZN',
                hand_reset: 'ÿ¨ÿßŸáÿ≤ ŸÑŸäÿØ ÿ¨ÿØŸäÿØÿ©',
                cards_arrived: 'üé¥ ŸàÿµŸÑÿ™ ÿ£Ÿàÿ±ÿßŸÇŸÉ!',
                connection_error: 'ÿÆÿ∑ÿ£ ÿßÿ™ÿµÿßŸÑ: {message}',
                room_info_not_found: 'ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ∫ÿ±ŸÅÿ©',
                room_info_fail: 'ÿ™ÿπÿ∞ÿ± ÿ¨ŸÑÿ® ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ∫ÿ±ŸÅÿ©: {message}',
                invalid_amount: 'ÿ£ÿØÿÆŸÑ ŸÖÿ®ŸÑÿ∫ÿßŸã ÿµÿ≠Ÿäÿ≠ÿßŸã!',
                min_buyin: 'ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ÿØŸÜŸâ ŸÑŸÑÿ¥ÿ±ÿßÿ°: {min}‚Çº',
                max_buyin: 'ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑŸÑÿ¥ÿ±ÿßÿ°: {max}‚Çº',
                room_id_missing: 'ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÖÿπÿ±ŸÅ ÿßŸÑÿ∫ÿ±ŸÅÿ©',
                join_fail: 'ÿ™ÿπÿ∞ÿ± ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ: {message}',
                rebuy_modal_fail: 'ÿ™ÿπÿ∞ÿ± ŸÅÿ™ÿ≠ ŸÜÿßŸÅÿ∞ÿ© ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ¥ÿ±ÿßÿ°',
                rebuy_invalid_amount: 'ÿ£ÿØÿÆŸÑ ŸÖÿ®ŸÑÿ∫ÿßŸã ÿµÿ≠Ÿäÿ≠ÿßŸã',
                min_rebuy: 'ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ÿØŸÜŸâ ŸÑÿ•ÿπÿßÿØÿ© ÿßŸÑÿ¥ÿ±ÿßÿ°: {min}‚Çº',
                max_rebuy: 'ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑÿ•ÿπÿßÿØÿ© ÿßŸÑÿ¥ÿ±ÿßÿ°: {max}‚Çº',
                rebuy_fail: 'ŸÅÿ¥ŸÑ ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ¥ÿ±ÿßÿ°: {message}',
                leave_confirm: 'ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ŸÖŸÜ ŸÖÿ∫ÿßÿØÿ±ÿ© ÿßŸÑÿ∫ÿ±ŸÅÿ©ÿü',
                action_error: 'ÿÆÿ∑ÿ£: {message}',
                rebuy_error: 'ÿÆÿ∑ÿ£ ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ¥ÿ±ÿßÿ°: {message}',
                auto_fold: '‚è∞ ÿßŸÜÿ™ŸáŸâ ÿßŸÑŸàŸÇÿ™! ÿ™ŸÖ AUTO-FOLD',
                fold_missing: 'ÿ≤ÿ± Fold ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ ÿ£Ÿà ŸÖÿπÿ∑ŸÑ',
                room_joined: 'ÿßŸÜÿ∂ŸÖ {player} ÿ•ŸÑŸâ ÿßŸÑÿ∫ÿ±ŸÅÿ©',
                room_left: 'ÿ∫ÿßÿØÿ± {player} ÿßŸÑÿ∫ÿ±ŸÅÿ©',
                room_kicked: 'ÿ™ŸÖÿ™ ÿ•ÿ≤ÿßŸÑÿ© {player} ŸÖŸÜ ÿßŸÑÿ∫ÿ±ŸÅÿ©',
                game_type_nolimit: 'No-Limit Texas Hold\'em - ÿ±ŸáÿßŸÜÿßÿ™ ÿ∫Ÿäÿ± ŸÖÿ≠ÿØŸàÿØÿ©',
                game_type_limit: 'Limit Texas Hold\'em - ÿ≠ÿØŸàÿØ ÿ±ŸáÿßŸÜÿßÿ™ ÿ´ÿßÿ®ÿ™ÿ©',
                game_type_potlimit: 'Pot-Limit - ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑŸÑÿ±ŸáÿßŸÜ = ÿßŸÑÿ®Ÿàÿ™',
                player_empty: 'ŸÅÿßÿ±ÿ∫',
                chips_text: '{chips} chips',
                bet_text: 'ÿßŸÑÿ±ŸáÿßŸÜ: {bet}',
                fold_status: 'FOLD'
            },
            uz: {
                title: 'üé∞ Poker Kazino',
                header_title: 'POKER',
                buyin_title: 'üí∞ Buy-in miqdori',
                buyin_label: 'Miqdor (Min: {min}‚Çº - Max: {max}‚Çº)',
                buyin_placeholder: 'Miqdor kiriting',
                rebuy_title: 'üîÑ Re-buy miqdori',
                rebuy_label: 'Miqdor (Min: {min}‚Çº - Max: {max}‚Çº)',
                rebuy_placeholder: 'Miqdor kiriting',
                min: 'Min',
                mid: 'O\'rtacha',
                max: 'Max',
                cancel: 'Bekor qilish',
                confirm: 'Tasdiqlash',
                rebuy_time: '‚è≥ RE-BUY VAQTI',
                loading: 'Yuklanmoqda...',
                loading_title: 'O\'yin yuklanmoqda',
                loading_subtitle: 'Diler stolni tayyorlamoqda...',
                loading_charm: 'Ikki yangi karta, chiplar uyumi va navbatingiz.',
                loading_ready: 'Stol tayyor ‚Äî tikishingizni qo\'ying!',
                balance_label: 'Balans',
                chips_label: 'Chiplar',
                pot_label: 'POT',
                bet_label: 'Tikish',
                wait_cards: 'Kartalaringiz kutilmoqda...',
                fold: 'FOLD',
                check: 'CHECK',
                call: 'CALL',
                raise: 'RAISE',
                rebuy_btn: 'üí∞ RE-BUY',
                allin: 'ALL-IN',
                leave: '‚ùå CHIQ',
                ok: '‚úì OK',
                cancel_text: '‚úó BEKOR',
                raise_info: 'Min: {min} | Max: {max}',
                room_empty: 'Hozirda faol xona yo\'q',
                players_label: 'O\'yinchilar',
                buyin_label_short: 'Buy-in',
                blinds_label: 'Blinds',
                game_active: 'üéÆ O\'yin davom etyapti',
                game_waiting: '‚úÖ Kutmoqda',
                badge_nolimit: 'üî¥ Cheksiz',
                badge_limit: 'üü¢ Limit',
                badge_potlimit: 'üü° Pot-Limit',
                join: 'üéØ QO\'SHIL',
                join_success: 'Xonaga qo\'shildingiz!',
                timeout_self: '‚è∞ Vaqt tugadi! Avto FOLD.',
                timeout_other: '‚è∞ {player} vaqti tugadi (Auto-fold)',
                game_started: 'üéÆ O\'yin boshlandi!',
                rebuy_prompt: 'üí∞ Chiplar tugadi! Re-buy qiling',
                rebuy_success: '‚úÖ {amount}‚Çº qo\'shildi! Yangi chiplar: {chips}‚Çº',
                rebuy_player: 'üí∞ {player} re-buy qildi',
                waiting_players: 'Kutilmoqda: {players}',
                game_over: 'üèÜ {winner} g\'olib bo\'ldi!\n{hand}\n+{amount} AZN\nKomissiya: {commission} AZN',
                hand_reset: 'Yangi qo\'lga tayyor',
                cards_arrived: 'üé¥ Kartalaringiz keldi!',
                connection_error: 'Ulanish xatosi: {message}',
                room_info_not_found: 'Xona ma\'lumoti topilmadi',
                room_info_fail: 'Xona ma\'lumoti olinmadi: {message}',
                invalid_amount: 'To\'g\'ri miqdor kiriting!',
                min_buyin: 'Minimal buy-in: {min}‚Çº',
                max_buyin: 'Maksimal buy-in: {max}‚Çº',
                room_id_missing: 'Xona ID topilmadi',
                join_fail: 'Xonaga qo\'shib bo\'lmadi: {message}',
                rebuy_modal_fail: 'Re-buy oynasi ochilmadi',
                rebuy_invalid_amount: 'To\'g\'ri miqdor kiriting',
                min_rebuy: 'Minimal re-buy: {min}‚Çº',
                max_rebuy: 'Maksimal re-buy: {max}‚Çº',
                rebuy_fail: 'Re-buy amalga oshmadi: {message}',
                leave_confirm: 'Xonadan chiqmoqchimisiz?',
                action_error: 'Xato: {message}',
                rebuy_error: 'Re-buy xatosi: {message}',
                auto_fold: '‚è∞ Vaqt tugadi! AUTO-FOLD bajarildi',
                fold_missing: 'Fold tugmasi yo\'q yoki o\'chirilgan',
                room_joined: '{player} xonaga qo\'shildi',
                room_left: '{player} xonadan chiqdi',
                room_kicked: '{player} xonadan chiqarildi',
                game_type_nolimit: 'No-Limit Texas Hold\'em - Cheksiz tikish',
                game_type_limit: 'Limit Texas Hold\'em - Doimiy limitlar',
                game_type_potlimit: 'Pot-Limit - Maks tikish = Pot',
                player_empty: 'Bo\'sh',
                chips_text: '{chips} chips',
                bet_text: 'Tikish: {bet}',
                fold_status: 'FOLD'
            }
        };

        function t(key, vars = {}) {
            const langPack = translations[currentLanguage] || translations.en;
            let text = langPack[key] || translations.en[key] || key;
            return text.replace(/\{(\w+)\}/g, (_, k) => (vars[k] !== undefined ? vars[k] : `{${k}}`));
        }

        function setLanguage(lang) {
            if (!lang) return;
            const normalized = String(lang).toLowerCase();
            const map = {
                en: 'en',
                english: 'en',
                tr: 'tr',
                turkish: 'tr',
                t√ºrk√ße: 'tr',
                hi: 'hi',
                hindi: 'hi',
                in: 'hi',
                indian: 'hi',
                ru: 'ru',
                russian: 'ru',
                ar: 'ar',
                arabic: 'ar',
                uz: 'uz',
                uzbek: 'uz'
            };
            currentLanguage = map[normalized] || 'en';
            document.documentElement.lang = currentLanguage;
            document.documentElement.dir = currentLanguage === 'ar' ? 'rtl' : 'ltr';
            applyLanguage();
        }

        function updateBuyInLabel() {
            const label = document.getElementById('buyInLabel');
            if (!label) return;
            const min = (currentMinBuyIn || 0).toFixed(2);
            const max = (currentMaxBuyIn || 0).toFixed(2);
            label.innerHTML = t('buyin_label', { min, max })
                .replace(min + '‚Çº', `<span id="minBuyIn">${min}</span>‚Çº`)
                .replace(max + '‚Çº', `<span id="maxBuyIn">${max}</span>‚Çº`);
        }

        function updateReBuyLabel() {
            const label = document.getElementById('reBuyLabel');
            if (!label) return;
            const min = (currentReBuyMin || 0).toFixed(2);
            const max = (currentReBuyMax || 0).toFixed(2);
            label.innerHTML = t('rebuy_label', { min, max })
                .replace(min + '‚Çº', `<span id="reBuyMinAmount">${min}</span>‚Çº`)
                .replace(max + '‚Çº', `<span id="reBuyMaxAmount">${max}</span>‚Çº`);
        }

        function updateRaiseInfoText() {
            const el = document.getElementById('raiseInfoText');
            if (!el) return;
            el.innerHTML = t('raise_info', {
                min: '<span id="raiseMinAmount">' + raiseSliderMin + '</span>',
                max: '<span id="raiseMaxAmount">' + raiseSliderMax + '</span>'
            });
        }

        function applyLanguage() {
            if (translations[currentLanguage]?.title || translations.en.title) {
                document.title = t('title');
            }
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                el.textContent = t(key);
            });
            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.getAttribute('data-i18n-placeholder');
                el.setAttribute('placeholder', t(key));
            });
            updateBuyInLabel();
            updateReBuyLabel();
            updateRaiseInfoText();
            updateGameTypeDisplay();
        }

        window.addEventListener('message', (event) => {
            console.log('üì® [POKER] Message alƒ±ndƒ±:', event.data);

            if (event.data && event.data.payload.language) {
                setLanguage(event.data.payload.language);
            }

            if (event.data && event.data.type === 'INIT_USER') {
                console.log('‚úÖ [POKER] INIT_USER q…ôbul edildi');

                currentUserData = event.data.payload;
                currentUserToken = currentUserData.token;

                console.log('üë§ [POKER] User:', currentUserData.username);
                console.log('üé´ [POKER] Token:', currentUserToken ? 'VAR' : 'YOX');

                // UI-ƒ± yenil…ô
                // document.getElementById('userName').textContent = currentUserData.username;
                document.getElementById('userBalance').textContent = currentUserData.balance.toFixed(2);

                console.log('üöÄ [POKER] initializeSignalR() √ßaƒüƒ±rƒ±lƒ±r...');
                // SignalR ba≈ülat
                initializeSignalR();
            }
        });

        // ============================================
        // getToken funksiyasƒ±nƒ± d…ôyi≈üdir
        // ============================================
        function getToken() {
            return currentUserToken || "";
        }

        // ============================================
        // Qalan kod eyni qalƒ±r
        // ============================================
        let connection = null;
        let currentUserId = 0;
        let currentRoomId = null;
        let myHoleCards = [];
        let currentPlayerName = '';
        let currentGameType = 0;
        let currentBigBlind = 0;
        let currentPot = 0;
        let raiseSliderMin = 0;
        let raiseSliderMax = 1000;
        let rebuyCountdownInterval = null;

        let currentMinBuyIn = 0;
        let currentMaxBuyIn = 0;

        let currentReBuyMin = 0;
        let currentReBuyMax = 0;

        let turnTimeoutTimer = null;
        let currentTurnTimeRemaining = 0;



        document.addEventListener('DOMContentLoaded', async () => {
            // await initializeSignalR();
            setupRaiseSlider();
            applyLanguage();
        });

        document.addEventListener('DOMContentLoaded', () => {
            const buyInInput = document.getElementById('buyInInput');

            if (buyInInput) {
                // Input d…ôyi≈ü…ônd…ô validation et
                buyInInput.addEventListener('input', (e) => {
                    let value = parseFloat(e.target.value) || 0;

                    // Min/Max limitl…ôri uygula
                    if (value < currentMinBuyIn) {
                        value = currentMinBuyIn;
                    }
                    if (value > currentMaxBuyIn) {
                        value = currentMaxBuyIn;
                    }

                    e.target.value = value;
                    console.log(`üíµ Buy-in input: ${value}‚Çº`);
                });
            }
        });
        function setupRaiseSlider() {
            const slider = document.getElementById('raiseSlider');
            const display = document.getElementById('raiseAmountDisplay');
            slider.addEventListener('input', (e) => {
                display.textContent = ' + e.target.value';
            });
        }

        function openRaisePanel() {
            if (currentGameType === 1) {
                playerAction('raise', null);
                return;
            }
            const panel = document.getElementById('raiseSliderPanel');
            const slider = document.getElementById('raiseSlider');
            const display = document.getElementById('raiseAmountDisplay');

            slider.min = raiseSliderMin;
            slider.max = raiseSliderMax;
            slider.value = raiseSliderMin;
            display.textContent = ' + raiseSliderMin';

            document.getElementById('raiseMinAmount').textContent = raiseSliderMin;
            document.getElementById('raiseMaxAmount').textContent = raiseSliderMax;
            updateRaiseInfoText();

            panel.classList.add('active');
        }

        function closeRaisePanel() {
            document.getElementById('raiseSliderPanel').classList.remove('active');
        }

        async function confirmRaise() {
            const amount = parseFloat(document.getElementById('raiseSlider').value);
            closeRaisePanel();
            await playerAction('raise', amount);
        }

        function getToken() {
            const raw = document.cookie.split("; ").find(row => row.startsWith("AuthToken="))?.split("=")[1];
            return raw ? decodeURIComponent(raw).trim() : "";
        }

        async function initializeSignalR() {
            try {
                connection = new signalR.HubConnectionBuilder()
                    .withUrl("https://nehemiah-paginal-alan.ngrok-free.dev/pokerhub", { accessTokenFactory: () => getToken() })
                    .withAutomaticReconnect()
                    .build();
                setupSignalRHandlers();
                await connection.start();
                console.log("‚úÖ Poker SignalR connected");
                await loadRoomList();
            } catch (error) {
                console.error("‚ùå SignalR connection error:", error);
                showMessage(t('connection_error', { message: error.message }), "error");
            }
        }

        function setupSignalRHandlers() {
            connection.on("UserData", (data) => {
                currentUserId = data.userId;
                currentPlayerName = data.fullName;
                // document.getElementById('userName').textContent = data.username;
                document.getElementById('userBalance').textContent = data.balance.toFixed(2);
            });

            connection.on("BalanceUpdated", (balance) => {
                document.getElementById('userBalance').textContent = balance.toFixed(2);
                document.getElementById('gameBalance').textContent = balance.toFixed(2);
            });

            connection.on("JoinedRoom", (data) => {
                currentRoomId = data.roomId;

                window.currentRoomId = data.roomId;
                window.currentRoomInfo = {
                    roomId: data.roomId,
                    roomName: data.roomName,
                    entryFee: data.entryFee || data.minBuyIn || 10,
                    minBuyIn: data.minBuyIn,
                    maxBuyIn: data.maxBuyIn
                };

                document.getElementById('currentRoomName').textContent = data.roomName;
                document.getElementById('gameBalance').textContent = data.balance.toFixed(2);
                document.getElementById('playerChips').textContent = data.chips.toFixed(2);
                if (data.gameType !== undefined) {
                    currentGameType = data.gameType;
                    updateGameTypeDisplay();
                }

                document.getElementById('roomListSection').style.display = 'none';
                document.getElementById('gameSection').classList.add('active');
                showMessage(t('join_success'), "success");
            });

            connection.on("PlayerTimeout", (data) => {
                console.log(`‚è∞ Timeout: ${data.playerName}`);
                console.log(`üì¢ Message: ${data.message}`);

                if (data.playerName === currentPlayerName) {
                    // ‚úÖ √ñz√ºn√ºz√ºn timeout-u
                    showMessage(t('timeout_self'), "error");
                } else {
                    // ‚úÖ Ba≈üqasƒ±nƒ±n timeout-u
                    showMessage(t('timeout_other', { player: data.playerName }), "info");
                }
            });
            connection.on("StreetAdvanced", (data) => {
                clearTimeout(turnTimeoutTimer);
                currentTurnTimeRemaining = 0;
                console.log("üé¥ New street - turn timer reset");
            });
            connection.on("JoinError", (message) => showMessage(message, "error"));
            connection.on("PlayerJoined", (playerName) => showMessage(t('room_joined', { player: playerName }), "info"));
            connection.on("PlayerLeft", (playerName) => showMessage(t('room_left', { player: playerName }), "info"));
            connection.on("PlayerKicked", (playerName) => showMessage(t('room_kicked', { player: playerName }), "info"));

            connection.on("GameStarted", () => {
                const reBuyBtn = document.getElementById('reBuyBtn');
                reBuyBtn.style.display = 'none';
                reBuyBtn.disabled = true;
                showMessage(t('game_started'), "success");
            });

            connection.on("ShowReBuyOption", (seconds) => {
                const reBuyBtn = document.getElementById('reBuyBtn');
                reBuyBtn.style.display = 'inline-block';
                reBuyBtn.disabled = false;
                showMessage(t('rebuy_prompt'), "info");
            });
            connection.on("ReBuyCountdown", (data) => {
                startReBuyCountdown(data.duration, data.playersWaiting);
            });
            connection.on("ReBuySuccess", (data) => {
                console.log("‚úÖ Re-buy successful:", data);

                const reBuyBtn = document.getElementById('reBuyBtn');
                reBuyBtn.style.display = 'none';
                reBuyBtn.disabled = true;

                showMessage(t('rebuy_success', { amount: data.amount, chips: data.chips }), "success");
                updatePlayerChips(data.chips);
                updateBalance(data.balance);
            });

            // üî• Re-buy Error event
            connection.on("ReBuyError", (message) => {
                console.error("‚ùå Re-buy error:", message);
                showMessage(message, "error");
            });

            connection.on("PlayerReBought", (playerName) => showMessage(t('rebuy_player', { player: playerName }), "info"));
            connection.on("WaitingForPlayers", (message) => showMessage(message, "info"));

            connection.on("KickedFromRoom", (reason) => {
                showMessage(reason, "error");
                document.getElementById('gameSection').classList.remove('active');
                document.getElementById('roomListSection').style.display = 'block';
                currentRoomId = null;
                currentGameType = 0;
                resetGameUI();
                loadRoomList();
            });

            connection.on("HoleCards", (cards) => {
                let cardArray = Array.isArray(cards) ? cards : Object.values(cards || {});
                if (cardArray && cardArray.length >= 2) {
                    myHoleCards = cardArray;
                    showMessage(t('cards_arrived'), "success");
                    // GameState yenil…ôm…ôsini g√∂zl…ô
                }
            });

            // SignalR event handlers
            connection.on("DisableActions", (data) => {
                // D√ºym…ôl…ôri deaktiv et
                document.querySelectorAll('.action-button').forEach(btn => {
                    btn.disabled = true;
                    btn.style.opacity = '0.5';
                });

                // Mesaj g√∂st…ôr
                showMessage(data.message, data.duration);
            });

            connection.on("EnableActions", () => {
                // D√ºym…ôl…ôri aktivl…ô≈üdir
                document.querySelectorAll('.action-button').forEach(btn => {
                    btn.disabled = false;
                    btn.style.opacity = '1';
                });
            });
            connection.on("DisableActionsFor", (seconds) => {
                console.log(`üö´ Actions disabled for ${seconds} seconds`);

                // B√ºt√ºn action d√ºym…ôl…ôrini disable et
                document.querySelectorAll('.action-button').forEach(btn => {
                    btn.disabled = true;
                    btn.style.opacity = '0.5';
                    btn.style.cursor = 'not-allowed';
                });

                // X saniy…ô sonra yenid…ôn aktiv et
                setTimeout(() => {
                    document.querySelectorAll('.action-button').forEach(btn => {
                        btn.disabled = false;
                        btn.style.opacity = '1';
                        btn.style.cursor = 'pointer';
                    });
                    console.log("‚úÖ Actions enabled after card reveal");
                }, seconds * 1000);
            });


            connection.on("GameState", (state) => {
                updateGameState(state);

                // ‚úÖ Cari oyun√ßunun turn time-ƒ± var mƒ±?
                if (state.players && state.players.length > 0) {
                    const myPlayer = state.players.find(p => p.name === currentPlayerName);

                    if (myPlayer && myPlayer.isActive && state.players[state.players.findIndex(p => p.name === currentPlayerName)].turnTimeRemaining > 0) {
                        const timeRemaining = state.players[state.players.findIndex(p => p.name === currentPlayerName)].turnTimeRemaining;

                        console.log(`‚è±Ô∏è Turn time remaining: ${timeRemaining}s`);

                        // ‚úÖ Auto-fold timer-i ba≈ülat
                        startAutoFoldTimer(timeRemaining);
                    }
                }
            });

            connection.on("StreetAdvanced", (data) => {
                console.log(`üé¥ New street: ${data.street}`);

                // üî• KARTLAR A√áILIR - D∆èRHAL D√úYM∆èL∆èR DEAKTƒ∞V OLSUN
                disableAllActionButtons();
                console.log("üö´ Buttons disabled - waiting for cards animation");

                // Kartlarƒ± g√∂st…ôr
                displayCommunityCards(data.communityCards);

                // Street m…ôlumatƒ±nƒ± yenil…ô
                currentStreet = data.street;
                updateStreetDisplay(data.street);
            });
            connection.on("PlayerActioned", (data) => {
                if (data.playerName === currentPlayerName && data.action.toLowerCase() === 'fold') {
                    const reBuyBtn = document.getElementById('reBuyBtn');
                    reBuyBtn.style.display = 'none';
                    reBuyBtn.disabled = true;
                }
            });


            connection.on("ShowdownCards", (allPlayerHands) => {
                displayShowdownOnTable(allPlayerHands);
            });

            connection.on("HideShowdownCards", () => {
                hideShowdownCards();
            });

            connection.on("GameOver", (data) => {
                showMessage(t('game_over', {
                    winner: data.winner,
                    hand: data.handName,
                    amount: data.amount.toFixed(2),
                    commission: data.commission.toFixed(2)
                }), "success");
                setTimeout(() => createConfetti(), 500);
                disableActionButtons();
            });

            connection.on("HandReset", () => {
                const reBuyBtn = document.getElementById('reBuyBtn');
                reBuyBtn.style.display = 'none';
                reBuyBtn.disabled = true;
                resetGameUI();
                showMessage(t('hand_reset'), "info");
            });
            connection.on("LeftRoom", () => {
                document.getElementById('gameSection').classList.remove('active');
                document.getElementById('roomListSection').style.display = 'block';
                currentRoomId = null;
                currentGameType = 0;
                resetGameUI();
                loadRoomList();
            });

            connection.on("ActionError", (msg) => showMessage(msg, "error"));
            connection.on("Error", (msg) => showMessage(msg, "error"));
            connection.on("GameError", (msg) => showMessage(msg, "error"));
        }

        function startAutoFoldTimer(timeInSeconds) {
            // ‚úÖ K√∂hn…ô timer-i dayandƒ±r
            if (turnTimeoutTimer) {
                clearTimeout(turnTimeoutTimer);
            }

            currentTurnTimeRemaining = timeInSeconds;

            console.log(`‚è∞ Auto-fold timer ba≈üladƒ±: ${timeInSeconds}s`);

            // ‚úÖ Timeout-dan 1 saniy…ô …ôvv…ôl fold et
            const delayMs = (timeInSeconds - 1) * 1000; // 1s …ôvv…ôl

            turnTimeoutTimer = setTimeout(() => {
                executeAutoFold();
            }, delayMs);
        }
        async function executeAutoFold() {
            console.log("‚è∞ ‚è∞ ‚è∞ VAXT Bƒ∞TDƒ∞! AUTO-FOLD ICRA EDILIR!");

            // ‚úÖ FOLD D√úYM∆èSINI BAS
            const foldBtn = document.getElementById('foldBtn');

            if (foldBtn && !foldBtn.disabled) {
                console.log("‚úÖ Fold d√ºym…ô basƒ±lƒ±yor...");

                // R…ôngi d…ôyi≈ü (visual feedback)
                foldBtn.style.background = '#ef4444';
                foldBtn.style.boxShadow = '0 0 20px rgba(239, 68, 68, 1)';

                // D√ºym…ôyi bas
                foldBtn.click();

                // ‚úÖ Animasyon
                showMessage(t('auto_fold'), "info");

                console.log("‚úÖ Auto-fold tamamlandƒ±");
            } else {
                console.warn(t('fold_missing'));
            }
        }
        function updateTurnCountdown() {
            const gameState = document.querySelector('[data-turn-time]');

            if (currentTurnTimeRemaining > 0) {
                currentTurnTimeRemaining--;

                // ‚úÖ Timer display-i yenil…ô (…ôg…ôr var olarsa)
                const timerDisplay = document.getElementById('turnTimerDisplay');
                if (timerDisplay) {
                    timerDisplay.textContent = `${currentTurnTimeRemaining}s`;

                    // ‚è∞ Son 5 saniy…ôd…ô qƒ±rmƒ±zƒ± et
                    if (currentTurnTimeRemaining <= 5) {
                        timerDisplay.style.color = '#dc2626';
                        timerDisplay.style.textShadow = '0 0 10px rgba(220, 38, 38, 1)';
                    } else {
                        timerDisplay.style.color = '#4ade80';
                        timerDisplay.style.textShadow = '0 0 10px rgba(74, 222, 128, 1)';
                    }
                }
            }
        }

        function updatePlayerChips(chips) {
            const chipsElement = document.getElementById('playerChips');
            if (chipsElement) {
                chipsElement.textContent = chips.toFixed(2) + '‚Çº';
            }
        }

        function updateBalance(balance) {
            const balanceElement = document.getElementById('userBalance');
            if (balanceElement) {
                balanceElement.textContent = balance.toFixed(2) + '‚Çº';
            }
        }

        function showMessage(message, type) {
            // M√∂vcud showMessage funksiyasƒ± v…ô ya sad…ô alert
            console.log(`${type === 'error' ? '‚ùå' : '‚úÖ'} ${message}`);
            alert(message);
        }

        function startReBuyCountdown(duration, playersWaiting) {
            if (rebuyCountdownInterval) {
                clearInterval(rebuyCountdownInterval);
            }

            const banner = document.getElementById('rebuyCountdownBanner');
            const timer = document.getElementById('rebuyCountdownTimer');
            const waitingList = document.getElementById('rebuyWaitingPlayers');

            waitingList.textContent = t('waiting_players', { players: playersWaiting.join(', ') });
            banner.classList.add('active');

            let remaining = duration;
            timer.textContent = remaining;

            rebuyCountdownInterval = setInterval(() => {
                remaining--;
                timer.textContent = remaining;
                if (remaining <= 0) {
                    clearInterval(rebuyCountdownInterval);
                    banner.classList.remove('active');
                }
            }, 1000);
        }

        function displayShowdownOnTable(allPlayerHands) {
            allPlayerHands.forEach(ph => {
                const playerSpots = document.querySelectorAll('.player-spot');
                playerSpots.forEach(spot => {
                    const playerName = spot.querySelector('.player-name')?.textContent?.replace('üîµ ', '');
                    if (playerName === ph.playerName) {
                        const avatar = spot.querySelector('.player-avatar');
                        if (ph.isWinner && avatar) {
                            avatar.classList.add('winner');
                        }

                        let showdownContainer = spot.querySelector('.showdown-cards');
                        if (!showdownContainer) {
                            showdownContainer = document.createElement('div');
                            showdownContainer.className = 'showdown-cards';
                            spot.appendChild(showdownContainer);
                        }

                        const cardsHtml = ph.cards.map(card => {
                            const isRed = card.includes('‚ô•') || card.includes('‚ô¶');
                            const rank = card.slice(0, -1);
                            const suit = card.slice(-1);
                            return `<div class="mini-card-showdown ${isRed ? 'red' : 'black'}">
                                            <div style="font-size: 1rem;">${rank}</div>
                                            <div style="font-size: 1.3rem;">${suit}</div>
                                        </div>`;
                        }).join('');

                        showdownContainer.innerHTML = cardsHtml;
                        setTimeout(() => showdownContainer.classList.add('visible'), 100);

                        let handNameEl = spot.querySelector('.showdown-hand-name');
                        if (!handNameEl) {
                            handNameEl = document.createElement('div');
                            handNameEl.className = 'showdown-hand-name';
                            spot.appendChild(handNameEl);
                        }
                        handNameEl.textContent = ph.handName || '';
                        setTimeout(() => handNameEl.classList.add('visible'), 100);
                    }
                });
            });
        }

        function hideShowdownCards() {
            document.querySelectorAll('.showdown-cards').forEach(el => {
                el.classList.remove('visible');
                setTimeout(() => el.remove(), 500);
            });
            document.querySelectorAll('.showdown-hand-name').forEach(el => {
                el.classList.remove('visible');
                setTimeout(() => el.remove(), 500);
            });
            document.querySelectorAll('.player-avatar.winner').forEach(el => {
                el.classList.remove('winner');
            });
        }

        function updateGameTypeDisplay() {
            const icon = document.getElementById('gameTypeIcon');
            const desc = document.getElementById('gameTypeDescription');
            switch (currentGameType) {
                case 0:
                    icon.textContent = 'üî¥';
                    desc.textContent = t('game_type_nolimit');
                    break;
                case 1:
                    icon.textContent = 'üü¢';
                    desc.textContent = t('game_type_limit');
                    break;
                case 2:
                    icon.textContent = 'üü°';
                    desc.textContent = t('game_type_potlimit');
                    break;
            }
        }

        async function loadRoomList() {
            try {
                const rooms = await connection.invoke("GetRoomList");
                displayRoomList(rooms);
            } catch (error) {
                console.error("Room list error:", error);
            }
        }

        function displayRoomList(rooms) {
            const grid = document.getElementById('roomGrid');
            if (!rooms || rooms.length === 0) {
                grid.innerHTML = `<div style="text-align: center; padding: 40px;">${t('room_empty')}</div>`;
                return;
            }
            const getGameTypeBadge = (type) => {
                switch (type) {
                    case 0: return `<span class="game-type-badge badge-no-limit">${t('badge_nolimit')}</span>`;
                    case 1: return `<span class="game-type-badge badge-limit">${t('badge_limit')}</span>`;
                    case 2: return `<span class="game-type-badge badge-pot-limit">${t('badge_potlimit')}</span>`;
                    default: return '';
                }
            };
            grid.innerHTML = rooms.map(room => `
                    <div class="room-card" onclick="joinRoom('${room.roomId}')">
                        ${getGameTypeBadge(room.gameType)}
                        <h3>${room.roomName}</h3>
                        <div class="room-info">
                            <div>üë• ${t('players_label')}: ${room.playerCount}/${room.maxPlayers}</div>
                            <div>üí∞ ${t('buyin_label_short')}: ${room.buyIn} AZN</div>
                            <div>üé≤ ${t('blinds_label')}: ${room.smallBlind}/${room.bigBlind}</div>
                            <div>üìç ${room.isGameActive ? t('game_active') : t('game_waiting')}</div>
                        </div>
                        <button class="join-btn" onclick="event.stopPropagation(); joinRoom('${room.roomId}')">${t('join')}</button>
                    </div>
                `).join('');
        }



        async function joinRoom(roomId) {
            try {
                currentRoomId = roomId;

                console.log(`üîç Getting room info for: ${roomId}`);

                // Room m…ôlumatlarƒ±nƒ± al
                const roomInfo = await connection.invoke("GetRoomInfo", roomId);

                console.log("üìä Room info received:", roomInfo);

                if (roomInfo) {
                    // ‚úÖ D√úZ∆èLƒ∞≈û: Backend-d…ôn g…ôl…ôn d…ôy…ôrl…ôri istifad…ô et
                    currentMinBuyIn = roomInfo.minBuyIn || roomInfo.entryFee;
                    currentMaxBuyIn = roomInfo.maxBuyIn || (roomInfo.entryFee * 100);

                    console.log(`üí∞ Buy-in range: ${currentMinBuyIn}‚Çº - ${currentMaxBuyIn}‚Çº`);

                    document.getElementById('minBuyIn').textContent = currentMinBuyIn.toFixed(2);
                    document.getElementById('maxBuyIn').textContent = currentMaxBuyIn.toFixed(2);
                    document.getElementById('buyInInput').value = currentMinBuyIn; // Default minimum
                    document.getElementById('buyInInput').min = currentMinBuyIn;
                    document.getElementById('buyInInput').max = currentMaxBuyIn;
                    document.getElementById('buyInInput').step = roomInfo.bigBlind || 1;
                    updateBuyInLabel();

                    // Modal-ƒ± g√∂st…ôr
                    document.getElementById('buyInModal').style.display = 'flex';
                } else {
                    showMessage(t('room_info_not_found'), "error");
                }
            } catch (error) {
                console.error("‚ùå joinRoom error:", error);
                showMessage(t('room_info_fail', { message: error.message }), "error");
            }
        }

        // Hazƒ±r m…ôbl…ôƒül…ôr
        function setQuickBuyIn(type) {
            const input = document.getElementById('buyInInput');

            if (!input) {
                console.error("‚ùå Input field tapƒ±lmadƒ±");
                return;
            }

            let value = 0;

            if (type === 'min') {
                value = currentMinBuyIn;
            } else if (type === 'mid') {
                value = Math.round((currentMinBuyIn + currentMaxBuyIn) / 2);
            } else if (type === 'max') {
                value = currentMaxBuyIn;
            }

            // ‚úÖ D√úZ∆èLƒ∞≈û: Input-un value-sunu d…ôyi≈ü
            input.value = value;

            console.log(`‚úÖ Quick buy-in set: ${value}‚Çº (${type})`);

            // Visual feedback
            input.style.borderColor = '#10b981';
            setTimeout(() => {
                input.style.borderColor = '#334155';
            }, 300);
        }

        // Buy-in t…ôsdiqi
        async function confirmBuyIn() {
            const buyInAmount = parseFloat(document.getElementById('buyInInput').value);

            console.log(`üéØ Confirming buy-in: ${buyInAmount}‚Çº for room: ${currentRoomId}`);

            // ‚úÖ Validasiyalar
            if (isNaN(buyInAmount) || buyInAmount <= 0) {
                showMessage(t('invalid_amount'), "error");
                return;
            }

            if (buyInAmount < currentMinBuyIn) {
                showMessage(t('min_buyin', { min: currentMinBuyIn }), "error");
                return;
            }

            if (buyInAmount > currentMaxBuyIn) {
                showMessage(t('max_buyin', { max: currentMaxBuyIn }), "error");
                return;
            }

            // üî• roomId-ni saxla
            const roomIdToJoin = currentRoomId;

            if (!roomIdToJoin) {
                showMessage(t('room_id_missing'), "error");
                return;
            }

            try {
                console.log(`üöÄ Joining room ${roomIdToJoin} with ${buyInAmount}‚Çº`);

                // Modal-ƒ± baƒüla
                closeBuyInModal();

                // Otaƒüa qo≈üul
                await connection.invoke("JoinRoom", roomIdToJoin, buyInAmount);

                console.log("‚úÖ Successfully joined room");

            } catch (error) {
                console.error("‚ùå JoinRoom error:", error);
                showMessage(t('join_fail', { message: error.message }), "error");
            }
        }

        // Modal-ƒ± baƒüla
        function closeBuyInModal() {
            const modal = document.getElementById('buyInModal');
            if (modal) {
                modal.style.display = 'none';
            }

            // Input-u t…ômizl…ô
            const input = document.getElementById('buyInInput');
            if (input) {
                input.value = '';
            }

            // roomId-ni sƒ±fƒ±rla
            setTimeout(() => {
                currentRoomId = null;
            }, 100);

            console.log("‚ùå Buy-in modal closed");
        }



        async function showReBuyModal() {
            try {
                // ∆èvv…ôlc…ô cari room ID-ni al
                const roomId = getCurrentRoomId(); // Bu funksiya olmalƒ±dƒ±r

                if (!roomId) {
                    showMessage(t('room_info_not_found'), "error");
                    return;
                }

                // üî• VARIANT 1: window.currentRoomInfo saxlanƒ±bsa (t√∂vsiy…ô)
                if (window.currentRoomInfo) {
                    currentReBuyMin = window.currentRoomInfo.entryFee;
                    currentReBuyMax = window.currentRoomInfo.entryFee * 50;

                    console.log(`‚úÖ Using cached room info: ${currentReBuyMin}‚Çº - ${currentReBuyMax}‚Çº`);
                }
                // üî• VARIANT 2: Room m…ôlumatƒ±nƒ± backend-d…ôn al
                else {
                    console.log("üì° Fetching room info from backend...");
                    const roomInfo = await connection.invoke("GetRoomInfo", roomId);

                    if (roomInfo) {
                        currentReBuyMin = roomInfo.entryFee;
                        currentReBuyMax = roomInfo.entryFee * 50;

                        // M…ôlumatƒ± saxla (n√∂vb…ôti d…ôf…ô √º√ß√ºn)
                        window.currentRoomInfo = {
                            roomId: roomInfo.roomId,
                            roomName: roomInfo.roomName,
                            entryFee: roomInfo.entryFee,
                            minBuyIn: roomInfo.minBuyIn,
                            maxBuyIn: roomInfo.maxBuyIn
                        };

                        console.log(`‚úÖ Fetched room info: ${currentReBuyMin}‚Çº - ${currentReBuyMax}‚Çº`);
                    } else {
                        // ∆èg…ôr he√ß n…ô alƒ±nmadƒ±sa, default d…ôy…ôrl…ôr
                        currentReBuyMin = 10;
                        currentReBuyMax = 500;
                        console.warn("‚ö†Ô∏è Using default re-buy values");
                    }
                }

                // Modal-ƒ± doldur
                document.getElementById('reBuyMinAmount').textContent = currentReBuyMin;
                document.getElementById('reBuyMaxAmount').textContent = currentReBuyMax;
                document.getElementById('reBuyInput').value = currentReBuyMin;
                document.getElementById('reBuyInput').min = currentReBuyMin;
                document.getElementById('reBuyInput').max = currentReBuyMax;
                updateReBuyLabel();

                // Modal-ƒ± g√∂st…ôr
                document.getElementById('reBuyModal').style.display = 'flex';

                console.log(`üîÑ Re-buy modal opened (${currentReBuyMin}‚Çº - ${currentReBuyMax}‚Çº)`);

            } catch (error) {
                console.error("‚ùå showReBuyModal error:", error);
                showMessage(t('rebuy_modal_fail'), "error");
            }
        }

        // Hazƒ±r re-buy m…ôbl…ôƒül…ôri
        function setQuickReBuy(type) {
            const input = document.getElementById('reBuyInput');

            if (type === 'min') {
                input.value = currentReBuyMin;
            } else if (type === 'mid') {
                input.value = Math.round((currentReBuyMin + currentReBuyMax) / 2);
            } else if (type === 'max') {
                input.value = currentReBuyMax;
            }

            console.log(`üíµ Quick re-buy selected: ${input.value}‚Çº (${type})`);
        }

        // Re-buy t…ôsdiqi
        async function confirmReBuy() {
            const reBuyAmount = parseFloat(document.getElementById('reBuyInput').value);

            console.log(`üéØ Confirming re-buy: ${reBuyAmount}‚Çº`);

            // Validasiyalar
            if (isNaN(reBuyAmount)) {
                showMessage(t('rebuy_invalid_amount'), "error");
                return;
            }

            if (reBuyAmount < currentReBuyMin) {
                showMessage(t('min_rebuy', { min: currentReBuyMin }), "error");
                return;
            }

            if (reBuyAmount > currentReBuyMax) {
                showMessage(t('max_rebuy', { max: currentReBuyMax }), "error");
                return;
            }

            // Modal-ƒ± baƒüla
            closeReBuyModal();

            try {
                console.log(`üöÄ Re-buying ${reBuyAmount}‚Çº`);
                await connection.invoke("ReBuy", reBuyAmount);
                console.log("‚úÖ Re-buy request sent");
            } catch (error) {
                console.error("‚ùå ReBuy error:", error);
                showMessage(t('rebuy_fail', { message: error.message }), "error");
            }
        }

        // Re-buy modal-ƒ±nƒ± baƒüla
        function closeReBuyModal() {
            document.getElementById('reBuyModal').style.display = 'none';
            console.log("‚ùå Re-buy modal closed");
        }
        function getCurrentRoomId() {
            // ∆èg…ôr global d…ôyi≈ü…ôn varsa
            if (window.currentRoomId) {
                return window.currentRoomId;
            }

            // ∆èg…ôr currentRoomInfo-da saxlanƒ±bsa
            if (window.currentRoomInfo && window.currentRoomInfo.roomId) {
                return window.currentRoomInfo.roomId;
            }

            console.warn("‚ö†Ô∏è Room ID not found");
            return null;
        }

        async function leaveRoom() {
            if (!confirm(t('leave_confirm'))) return;
            try {
                await connection.invoke("LeaveRoom");
            } catch (error) {
                showMessage(t('action_error', { message: error.message || '' }), "error");
            }
        }

        async function playerAction(action, amount = null) {
            clearTimeout(turnTimeoutTimer);
            currentTurnTimeRemaining = 0;
            if (action === 'raise' && currentGameType !== 1 && !amount) {
                openRaisePanel();
                return;
            }
            try {
                await connection.invoke("PlayerAction", action, amount);
            } catch (error) {
                showMessage(t('action_error', { message: error.message }), "error");
            }
        }

        async function reBuy() {
            try {
                // Birba≈üa ReBuy √ßaƒüƒ±rƒ±mƒ± yerin…ô modal a√ß
                await showReBuyModal();
            } catch (error) {
                showMessage(t('rebuy_error', { message: error.message }), "error");
            }
        }

        const reBuyButtonStyle = `
            .btn-rebuy {
                background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
                color: #fff;
                animation: rebuyPulse 2s infinite;
                box-shadow: 0 0 20px rgba(245, 158, 11, 0.6);
            }

            .btn-rebuy:disabled {
                opacity: 0.5;
                cursor: not-allowed;
                animation: none;
            }

            @keyframes rebuyPulse {
                0%, 100% {
                    box-shadow: 0 0 20px rgba(245, 158, 11, 0.6);
                }
                50% {
                    box-shadow: 0 0 40px rgba(245, 158, 11, 1);
                }
            }
            `;

        function displayHoleCards() {
            // Kartlar indi player-spot-da g√∂st…ôrilir
            // Bu funksiyanƒ± yenil…ôyirik
            if (myHoleCards && myHoleCards.length > 0) {
                updatePlayersOnTable(
                    document.querySelectorAll('.player-spot').length > 0 ?
                        Array.from(document.querySelectorAll('.player-spot')).map(spot => ({
                            name: spot.dataset.playerName
                        })) : [],
                    0
                );
            }
        }

        function displayCommunityCards(cards) {
            const container = document.getElementById('communityCards');
            if (!cards || cards.length === 0) {
                container.innerHTML = '';
                return;
            }
            container.innerHTML = cards.map(card => {
                const isRed = card.includes('‚ô•') || card.includes('‚ô¶');
                const rank = card.slice(0, -1);
                const suit = card.slice(-1);
                return `<div class="mini-card ${isRed ? 'red' : 'black'}">
                        <div style="font-size: 1.2rem;">${rank}</div>
                        <div style="font-size: 1.5rem;">${suit}</div>
                    </div>`;
            }).join('');
        }

        function updateGameState(state) {
            if (!state || !state.players) return;

            const myPlayer = state.players.find(p => p.name === currentPlayerName);
            const currentPlayer = state.players[0]; // F…ôrz et ki, active oyun√ßu birinci

            // ‚úÖ Timer display-i g√∂st…ôr/gizl…ô
            const timerDisplay = document.getElementById('turnTimerDisplay');
            if (timerDisplay) {
                if (currentPlayer && currentPlayer.isActive) {
                    timerDisplay.style.display = 'block';
                    timerDisplay.textContent = `${currentPlayer.turnTimeRemaining || 0}s`;

                    // ‚è∞ Son 5 saniy…ôd…ô qƒ±rmƒ±zƒ± et
                    if ((currentPlayer.turnTimeRemaining || 0) <= 5) {
                        timerDisplay.style.color = '#dc2626';
                        timerDisplay.style.textShadow = '0 0 10px rgba(220, 38, 38, 1)';
                        timerDisplay.style.borderColor = '#dc2626';
                    } else {
                        timerDisplay.style.color = '#4ade80';
                        timerDisplay.style.textShadow = '0 0 10px rgba(74, 222, 128, 1)';
                        timerDisplay.style.borderColor = '#4ade80';
                    }
                } else {
                    timerDisplay.style.display = 'none';
                }
            }

            // ‚úÖ Siz sƒ±rada olsunuz
            if (myPlayer && myPlayer.isActive && myPlayer.turnTimeRemaining > 0) {
                startAutoFoldTimer(myPlayer.turnTimeRemaining);
            }
            document.getElementById('potAmount').textContent = (state.pot || 0).toFixed(2);
            document.getElementById('currentBet').textContent = (state.currentBet || 0).toFixed(2);
            currentPot = state.pot || 0;
            currentBigBlind = state.bigBlind || 0;

            if (state.gameType !== undefined) {
                currentGameType = state.gameType;
            }

            if (state.communityCards) displayCommunityCards(state.communityCards);
            if (state.players) updatePlayersOnTable(state.players, state.dealerIndex || 0);

            if (!myPlayer) return;

            document.getElementById('playerChips').textContent = myPlayer.chips.toFixed(2);

            // üî¥ RE-BUY D√úYM∆è KONTROL
            const reBuyBtn = document.getElementById('reBuyBtn');
            if (myPlayer.chips <= 0 && !myPlayer.hasFolded) {
                // √áipl…ôr bitdi V∆è fold etm…ôdiyiniz
                reBuyBtn.style.display = 'inline-block';
                reBuyBtn.disabled = false;
            } else {
                // Oyun zamanƒ± v…ô ya fold-da - Gƒ∞ZL∆è ET
                reBuyBtn.style.display = 'none';
                reBuyBtn.disabled = true;
            }
            const activePlayers = state.players.filter(p => p.isInHand && !p.hasFolded);
            const isLastPlayer = activePlayers.length === 1 && activePlayers[0].name === currentPlayerName;
            const isMyTurn = myPlayer.isActive && myPlayer.isInHand && !myPlayer.hasFolded;
            const needToCall = state.currentBet > myPlayer.currentBet;
            const callAmount = state.currentBet - myPlayer.currentBet;

            const callBtn = document.getElementById('callBtn');
            const callAmountSpan = document.getElementById('callAmount');
            if (needToCall && callAmount > 0) {
                callAmountSpan.textContent = `(${callAmount.toFixed(2)})`;
            } else {
                callAmountSpan.textContent = '';
            }

            document.getElementById('foldBtn').disabled = !isMyTurn || isLastPlayer;
            callBtn.disabled = !isMyTurn || !needToCall;
            document.getElementById('checkBtn').disabled = !isMyTurn || needToCall;
            document.getElementById('raiseBtn').disabled = !isMyTurn;

            const minRaise = Math.max(state.currentBet * 2, currentBigBlind * 2);
            const maxRaise = currentGameType === 2 ? currentPot + state.currentBet : myPlayer.chips;
            raiseSliderMin = minRaise;
            raiseSliderMax = maxRaise;
            updateRaiseInfoText();

            const allinBtn = document.getElementById('allinBtn');
            if (currentGameType === 1) {
                allinBtn.style.display = 'none';
            } else {
                allinBtn.style.display = 'inline-block';
                allinBtn.disabled = !isMyTurn;
            }
        }

        window.addEventListener('beforeunload', () => {
            if (turnTimeoutTimer) {
                clearTimeout(turnTimeoutTimer);
            }
        });
        function updatePlayersOnTable(players, dealerIndex) {
            const table = document.getElementById('pokerTable');
            const existingSpots = table.querySelectorAll('.player-spot');
            existingSpots.forEach(spot => spot.remove());

            if (!players || players.length === 0) return;

            // Cari oyun√ßunu tap
            const myIndex = players.findIndex(p => p.name === currentPlayerName);
            if (myIndex === -1) return;

            // Pozisiyalar: cari oyun√ßu h…ômi≈ü…ô bottom-da
            const positions = ['bottom', 'left', 'top-left', 'top', 'top-right', 'right', 'bottom-right', 'bottom-left'];

            // Oyun√ßularƒ± yenid…ôn sƒ±rala ki, cari oyun√ßu 0-cƒ± indeksd…ô olsun
            const reorderedPlayers = [
                ...players.slice(myIndex),
                ...players.slice(0, myIndex)
            ];

            // Dealer indeksini yenid…ôn hesabla
            const newDealerIndex = (dealerIndex - myIndex + players.length) % players.length;

            reorderedPlayers.forEach((player, index) => {
                if (index >= positions.length) return;
                const spot = document.createElement('div');
                spot.className = `player-spot ${positions[index]}`;
                spot.dataset.playerName = player.name;
                const isDealer = index === newDealerIndex;
                const activeClass = player.isActive && !player.hasFolded ? 'active' : '';
                const foldedClass = player.hasFolded ? 'folded' : '';

                // Kartlarƒ± g√∂st…ôr (yalnƒ±z cari oyun√ßu √º√ß√ºn v…ô ya showdown zamanƒ±)
                let cardsHtml = '';
                if (index === 0 && myHoleCards && myHoleCards.length > 0) {
                    // Cari oyun√ßunun kartlarƒ±
                    cardsHtml = '<div class="player-cards">';
                    myHoleCards.forEach(card => {
                        const isRed = card.includes('‚ô•') || card.includes('‚ô¶');
                        const rank = card.slice(0, -1);
                        const suit = card.slice(-1);
                        cardsHtml += `<div class="player-card ${isRed ? 'red' : 'black'}">
                                <div style="font-size: 1rem;">${rank}</div>
                                <div style="font-size: 1.3rem;">${suit}</div>
                            </div>`;
                    });
                    cardsHtml += '</div>';
                }

                spot.innerHTML = `
                        <div class="player-avatar ${foldedClass} ${activeClass}">
                            ${player.name ? player.name.charAt(0).toUpperCase() : '?'}
                        </div>
                        <div class="player-name">${isDealer ? 'üîµ ' : ''}${player.name || t('player_empty')}</div>
                        <div class="player-chips">${t('chips_text', { chips: (player.chips || 0).toFixed(2) })}</div>
                        ${player.currentBet > 0 ? `<div class="player-bet">${t('bet_text', { bet: player.currentBet.toFixed(2) })}</div>` : ''}
                        ${player.hasFolded ? `<div class="player-status">${t('fold_status')}</div>` : ''}
                        ${cardsHtml}
                    `;
                table.appendChild(spot);
            });
        }

        function disableActionButtons() {
            document.getElementById('foldBtn').disabled = true;
            document.getElementById('callBtn').disabled = true;
            document.getElementById('checkBtn').disabled = true;
            document.getElementById('raiseBtn').disabled = true;
            document.getElementById('allinBtn').disabled = true;
            const callAmountSpan = document.getElementById('callAmount');
            if (callAmountSpan) callAmountSpan.textContent = '';
            closeRaisePanel();
        }

        function resetGameUI() {
            myHoleCards = [];
            document.getElementById('communityCards').innerHTML = '';
            document.getElementById('potAmount').textContent = '0';
            document.getElementById('currentBet').textContent = '0';
            disableActionButtons();
            closeRaisePanel();
            hideShowdownCards();
            if (rebuyCountdownInterval) {
                clearInterval(rebuyCountdownInterval);
                document.getElementById('rebuyCountdownBanner').classList.remove('active');
            }
        }

        function createConfetti() {
            for (let i = 0; i < 50; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + '%';
                    confetti.style.background = ['#ffd700', '#4ade80', '#3b82f6', '#f59e0b'][Math.floor(Math.random() * 4)];
                    confetti.style.animationDelay = Math.random() * 0.5 + 's';
                    document.body.appendChild(confetti);
                    setTimeout(() => confetti.remove(), 3000);
                }, i * 30);
            }
        }

        function showMessage(text, type = 'info') {
            const existing = document.querySelectorAll('.message');
            existing.forEach(msg => msg.remove());
            const message = document.createElement('div');
            message.className = `message ${type}`;
            message.textContent = text;
            document.body.appendChild(message);
            setTimeout(() => {
                message.style.animation = 'slideInRight 0.3s ease-out reverse';
                setTimeout(() => message.remove(), 300);
            }, 4000);
        }
        function backToGames() {
            window.parent.postMessage({ type: 'BACK_TO_GAMES', payload: {} }, '*');
        }
        window.addEventListener('beforeunload', async () => {
            if (currentRoomId && connection) {
                try {
                    await connection.invoke("LeaveRoom");
                } catch (error) {
                    console.error("Error leaving room:", error);
                }
            }
        });

        setInterval(() => {
            if (!currentRoomId && document.getElementById('roomListSection').style.display !== 'none') {
                loadRoomList();
            }
        }, 10000);
    </script>
</body>

</html>

<!DOCTYPE html>
<html lang="az">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" /> -->

    <title>Okey</title>
    <link rel="stylesheet" href="./Okey.css">
</head>

<body>
    <div class="okey-game-container">
        <!-- <div class="notification">asjkdlfalsdjf</div> -->
        <div id="roomListScreen" class="screen active">
            <div class="room-list-container">
                <div class="header">

                    <!-- <h1>OKEY 51</h1> -->
                    <div class="header-title">OKEY 51</div>
                    <!-- <span class="user-name" id="userName">Y√ºkl…ônir...</span> -->
                    <span class="user-balance" id="userBalance">0</span>

                </div>

                <div class="rooms-grid" id="roomsGrid">
                    <div class="loading-container">
                        <div class="loading"></div>
                        <p class="loading-text">Otaqlar y√ºkl…ônir...</p>
                    </div>
                </div>
                <!-- Lobby Bet Modal -->
                <div id="lobbyBetModal" class="modal-overlay" style="display: none;"
                    onclick="if(event.target === this) closeLobbyBetModal()">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h2>Bet Se√ß</h2>
                            <button class="modal-close" onclick="closeLobbyBetModal()">√ó</button>
                        </div>
                        <div class="modal-body" id="lobbyBetOptions"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="gameScreen" class="screen">
            <div class="game-container">
                <div class="game-header">
                    <div class="game-info">
                        <span id="roomNameDisplay">Otaq</span>
                        <!-- <span id="gameModeDisplay" style="color: #f39c12;">Mod: 51</span> -->
                        <span id="potAmountDisplay" style="color: #27ae60;">Pot: 0</span>
                    </div>
                    <div class="current-user-info">
                        <div class="player-name" id="myPlayerName">You</div>
                        <!-- <div class="player-score" id="myScore">101</div> -->
                    </div>
                    <button id="leaveRoomBtn" class="btn btn-danger">√áƒ±x</button>
                    <!-- <button onclick="goFullscreen()" class="btn btn-danger">Tam Ekran</button> -->
                </div>

                <div class="game-table">
                    <div class="player-section player-section-top">
                        <div class="player-deck-section">

                            <div class="player-deck-top" id="playerInfoTop">
                                <div class="player-avatar">üë§</div>
                                <div class="player-details detail-sides">
                                    <div id="topPlayerName" class="player-name">G√∂zl…ôyir</div>
                                    <!-- <div class="player-score">101</div> -->
                                </div>
                            </div>
                        </div>
                        <!-- <div class="discard-zone" id="discardZoneTop">üóëÔ∏è</div> -->
                        <div class="discard-zone" id="discardZoneTop" onclick="tryDrawFromTopPlayer()">
                            <!-- üóëÔ∏è -->
                        </div>

                    </div>

                    <div class="player-section player-section-right">
                        <div class="discard-zone discard-zone-right" id="discardZoneRight">
                        </div>
                        <div class="player-deck-section deck-right">
                            <div class="player-deck-right" id="playerInfoRight">
                                <div class="player-avatar avatar-right">üë§</div>
                                <div class="player-details detail-sides">
                                    <div id="rightPlayerName" class="player-name">G√∂zl…ôyir</div>
                                    <!-- <div class="player-score">101</div> -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="player-section player-section-bottom">
                        <div class="my-board-container" id="myBoardContainer">

                            <div class="my-actions">
                                <!-- <button id="declareWinBtn" class="btn-action btn-success" disabled>üèÜ Bitir</button> -->
                                <!-- <div class="player-info active" id="myPlayerInfo">
                                    <div class="player-avatar">üòä</div>
                                    <div class="player-details">
                                        <div class="player-name" id="myPlayerName">You</div>
                                        <div class="player-score" id="myScore">101</div>
                                    </div>
                                </div> -->
                                <!-- <button id="sortBtn" class="btn-action">Sƒ±rala</button> -->
                            </div>

                            <div class="my-board" id="myBoard">
                                <!-- <div class="tile-row" id="myRow1"></div>
                                <div class="tile-row" id="myRow2"></div> -->
                            </div>
                            <div class="my-discard-zone" id="myDiscardZone">
                                <!-- üóëÔ∏è
                                <div class="discard-label">BURAYA<br>AT</div> -->
                            </div>
                        </div>


                    </div>

                    <div class="player-section player-section-left">
                        <div class="player-deck-section deck-left">
                            <div class="player-deck-left" id="playerInfoLeft">
                                <div class="player-avatar avatar-left">üë§</div>
                                <div class="player-details detail-sides">
                                    <div id="leftPlayerName" class="player-name">G√∂zl…ôyir</div>
                                    <!-- <div class="player-score">101</div> -->
                                </div>
                            </div>
                        </div>
                        <div class="discard-zone clickable discard-zone-left" id="discardZoneLeft"
                            onclick="tryDrawFromLeftPlayer()">
                        </div>
                    </div>

                    <div class="center-area">
                        <!-- <div class="indicator-wrapper"> -->
                        <!-- <div class="indicator-label">üéØ OKEY</div> -->
                        <!-- </div> -->

                        <div id="indicatorTile"></div>
                        <div class="deck-stack" id="deckStack">
                            <div class="deck-tile-layer" id="deckCountLabel"></div>
                            <!-- <div class="deck-label" id="deckCountLabel">106</div> -->
                        </div>
                        <!-- <div id="notification" class="notification"></div> -->

                        <!-- ‚úÖ Qazanan kombinasiya modalƒ± -->
                        <div id="winModal" class="win-modal">
                            <h2>üèÜ QAZANAN KOMBƒ∞NASƒ∞YA</h2>
                            <div id="winMeldsContainer" class="win-melds"></div>
                        </div>
                        <div class="indicator-wrapper">
                            <!-- <div class="indicator-label">üÉè JOKER</div>
                        <div id="jokerTile"></div> -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- <div id="notification" class="notification"></div> -->


    </div>

    <script src="https://cdn.jsdelivr.net/npm/@microsoft/signalr@latest/dist/browser/signalr.min.js"></script>
    <script>

        playerPositions = {
            top: topPlayerName,
            right: rightPlayerName,
            left: leftPlayerName
        }

        function getPlayerNames() {
            return {
                top: document.getElementById("topPlayerName")?.textContent || "",
                right: document.getElementById("rightPlayerName")?.textContent || "",
                left: document.getElementById("leftPlayerName")?.textContent || ""
            };
        }
        let activeTimerInterval = null;
        function findPosition(username) {
            // Top player
            const topName = document.getElementById("topPlayerName")?.textContent;
            if (topName === username) return 'top';

            // Right player
            const rightName = document.getElementById("rightPlayerName")?.textContent;
            if (rightName === username) return 'right';

            // Left player
            const leftName = document.getElementById("leftPlayerName")?.textContent;
            if (leftName === username) return 'left';

            // Bottom (√∂z√ºm)
            const myName = document.querySelector('#myPlayerName')?.textContent;
            if (myName === username) return 'bottom';

            console.log(topName, rightName, leftName, myName);

            return null;
        }
        // function showTimer(username, seconds) {
        //     const position = findPosition(username);
        //     if (!position) {
        //         console.log('‚ùå Player tapƒ±lmadƒ±:', username);
        //         return;
        //     }

        //     console.log(`‚úÖ Timer: ${username} (${position}) - ${seconds}s`);

        //     // ∆èvv…ôlki timer-l…ôri sil
        //     document.querySelectorAll('.player-deck-top, .player-deck-right, .player-deck-left').forEach(el => {
        //         el.classList.remove('timer-active');
        //     });

        //     // Element tap
        //     let deckElement = null;
        //     if (position === 'top') deckElement = document.querySelector('.player-deck-top');
        //     if (position === 'right') deckElement = document.querySelector('.player-deck-right');
        //     if (position === 'left') deckElement = document.querySelector('.player-deck-left');

        //     if (deckElement) {
        //         const percentage = (seconds / 30) * 100; // 30 = max saniy…ô

        //         // R…ông
        //         let color = '#4CAF50'; // ya≈üƒ±l
        //         if (seconds <= 10) color = '#FFC107'; // sarƒ±
        //         if (seconds <= 5) color = '#f44336'; // qƒ±rmƒ±zƒ±

        //         deckElement.style.setProperty('--timer-progress', `${percentage}%`);
        //         deckElement.style.setProperty('--timer-color', color);
        //         deckElement.classList.add('timer-active');
        //     }
        // }

        function showTimer(username, seconds) {
            const position = findPosition(username);
            if (!position) {
                console.log('‚ùå Player tapƒ±lmadƒ±:', username);
                return;
            }

            console.log(`‚úÖ Timer ba≈üladƒ±: ${username} (${position}) - ${seconds}s`);

            // K√∂hn…ô timer-i dayandƒ±r
            if (activeTimerInterval) {
                clearInterval(activeTimerInterval);
                activeTimerInterval = null;
            }

            // ∆èvv…ôlki timer-l…ôri sil
            document.querySelectorAll('.player-deck-top, .player-deck-right, .player-deck-left,.my-board').forEach(el => {
                el.classList.remove('timer-active');
            });

            // Element tap
            let deckElement = null;
            if (position === 'top') deckElement = document.querySelector('.player-deck-top');
            if (position === 'right') deckElement = document.querySelector('.player-deck-right');
            if (position === 'left') deckElement = document.querySelector('.player-deck-left');
            if (position === 'bottom') deckElement = document.querySelector('.my-board');

            if (!deckElement) return;

            let remainingSeconds = seconds;
            const maxSeconds = 33;

            // ƒ∞lk g√∂st…ôr
            updateTimerDisplay(deckElement, remainingSeconds, maxSeconds);

            // H…ôr saniy…ô yenil…ô
            activeTimerInterval = setInterval(() => {
                remainingSeconds--;

                if (remainingSeconds <= 0) {
                    clearInterval(activeTimerInterval);
                    activeTimerInterval = null;
                    deckElement.classList.remove('timer-active');
                    console.log('‚è∞ Timer bitdi');
                    return;
                }

                updateTimerDisplay(deckElement, remainingSeconds, maxSeconds);
            }, 1000);
        }
        function updateTimerDisplay(element, seconds, maxSeconds) {
            const percentage = (seconds / maxSeconds) * 100;

            // R…ông
            let color = '#4CAF50'; // ya≈üƒ±l
            if (seconds <= 10) color = '#FFC107'; // sarƒ±
            if (seconds <= 5) color = '#f44336'; // qƒ±rmƒ±zƒ±

            element.style.setProperty('--timer-progress', `${percentage}%`);
            element.style.setProperty('--timer-color', color);
            element.classList.add('timer-active');

            console.log(`‚è±Ô∏è Timer: ${seconds}s (${percentage.toFixed(0)}%)`);
        }
        // function clearTimers() {
        //     document.querySelectorAll('.player-deck-top, .player-deck-right, .player-deck-left').forEach(el => {
        //         el.classList.remove('timer-active');
        //     });
        // }

        function clearTimers() {
            if (activeTimerInterval) {
                clearInterval(activeTimerInterval);
                activeTimerInterval = null;
            }

            document.querySelectorAll('.player-deck-top, .player-deck-right, .player-deck-left').forEach(el => {
                el.classList.remove('timer-active');
            });

            console.log('üßπ Timer-l…ôr t…ômizl…ôndi');
        }

        window.addEventListener("load", () => {
            setTimeout(() => {
                window.scrollTo(0, 1);
            }, 100);
        });

        function checkTileCollision(x1, y1, x2, y2) {
            const tileWidth = 36;
            const tileHeight = 55;
            const tolerance = 4; // ‚úÖ 4px overlap-…ô icaz…ô ver

            return !(
                x1 + tileWidth - tolerance <= x2 ||
                x2 + tileWidth - tolerance <= x1 ||
                y1 + tileHeight - tolerance <= y2 ||
                y2 + tileHeight - tolerance <= y1
            );
        }

        function isPositionValid(x, y, currentIdx) {
            for (let i = 0; i < myHand.length; i++) {
                if (i === currentIdx) continue;
                const otherTile = myHand[i];
                if (otherTile.x !== undefined && otherTile.y !== undefined) {
                    if (checkTileCollision(x, y, otherTile.x, otherTile.y)) {
                        return false;
                    }
                }
            }
            return true;
        }

        function findNearestValidPosition(targetX, targetY, currentIdx, boardWidth) {
            const tileWidth = 36;
            const gap = 3; // ‚úÖ Gap artƒ±rƒ±ldƒ±
            const ROW_1_Y = 10;
            const ROW_2_Y = 70; // ‚úÖ Yenil…ôndi

            const snappedY = targetY < 55 ? ROW_1_Y : ROW_2_Y; // ‚úÖ Threshold yenil…ôndi

            // ‚úÖ ƒ∞lk olaraq d…ôqiq yeri yoxla
            if (isPositionValid(targetX, snappedY, currentIdx)) {
                return { x: targetX, y: snappedY };
            }

            // ‚úÖ X eksenind…ô ki√ßik addƒ±mlarla yoxla
            const step = tileWidth + gap;
            const maxSearchDistance = boardWidth;

            for (let offset = gap; offset < maxSearchDistance; offset += step) {
                // Saƒüa yoxla
                let testX = targetX + offset;
                if (testX + tileWidth <= boardWidth && isPositionValid(testX, snappedY, currentIdx)) {
                    return { x: testX, y: snappedY };
                }

                // Sola yoxla
                testX = targetX - offset;
                if (testX >= 0 && isPositionValid(testX, snappedY, currentIdx)) {
                    return { x: testX, y: snappedY };
                }
            }

            // ‚úÖ Ba≈üqa s…ôtird…ô yoxla
            const alternateY = snappedY === ROW_1_Y ? ROW_2_Y : ROW_1_Y;

            if (isPositionValid(targetX, alternateY, currentIdx)) {
                return { x: targetX, y: alternateY };
            }

            for (let offset = gap; offset < maxSearchDistance; offset += step) {
                let testX = targetX + offset;
                if (testX + tileWidth <= boardWidth && isPositionValid(testX, alternateY, currentIdx)) {
                    return { x: testX, y: alternateY };
                }

                testX = targetX - offset;
                if (testX >= 0 && isPositionValid(testX, alternateY, currentIdx)) {
                    return { x: testX, y: alternateY };
                }
            }

            // ‚úÖ He√ß yer tapƒ±lmasa, orijinal yeri saxla
            return {
                x: myHand[currentIdx].x || targetX,
                y: myHand[currentIdx].y || snappedY
            };
        }
        function autoArrangeTiles() {
            const tileWidth = 36;
            const gap = 3;
            const startX = 10;
            const maxPerRow = 8;
            const ROW_1_Y = 10;
            const ROW_2_Y = 70;

            myHand.forEach((tile, idx) => {
                const row = Math.floor(idx / maxPerRow);
                const col = idx % maxPerRow;

                tile.x = startX + col * (tileWidth + gap);
                tile.y = row === 0 ? ROW_1_Y : ROW_2_Y;

                // ‚úÖ Cache-…ô …ôlav…ô et
                tilePositions[tile.id] = { x: tile.x, y: tile.y };
            });
        }


        // ‚úÖ Bu yeni d…ôyi≈ü…ônl…ôri ∆èLAV∆è ET (scriptƒ±n …ôvv…ôlind…ô):
        let IFRAME_TOKEN = null;
        let IFRAME_USER = null;

        // ‚úÖ Bu yeni funksiyanƒ± ∆èLAV∆è ET (getToken yerin…ô):
        function waitForUserData() {
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('User data timeout'));
                }, 10000); // 10 saniy…ô g√∂zl…ô

                const checkData = () => {
                    if (IFRAME_TOKEN && IFRAME_USER) {
                        clearTimeout(timeout);
                        clearInterval(interval);
                        resolve();
                    }
                };

                const interval = setInterval(checkData, 100);
                checkData(); // ƒ∞lk yoxlama
            });
        }

        // ‚úÖ postMessage dinl…ôyicisini ∆èLAV∆è ET (DOMContentLoaded-d…ôn ∆èVV∆èL):
        window.addEventListener('message', (event) => {
            // üîí T…ôhl√ºk…ôsizlik: yalnƒ±z eyni origin-d…ôn q…ôbul et
            if (event.origin !== window.location.origin) {
                console.warn('‚ö†Ô∏è Rejected message from:', event.origin);
                return;
            }

            const { type, payload } = event.data;

            if (type === 'INIT_USER') {
                log('üì• React-dan user data alƒ±ndƒ±:', payload);

                IFRAME_TOKEN = payload.token;
                IFRAME_USER = {
                    id: payload.userId,
                    username: payload.username,
                    fullName: payload.fullName,
                    balance: payload.balance
                };

                // UI-ƒ± yenil…ô
                if (document.getElementById('userName')) {
                    document.getElementById('userName').textContent = payload.username;
                }
                if (document.getElementById('userBalance')) {
                    document.getElementById('userBalance').textContent = `üí∞ ${payload.balance}‚Çº`;
                }
                if (document.getElementById('myPlayerName')) {
                    document.getElementById('myPlayerName').textContent = payload.username;
                }

                log('‚úÖ User data saxlanƒ±ldƒ± v…ô UI yenil…ôndi');
            }
        });


        // -----
        const CONFIG = { HUB_URL: 'https://nehemiah-paginal-alan.ngrok-free.dev/okeyHub', DEBUG: true };
        let connection, currentUser, currentRoomId, myHand = [], myPosition = 0;
        let hasDrawn = false, isMyTurn = false, mustDiscard = false;
        let draggedTile = null, draggedFromIndex = null;
        let maxPlayers = 4;
        let currentTurnTimer = null;
        let turnTimeRemaining = 0;
        // TILE POSITIONS 
        let tilePositions = {}; // ‚úÖ Tile ID ‚Üí {x, y} cache


        function log(...args) { if (CONFIG.DEBUG) console.log('üéÆ', ...args); }


        function showNotification(message, type = 'info') {
            const notif = document.createElement('div');
            notif.className = 'notification';
            notif.textContent = message;
            document.body.appendChild(notif);
            setTimeout(() => notif.remove(), 3000);
        }


        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(id)?.classList.add('active');
        }

        // function getToken() {
        //     const raw = document.cookie.split("; ").find(r => r.startsWith("AuthToken="))?.split("=")[1];
        //     return raw ? decodeURIComponent(raw).trim() : "";
        // }

        // async function initializeSignalR() {
        //     const token = getToken();
        //     if (!token) {
        //         showNotification('Token tapƒ±lmadƒ±!', 'error');
        //         setTimeout(() => window.location.href = '/frontend/index.html', 3000);
        //         return;
        //     }

        //     try {
        //         connection = new signalR.HubConnectionBuilder()
        //             .withUrl(CONFIG.HUB_URL, {
        //                 accessTokenFactory: () => token,
        //                 transport: signalR.HttpTransportType.WebSockets | signalR.HttpTransportType.LongPolling
        //             })
        //             .withAutomaticReconnect()
        //             .configureLogging(signalR.LogLevel.Information)
        //             .build();

        //         setupSignalREvents();
        //         await connection.start();
        //         log('‚úÖ Connected');
        //         showNotification('Baƒülantƒ± uƒüurlu!', 'success');
        //         setTimeout(() => loadRooms(), 500);
        //     } catch (err) {
        //         log('‚ùå Error:', err);
        //         showNotification('Baƒülantƒ± x…ôtasƒ±', 'error');
        //     }
        // }

        async function initializeSignalR() {
            try {
                // React-dan data g√∂zl…ô
                log('‚è≥ React-dan user data g√∂zl…ônilir...');
                await waitForUserData();

                const token = IFRAME_TOKEN;

                if (!token) {
                    showNotification('Token tapƒ±lmadƒ±!', 'error');
                    return;
                }

                log('üîë Token alƒ±ndƒ±, SignalR baƒülanƒ±r...');

                connection = new signalR.HubConnectionBuilder()
                    .withUrl(CONFIG.HUB_URL, {
                        accessTokenFactory: () => token,
                        transport: signalR.HttpTransportType.WebSockets | signalR.HttpTransportType.LongPolling
                    })
                    .withAutomaticReconnect()
                    .configureLogging(signalR.LogLevel.Information)
                    .build();

                setupSignalREvents();
                await connection.start();
                log('‚úÖ Connected');
                showNotification('Baƒülantƒ± uƒüurlu!', 'success');
                setTimeout(() => loadRooms(), 500);
            } catch (err) {
                log('‚ùå Error:', err);
                showNotification('Baƒülantƒ± x…ôtasƒ±: ' + err.message, 'error');
            }
        }

        function setupSignalREvents() {

            connection.on("UserData", (d) => {
                // SignalR-dan g…ôl…ôn data il…ô yenil…ô (React data il…ô birl…ô≈üdir)
                currentUser = {
                    ...IFRAME_USER,
                    ...d
                };

                document.getElementById('userName').textContent = d.username || IFRAME_USER.username;
                document.getElementById('userBalance').textContent = `${d.balance}`;
                document.getElementById('userRank').textContent = d.rank;
                document.getElementById('myPlayerName').textContent = d.username || IFRAME_USER.username;
            });
            connection.on("BalanceUpdated", (balance) => {
                document.getElementById('userBalance').textContent = `${balance}`;
            });

            connection.on("RoomCreated", () => loadRooms());
            connection.on("RoomDeleted", () => loadRooms());


            // ‚úÖ PlayerTimeout eventi
            // connection.on("PlayerTimeout", (data) => {
            //     log('‚è∞ Player timeout:', data);
            //     showNotification(data.message || 'Oyun√ßu vaxt bitirdi', 'warning');
            //     clearAllTimers();
            // });


            connection.on("PlayerTimeout", (data) => {
                log('‚è∞ TIMEOUT:', data);

                const { playerName, discardedTile, message } = data;

                showNotification(`${playerName} vaxtƒ± bitdi - avtomatik da≈ü atƒ±ldƒ±`, 'success');

                // üéØ 2. Avtomatik da≈ü atma animasiyasƒ±
                if (discardedTile) {
                    showAutoDiscardAnimation(playerName, discardedTile);
                }

                // üéØ 3. Ekrandakƒ± oyun√ßunun infosunu yenil…ô
                updatePlayerUIAfterTimeout(playerName);
            });




            // ‚úÖ TurnTimerStarted eventi
            connection.on("TurnTimerStarted", (data) => {
                console.log('‚è±Ô∏è Timer started:', data);
                showTimer(data.username, data.seconds);
            });

            connection.on("JoinedRoom", (d) => {
                currentRoomId = d.roomId;
                myPosition = d.position;
                maxPlayers = d.maxPlayers || 4;
                document.getElementById('roomNameDisplay').textContent = d.roomName;

                adjustTableLayout(maxPlayers);


                if (d.hand && d.hand.length > 0) {
                    myHand = d.hand;
                    renderMyTiles();
                    autoArrangeTiles();
                }
                showScreen('gameScreen');
                showNotification('Otaƒüa daxil oldunuz', 'success');
            });
            connection.on("TurnTimerUpdate", (data) => {
                console.log('‚è±Ô∏è Timer update:', data);
                showTimer(data.username, data.seconds);
            });

            connection.on("TurnTimerStopped", () => {
                console.log('‚èπÔ∏è Timer stopped');
                clearTimers();
            });

            // ‚úÖ PlayerAction event-i (avtomatik da≈ü atma bildiri≈üi)
            connection.on("PlayerAction", (data) => {
                if (data.action === "AutoDiscard") {
                    showNotification(data.message, 'info');
                    log('‚è∞ AUTO ACTION:', data);
                }
            });

            // ‚úÖ YourTurn event-d…ô timer-i t…ômizl…ô
            const originalYourTurnHandler = connection.on("YourTurn", () => {
                isMyTurn = true;
                hasDrawn = false;
                mustDiscard = false;
                clearAllTimers();
                updateTurnUI();
                showNotification('Sizin n√∂vb…ônizdir! DA≈û √á∆èKƒ∞N!', 'info');
            });

            connection.on("TileDrawn", (d) => {
                myHand = d.hand;
                hasDrawn = true;
                mustDiscard = true;
                renderMyTiles();
                updateTurnUI();

                // ‚úÖ Vizual olaraq d…ôst…ôd…ôn da≈ü √ß…ôkilm…ôsini g√∂st…ôr
                const deckStack = document.getElementById('deckStack');
                if (deckStack) {
                    deckStack.style.transform = 'scale(1.1)';
                    setTimeout(() => {
                        deckStack.style.transform = '';
                    }, 200);
                }

                showNotification('Da≈ü √ß…ôkdiniz, indi DA≈û ATIN!', 'success');
            });

            // ‚úÖ TileDiscarded event-d…ô timer t…ômizl…ô
            connection.on("TileDiscarded", (d) => {
                myHand = d.hand;
                hasDrawn = false;
                isMyTurn = false;
                mustDiscard = false;
                clearAllTimers();
                renderMyTiles();
                updateTurnUI();
            });


            // ‚úÖ PlayerDiscardedTile - vizual animasiya
            connection.on("PlayerDiscardedTile", (d) => {
                if (d.tile && d.playerPosition !== undefined) {
                    displayDiscardedTile(d.tile, d.playerPosition);

                    // ‚úÖ Animasiya
                    const relativePos = getRelativePosition(myPosition, d.playerPosition);
                    let zoneId = '';

                    if (relativePos === 'bottom') zoneId = 'myDiscardZone';
                    else if (relativePos === 'top') zoneId = 'discardZoneTop';
                    else if (relativePos === 'left') zoneId = 'discardZoneLeft';
                    else if (relativePos === 'right') zoneId = 'discardZoneRight';

                    const zone = document.getElementById(zoneId);
                    if (zone) {
                        // Atma animasiyasƒ±
                        zone.style.transform = 'scale(1.15)';
                        zone.style.boxShadow = '0 0 30px rgba(231, 76, 60, 0.8)';

                        setTimeout(() => {
                            zone.style.transform = '';
                            zone.style.boxShadow = '';
                        }, 300);
                    }
                }
            });

            // ‚úÖ GameReset event-d…ô timer t…ômizl…ô
            connection.on("GameReset", () => {
                console.log('üîÑ Game Reset - t…ômizl…ôm…ô ba≈ülayƒ±r...');

                // ‚úÖ Oyun v…ôziyy…ôtini sƒ±fƒ±rla
                myHand = [];
                hasDrawn = false;
                mustDiscard = false;
                isMyTurn = false;

                tilePositions = {};

                // ‚úÖ Timer-l…ôri t…ômizl…ô
                clearAllTimers();

                // ‚úÖ L√∂vh…ôni t…ômizl…ô
                const row1 = document.getElementById('myRow1');
                const row2 = document.getElementById('myRow2');
                if (row1) row1.innerHTML = '';
                if (row2) row2.innerHTML = '';

                // ‚úÖ B√ºt√ºn discard zona-larƒ± t…ômizl…ô
                clearAllDiscardZones();

                // ‚úÖ G√∂st…ôrici v…ô joker-i t…ômizl…ô
                const indicatorEl = document.getElementById('indicatorTile');
                const jokerEl = document.getElementById('jokerTile');
                if (indicatorEl) indicatorEl.innerHTML = '';
                if (jokerEl) jokerEl.innerHTML = '';

                // ‚úÖ D…ôst…ô sayƒ±nƒ± sƒ±fƒ±rla
                const deckLabel = document.getElementById('deckCountLabel');
                if (deckLabel) {
                    deckLabel.textContent = '106';
                    deckLabel.style.color = 'white';
                }

                // ‚úÖ Modal-ƒ± baƒüla
                document.getElementById('winModal')?.classList.remove('show');

                // ‚úÖ Bildiri≈ü
                showNotification('Yeni raund hazƒ±rlanƒ±r...', 'info');

                console.log('‚úÖ T…ômizl…ôm…ô tamamlandƒ±');
            });

            // ‚úÖ D…ôst…ô vizual yenil…ôm…ô
            connection.on("GameStateUpdated", (state) => {
                if (state.stockCount !== undefined) {
                    const label = document.getElementById('deckCountLabel');
                    if (label) {
                        label.textContent = `üìö ${state.stockCount}`;

                        // ‚úÖ Az da≈ü qalƒ±bsa x…ôb…ôrdarlƒ±q
                        if (state.stockCount <= 10 && state.stockCount > 0) {
                            label.style.color = '#f39c12';
                        } else if (state.stockCount === 0) {
                            label.style.color = '#e74c3c';
                            label.textContent = '‚ùå BO≈û';
                        }
                    }
                }

                if (state.potAmount !== undefined) {
                    document.getElementById('potAmountDisplay').textContent = `Pot: ${state.potAmount}‚Çº`;
                }

                if (state.players) {
                    updatePlayersDisplay(state.players);
                }
            });

            connection.on("JoinError", (msg) => showNotification(msg, 'error'));
            connection.on("PlayerJoined", (d) => showNotification(`${d.playerName} qo≈üuldu`, 'info'));
            connection.on("PlayerLeft", (d) => showNotification(`${d.playerName} √ßƒ±xdƒ±`, 'info'));
            connection.on("PlayersList", (players) => updatePlayersDisplay(players));

            connection.on("GameStarted", (d) => {
                log('GameStarted:', d);
                myHand = d.hand || [];

                adjustTableLayout(maxPlayers);

                tilePositions = {};
                if (myHand.length > 0) {
                    autoArrangeTiles();
                }


                if (myHand.length === 15) {
                    hasDrawn = true;
                    mustDiscard = true;
                    isMyTurn = true;
                    showNotification('Oyunu Sƒ∞Z ba≈ülayƒ±rsƒ±nƒ±z! DA≈û ATIN! üéÆ', 'success');
                } else {
                    hasDrawn = false;
                    mustDiscard = false;
                    isMyTurn = d.isYourTurn || false;
                }

                renderMyTiles();
                if (d.indicator) setIndicatorTile(d.indicator);
                if (d.joker) setJokerTile(d.joker);

                // document.getElementById('gameModeDisplay').textContent = `Mod: ${d.gameMode}`;
                document.getElementById('myScore').textContent = d.initialScore;
                updateTurnUI();

                const playerPositions = getPlayerNames();
                console.log(playerPositions);

                if (!mustDiscard) showNotification('Oyun ba≈üladƒ±! üéÆ', 'success');
            });

            connection.on("GameStateUpdated", (state) => {
                if (state.stockCount !== undefined)
                    document.getElementById('deckCountLabel').textContent = `${state.stockCount}`;
                if (state.potAmount !== undefined)
                    document.getElementById('potAmountDisplay').textContent = `Pot: ${state.potAmount}‚Çº`;
                if (state.players) updatePlayersDisplay(state.players);
            });


            connection.on("TileDrawn", (d) => {
                myHand = d.hand;
                hasDrawn = true;
                mustDiscard = true;
                renderMyTiles();
                updateTurnUI();
                showNotification('Da≈ü √ß…ôkdiniz, indi DA≈û ATIN!', 'success');
            });

            connection.on("PlayerDrew", (d) => showNotification(`${d.playerName} da≈ü √ß…ôkdi`, 'info'));



            connection.on("PlayerDiscardedTile", (d) => {
                if (d.tile && d.playerPosition !== undefined)
                    displayDiscardedTile(d.tile, d.playerPosition);
            });

            connection.on("ActionError", (msg) => showNotification(msg, 'error'));

            // connection.on("RoundOver", (d) => showNotification(`üéâ ${d.winner} qazandƒ±!`, 'success'));
            connection.on("RoundOver", (d) => {
                console.log('üéâ RoundOver:', d);

                showNotification(`üéâ ${d.winner} qazandƒ±!`, 'success');

                // ‚úÖ Kombinasiyalarƒ± masanƒ±n ortasƒ±nda modal il…ô g√∂st…ôr
                const modal = document.getElementById('winModal');
                const container = document.getElementById('winMeldsContainer');

                if (modal && container && d.melds && d.melds.length > 0) {
                    container.innerHTML = '';

                    d.melds.forEach((meld, idx) => {
                        const meldDiv = document.createElement('div');
                        meldDiv.className = 'win-meld-group';
                        meldDiv.innerHTML = `<strong style="color: #f39c12; min-width: 80px;">Qrup ${idx + 1}:</strong>`;

                        meld.forEach(tile => {
                            meldDiv.innerHTML += createTileHTML(tile, 0);
                        });

                        container.appendChild(meldDiv);
                    });

                    const winTypeEl = document.createElement('p');
                    winTypeEl.style.cssText = 'margin-top: 25px; font-size: 20px; text-align: center; color: #f39c12; font-weight: 800;';
                    winTypeEl.innerHTML = `üéñÔ∏è Bitirm…ô n√∂v√º: <strong>${d.winType}</strong>`;
                    container.appendChild(winTypeEl);

                    modal.classList.add('show');

                    setTimeout(() => modal.classList.remove('show'), 10000);
                }
            });

            connection.on("GameOver", (d) => {
                if (d.reason) {
                    showNotification(d.reason, 'error');
                } else {
                    showNotification(`üèÜ Final Qalibi: ${d.finalWinner}`, 'success');
                }

                // ‚úÖ Final xallarƒ± g√∂st…ôr
                if (d.finalScores && d.finalScores.length > 0) {
                    console.log('üìä Final Scores:', d.finalScores);
                }

                // ‚úÖ 5 saniy…ô sonra otaq siyahƒ±sƒ±na qayƒ±t
                setTimeout(() => {
                    showScreen('roomListScreen');
                    loadRooms();
                }, 5000);
            });

            // connection.on("GameReset", () => {
            //     myHand = [];
            //     hasDrawn = false;
            //     mustDiscard = false;
            //     isMyTurn = false;
            //     renderMyTiles();
            //     clearAllDiscardZones();
            //     document.getElementById('winModal')?.classList.remove('show');
            //     showNotification('Yeni raund...', 'info');
            // });

            connection.on("WinDeclared", (d) => showNotification(d.message, d.isValid ? 'success' : 'error'));
            connection.on("RankUpdated", (d) => {
                document.getElementById('userRank').textContent = d.rank;
                showNotification(`üéñÔ∏è ${d.rank} - Lvl ${d.level}`, 'success');
            });

            connection.on("LeftRoom", () => {
                currentRoomId = null;
                myHand = [];
                showScreen('roomListScreen');
                loadRooms();
            });

            connection.on("LeaveError", (msg) => showNotification(msg, 'error'));
        }




        function adjustTableLayout(playerCount) {
            const table = document.querySelector('.game-table');
            if (!table) return;

            // ∆èvv…ôlki class-larƒ± sil
            table.classList.remove('players-2', 'players-3', 'players-4');

            // Yeni class …ôlav…ô et
            table.classList.add(`players-${playerCount}`);

            log(`üéÆ Masa ${playerCount} n…ôf…ôrlik rejimd…ô`);
        }
        // ============autoDiscard============== 
        // ‚úÖ AVTOMATIK DA≈û ATMA ANƒ∞MASƒ∞YASI
        function showAutoDiscardAnimation(playerName, tile) {
            const relativePos = getRelativePositionByName(playerName);
            let zoneId = '';

            if (relativePos === 'bottom') zoneId = 'myDiscardZone';
            else if (relativePos === 'top') zoneId = 'discardZoneTop';
            else if (relativePos === 'left') zoneId = 'discardZoneLeft';
            else if (relativePos === 'right') zoneId = 'discardZoneRight';

            const zone = document.getElementById(zoneId);
            if (!zone) return;

            // üéØ Da≈ü elementi yarat
            const autoTile = document.createElement('div');
            autoTile.className = `okey-tile ${(tile.color || '').toLowerCase()}`;
            autoTile.style.position = 'fixed';
            autoTile.style.width = '36px';
            autoTile.style.height = '55px';
            autoTile.style.zIndex = '7777';
            autoTile.style.animation = 'autoDiscardFly 0.8s ease-in-out forwards';

            // Da≈ü √ºz…ôrind…ô m…ôtn
            if (tile.isJoker || tile.isFakeJoker) {
                autoTile.innerHTML = '<div class="tile-joker-star">‚òÖ</div>';
            } else {
                const color = (tile.color || '').toLowerCase();
                const dotColor = color === 'red' ? '#d32f2f' :
                    color === 'yellow' ? '#f9a825' :
                        color === 'blue' ? '#1976d2' : '#212121';
                autoTile.innerHTML = `
            <div class="tile-number">${tile.number}</div>

            <div class="tile-color-dot-container">
            <div class="tile-color-dot" style="background: ${dotColor};"></div>
            </div>
        `;
            }

            // üéØ Ba≈ülanƒüƒ±c position (oyun√ßunun masada yerl…ô≈üdiyi yer)
            const playerInfo = getPlayerInfoElement(relativePos);
            if (playerInfo) {
                const rect = playerInfo.getBoundingClientRect();
                autoTile.style.left = (rect.left + rect.width / 2 - 28) + 'px';
                autoTile.style.top = (rect.top + rect.height / 2 - 41) + 'px';
            }

            // üéØ CSS-d…ô hedef pozisiyanƒ± t…ôyin et
            autoTile.setAttribute('data-target-zone', zoneId);

            // üéØ Sona √ßatdƒ±ƒüƒ±nda
            autoTile.addEventListener('animationend', () => {
                autoTile.remove();

                // üéØ Atma zonasƒ±na da≈ü …ôlav…ô et
                displayDiscardedTile(tile, getPlayerPositionByName(playerName));

                // üéØ Zona vizual feedback
                zone.style.transform = 'scale(1.15)';
                zone.style.boxShadow = '0 0 30px rgba(39, 174, 96, 0.8)';

                setTimeout(() => {
                    zone.style.transform = '';
                    zone.style.boxShadow = '';
                }, 300);
            });

            document.body.appendChild(autoTile);
            log('‚ú® Auto discard animation started');
        }

        // ‚úÖ Oyun√ßunun adƒ±ndan position tapa bilm…ôk √º√ß√ºn helper
        function getRelativePositionByName(playerName) {
            const players = document.querySelectorAll('[class*="player-info"]');

            for (let el of players) {
                const nameEl = el.querySelector('.player-name');
                if (nameEl && nameEl.textContent === playerName) {
                    // Element ID-d…ôn position tap
                    if (el.id === 'myPlayerInfo') return 'bottom';
                    if (el.id === 'playerInfoTop') return 'top';
                    if (el.id === 'playerInfoLeft') return 'left';
                    if (el.id === 'playerInfoRight') return 'right';
                }
            }
            return 'bottom';
        }

        // ‚úÖ Position-dan player info elementi tapa bilm…ôk
        function getPlayerInfoElement(position) {
            const idMap = {
                'bottom': 'myPlayerInfo',
                'top': 'playerInfoTop',
                'left': 'playerInfoLeft',
                'right': 'playerInfoRight'
            };
            return document.getElementById(idMap[position]);
        }

        // ‚úÖ Oyun√ßunun adƒ±ndan position tapa bilm…ôk √º√ß√ºn backup
        function getPlayerPositionByName(playerName) {
            const players = document.querySelectorAll('[class*="player-info"]');

            for (let el of players) {
                const nameEl = el.querySelector('.player-name');
                if (nameEl && nameEl.textContent === playerName) {
                    if (el.id === 'myPlayerInfo') return 0; // myPosition
                    // Dig…ôrl…ôrini …ôksik - lazƒ±m olsa doldur
                }
            }
            return myPosition;
        }

        // ‚úÖ UI-ƒ± yenil…ô (da≈ü sayƒ±nƒ± azalt)
        function updatePlayerUIAfterTimeout(playerName) {
            const players = document.querySelectorAll('[class*="player-info"]');

            for (let el of players) {
                const nameEl = el.querySelector('.player-name');
                if (nameEl && nameEl.textContent === playerName) {
                    const scoreEl = el.querySelector('.player-score');
                    if (scoreEl) {
                        const currentScore = parseInt(scoreEl.textContent) || 0;
                        // Da≈ü sayƒ± 1 azalƒ±r
                        if (currentScore > 0) {
                            scoreEl.textContent = currentScore - 1;

                            // üéØ Visual pulse
                            el.style.animation = 'playerPulse 0.5s ease-out';
                            setTimeout(() => {
                                el.style.animation = '';
                            }, 500);
                        }
                    }
                    break;
                }
            }
        }

        // ‚úÖ CSS ANƒ∞MASƒ∞YA (style tag-ƒ±na …ôlav…ô et)
        // ∆èg…ôr artƒ±q var is…ô, yoxla v…ô yenisini …ôlav…ô et
        const style = document.createElement('style');
        style.textContent = `
    @keyframes autoDiscardFly {
        0% {
            transform: scale(1) rotate(0deg);
            opacity: 1;
        }
        50% {
            transform: scale(1.1) rotate(-15deg);
            box-shadow: 0 10px 40px rgba(102, 126, 234, 0.7);
        }
        100% {
            transform: scale(0.85) rotate(5deg);
            opacity: 0.9;
        }
    }

    @keyframes playerPulse {
        0% {
            transform: scale(1);
        }
        50% {
            transform: scale(1.08);
            box-shadow: 0 0 25px rgba(231, 76, 60, 0.8);
        }
        100% {
            transform: scale(1);
        }
    }

    @keyframes slideInRight {
        from {
            transform: translateX(500px);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }
`;
        document.head.appendChild(style);

        // ========================================== 
        function updatePlayerTimer(playerPosition, seconds) {
            const relativePos = getRelativePosition(myPosition, playerPosition);
            let infoId = '';

            if (relativePos === 'bottom') infoId = 'myPlayerInfo';
            else if (relativePos === 'top') infoId = 'playerInfoTop';
            else if (relativePos === 'left') infoId = 'playerInfoLeft';
            else if (relativePos === 'right') infoId = 'playerInfoRight';

            const playerInfo = document.getElementById(infoId);
            if (!playerInfo) return;

            // K√∂hn…ô timer-i sil
            let timerBadge = playerInfo.querySelector('.timer-badge');
            if (!timerBadge) {
                timerBadge = document.createElement('div');
                timerBadge.className = 'timer-badge';
                playerInfo.style.position = 'relative';
                playerInfo.appendChild(timerBadge);
            }

            // Yeni vaxt g√∂st…ôr
            timerBadge.textContent = seconds;

            // R…ông d…ôyi≈ü
            timerBadge.classList.remove('warning', 'critical');
            if (seconds <= 5) {
                timerBadge.classList.add('critical');
            } else if (seconds <= 10) {
                timerBadge.classList.add('warning');
            }

            // ‚úÖ M…ônim n√∂vb…ômd…ôdirs…ô - bildiri≈ü
            if (relativePos === 'bottom') {
                if (seconds === 10) {
                    showNotification(`‚è∞ 10 saniy…ô qaldƒ±!`, 'info');
                } else if (seconds === 5) {
                    showNotification(`‚ö†Ô∏è 5 saniy…ô qaldƒ±! T…ôl…ôsin!`, 'error');
                } else if (seconds === 1) {
                    showNotification(`üö® AVTOMATIK DA≈û ATILIR!`, 'error');
                }
            }
        }

        // ‚úÖ B√ºt√ºn timer-l…ôri t…ômizl…ô
        function clearAllTimers() {
            ['myPlayerInfo', 'playerInfoTop', 'playerInfoLeft', 'playerInfoRight'].forEach(id => {
                const playerInfo = document.getElementById(id);
                if (playerInfo) {
                    const timerBadge = playerInfo.querySelector('.timer-badge');
                    if (timerBadge) {
                        timerBadge.remove();
                    }
                }
            });
        }

        // Lobby y√ºkl…ôm…ô funksiyasƒ±
        // Lobby y√ºkl…ôm…ô funksiyasƒ±
        async function loadRooms() {
            try {
                const rooms = await connection.invoke("GetRoomList");
                const grid = document.getElementById('roomsGrid');

                if (!rooms || rooms.length === 0) {
                    grid.innerHTML = '<div style="text-align: center; padding: 50px; color: white;">Otaq tapƒ±lmadƒ±</div>';
                    return;
                }

                // Otaqlarƒ± saxla (modal √º√ß√ºn)
                window.availableRooms = rooms;

                // Oyun√ßu sayƒ± se√ßiml…ôri
                grid.innerHTML = `
            <div class="player-selection-container">
                <div class="player-options">
                    ${[2, 3, 4].map(playerCount => {
                    const playerRooms = rooms.filter(r => r.maxPlayers === playerCount);
                    const totalPlayers = playerRooms.reduce((sum, r) => sum + r.playerCount, 0);
                    // <span class="player-count-info">${totalPlayers} oyun√ßu</span>
                    // <div class="player-icon-large">üë•</div>

                    return `
                            <div class="player-option-card" onclick="openBetModal(${playerCount})">
                                <div class="player-count-large">${playerCount}</div>
                                <div class="player-label">N…ôf…ôrlik</div>
                                ${playerRooms.length > 0 ? `
                                ` : '<div class="no-rooms">Otaq yoxdur</div>'}
                            </div>
                        `;
                }).join('')}
                </div>
            </div>
        `;

            } catch (err) {
                console.error('‚ùå Load rooms error:', err);
            }
        }

        // Bet modal a√ßma
        function openBetModal(playerCount) {
            const rooms = window.availableRooms.filter(r => r.maxPlayers === playerCount);

            if (!rooms || rooms.length === 0) {
                showNotification('Bu oyun√ßu sayƒ± √º√ß√ºn otaq yoxdur', 'error');
                return;
            }

            // Modal yaradƒ±rƒ±q v…ô ya tapƒ±rƒ±q
            let modal = document.getElementById('lobbyBetModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'lobbyBetModal';
                modal.className = 'modal-overlay';
                modal.style.display = 'none';
                document.body.appendChild(modal);

                // Overlay-…ô klik ed…ônd…ô baƒülansƒ±n
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) closeLobbyBetModal();
                });
            }

            // Unikal bet m…ôbl…ôƒül…ôri
            const uniqueBets = [...new Set(rooms.map(r => r.entryFee))].sort((a, b) => a - b);

            // <div class="bet-info-small">${room.playerCount}/${playerCount} oyun√ßu</div>
            // Modal content-i yenil…ô
            modal.innerHTML = `
        <div class="modal-content">
            <div class="modal-header">
                <h2>${playerCount} N…ôf…ôrlik Oyun</h2>
                <button class="modal-close" onclick="closeLobbyBetModal()">√ó</button>
            </div>
            <div class="modal-body">
                <div class="bet-grid" id="betOptions">
                    ${uniqueBets.map(bet => {
                const room = rooms.find(r => r.entryFee === bet);
                return `
                            <button class="lobby-bet-card" onclick="joinRoom('${room.roomId}')">
                                <div class="bet-amount">üí∞ ${bet}</div>
                            </button>
                        `;
            }).join('')}
                </div>
            </div>
        </div>
    `;

            modal.style.display = 'flex';
        }

        // Modal baƒülama
        function closeLobbyBetModal() {
            const modal = document.getElementById('lobbyBetModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // Otaƒüa qo≈üulma
        async function joinRoom(roomId) {
            try {
                closeLobbyBetModal();
                showNotification('Qo≈üulma...', 'info');
                await connection.invoke("JoinRoom", roomId, null);
                sortTiles();
            } catch (err) {
                console.error('‚ùå Join error:', err);
                showNotification('Qo≈üulmaq alƒ±nmadƒ±', 'error');
            }
        }

        // Auto refresh
        // setInterval(() => {
        //     if (document.getElementById('roomListScreen').classList.contains('active') && connection) {
        //         loadRooms();
        //     }
        // }, 3000);

        // ‚úÖ YENƒ∞ FUNKSIYA: G√∂st…ôrici √ºz…ôrin…ô da≈ü atmaq
        function setupIndicatorDropZone() {
            const indicatorEl = document.getElementById('indicatorTile');
            if (!indicatorEl) return;

            indicatorEl.addEventListener('dragenter', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (hasDrawn && mustDiscard && isMyTurn && draggedTile) {
                    indicatorEl.style.border = '3px solid #27ae60';
                    indicatorEl.style.transform = 'scale(1.1)';
                }
            });

            indicatorEl.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (hasDrawn && mustDiscard && isMyTurn && draggedTile) {
                    e.dataTransfer.dropEffect = 'move';
                }
            });

            indicatorEl.addEventListener('dragleave', (e) => {
                const rect = indicatorEl.getBoundingClientRect();
                if (e.clientX < rect.left || e.clientX > rect.right ||
                    e.clientY < rect.top || e.clientY > rect.bottom) {
                    indicatorEl.style.border = '';
                    indicatorEl.style.transform = '';
                }
            });

            indicatorEl.addEventListener('drop', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                indicatorEl.style.border = '';
                indicatorEl.style.transform = '';

                if (hasDrawn && mustDiscard && isMyTurn && draggedTile) {
                    const tileId = draggedTile.id;
                    draggedTile = null;
                    draggedFromIndex = null;

                    try {
                        log('üéØ G√∂st…ôrici √ºz…ôrin…ô da≈ü atƒ±lƒ±r - oyun bitir!');
                        await connection.invoke("DiscardOnIndicator", tileId);
                    } catch (err) {
                        log('‚ùå DiscardOnIndicator error:', err);
                        showNotification('X…ôta ba≈ü verdi', 'error');
                    }
                }
            });
        }

        async function leaveRoom() {
            if (!confirm('√áƒ±xmaq ist…ôyirsiniz?')) return;
            try {
                await connection.invoke("LeaveRoom");
            } catch (err) {
                log('‚ùå Leave error:', err);
                showScreen('roomListScreen');
                loadRooms();
            }
        }

        async function drawFromStock() {
            if (!isMyTurn || hasDrawn || mustDiscard) {
                showNotification(mustDiscard ? 'DA≈û ATIN!' : 'N√∂vb…ônizi g√∂zl…ôyin', 'error');
                return;
            }

            // ‚úÖ Vizual animasiya
            const deckStack = document.getElementById('deckStack');
            if (deckStack) {
                deckStack.style.transform = 'scale(1.15) translateY(-10px)';
                deckStack.style.boxShadow = '0 10px 35px rgba(52, 152, 219, 0.8)';

                setTimeout(() => {
                    deckStack.style.transform = '';
                    deckStack.style.boxShadow = '';
                }, 300);
            }

            try {
                await connection.invoke("DrawTile", "stock");
            } catch (err) {
                log('‚ùå Draw error:', err);
            }
        }

        async function tryDrawFromLeftPlayer() {
            if (!isMyTurn || hasDrawn || mustDiscard) {
                if (mustDiscard) showNotification('∆èvv…ôlc…ô da≈ü atƒ±n!', 'error');
                else if (hasDrawn) showNotification('Artƒ±q da≈ü √ß…ôkmisiniz!', 'error');
                else showNotification('N√∂vb…ôniz deyil!', 'error');
                return;
            }

            const zone = document.getElementById('discardZoneTop');
            if (!zone || !zone.querySelector('.okey-tile')) {
                showNotification('R…ôqib h…ôl…ô da≈ü atmayƒ±b', 'error');
                return;
            }

            try {
                log('üé¥ Top oyun√ßudan da≈ü g√∂t√ºr√ºr…ôm...');
                await connection.invoke("DrawTile", "discard");
                setTimeout(() => {
                    zone.innerHTML = '';
                    log('‚úÖ Top oyun√ßunun da≈üƒ± silindi');
                }, 150);
            } catch (err) {
                log('‚ùå Draw from discard error:', err);
                showNotification('Da≈üƒ± g√∂t√ºrm…ôk m√ºmk√ºn olmadƒ±', 'error');
            }
        }

        async function discardTile(tileId) {
            if (!hasDrawn || !mustDiscard) {
                showNotification('∆èvv…ôlc…ô da≈ü √ß…ôkin!', 'error');
                return;
            }

            // ‚úÖ Vizual animasiya - atma zonasƒ±
            const myDiscardZone = document.getElementById('myDiscardZone');
            if (myDiscardZone) {
                myDiscardZone.style.transform = 'scale(1.1)';
                myDiscardZone.style.borderColor = '#27ae60';

                setTimeout(() => {
                    myDiscardZone.style.transform = '';
                    myDiscardZone.style.borderColor = '';
                }, 300);
            }

            try {
                await connection.invoke("DiscardTile", tileId);
            } catch (err) {
                log('‚ùå Discard error:', err);
            }
        }

        async function declareWin() {
            try {
                await connection.invoke("DeclareWin");
            } catch (err) { log('‚ùå Win error:', err); }
        }

        // ‚úÖ SORT FUNKSIYASINI YENIL∆è
        function sortTiles() {
            const colorOrder = { red: 0, yellow: 1, blue: 2, black: 3, fakejoker: 4 };

            myHand.sort((a, b) => {
                const colorA = (a.color || '').toLowerCase();
                const colorB = (b.color || '').toLowerCase();
                const colorDiff = (colorOrder[colorA] || 0) - (colorOrder[colorB] || 0);
                return colorDiff !== 0 ? colorDiff : a.number - b.number;
            });

            // ‚úÖ Cache-i t…ômizl…ô v…ô yenid…ôn d√ºz…ôlt
            tilePositions = {};
            autoArrangeTiles();
            renderMyTiles();

            showNotification('Sƒ±ralandƒ±', 'success');
        }

        function getRelativePosition(myPos, targetPos) {
            const diff = (targetPos - myPos + maxPlayers) % maxPlayers;

            if (maxPlayers === 2) {
                // 2 n…ôf…ôr: bottom, top
                if (diff === 0) return 'bottom';
                if (diff === 1) return 'top';
            } else if (maxPlayers === 3) {
                // 3 n…ôf…ôr: bottom, left, right
                if (diff === 0) return 'bottom';
                if (diff === 1) return 'right';
                if (diff === 2) return 'left';
            } else {
                // 4 n…ôf…ôr: bottom, right, top, left
                if (diff === 0) return 'bottom';
                if (diff === 1) return 'right';
                if (diff === 2) return 'top';
                if (diff === 3) return 'left';
            }

            return 'bottom';
        }

        // ‚úÖ Tile HTML yaratmaq √º√ß√ºn k√∂m…ôk√ßi funksiya
        function createTileHTML(tile, globalIdx) {
            if (!tile) return '';

            let className = `okey-tile ${(tile.color || '').toLowerCase()}`;
            let content = '';

            if (tile.isFakeJoker || tile.isJoker) {
                content = '<div class="tile-joker-star">‚òÖ</div>';
                className += ' joker';
            } else {
                const color = (tile.color || '').toLowerCase();
                const dotColor =
                    color === 'red' ? '#d32f2f' :
                        color === 'yellow' ? '#f9a825' :
                            color === 'blue' ? '#1976d2' : '#212121';

                content = `
            <div class="tile-number">${tile.number}</div>
            <div class="tile-color-dot-container">
            <div class="tile-color-dot" style="background: ${dotColor};"></div>
            </div>
        `;
            }

            return `<div class="${className}" data-tile-id="${tile.id}" data-idx="${globalIdx}" draggable="true">${content}</div>`;
        }


        function renderMyTiles() {
            const board = document.getElementById('myBoard');
            if (!board) {
                console.error('‚ùå myBoard tapƒ±lmadƒ±!');
                return;
            }

            const tileWidth = 36;
            const gap = 3;
            const ROW_1_Y = 10;
            const ROW_2_Y = 70;

            // ‚úÖ 1. K√∂hn…ô da≈ülarƒ±n pozisiyalarƒ±nƒ± cache-…ô saxla
            myHand.forEach(tile => {
                if (tile.x !== undefined && tile.y !== undefined) {
                    tilePositions[tile.id] = { x: tile.x, y: tile.y };
                }
            });

            // ‚úÖ 2. Cache-d…ôn pozisiyalarƒ± geri qaytar
            myHand.forEach(tile => {
                if (tilePositions[tile.id]) {
                    tile.x = tilePositions[tile.id].x;
                    tile.y = tilePositions[tile.id].y;
                }
            });

            // ‚úÖ 3. Yeni da≈ülarƒ± (pozisiyasƒ± olmayan) sona yerl…ô≈üdir
            const tilesWithoutPosition = myHand.filter(t => t.x === undefined || t.y === undefined);

            if (tilesWithoutPosition.length > 0) {
                // H…ôr iki s…ôtird…ô m√∂vcud da≈ülarƒ± say
                const row1Count = myHand.filter(t => t.y === ROW_1_Y && t.x !== undefined).length;
                const row2Count = myHand.filter(t => t.y === ROW_2_Y && t.x !== undefined).length;

                // Yeni da≈ülarƒ± yerl…ô≈üdir
                tilesWithoutPosition.forEach(tile => {
                    if (row1Count < 8) {
                        // 1-ci s…ôtr…ô …ôlav…ô et
                        const existingRow1 = myHand.filter(t => t.y === ROW_1_Y && t.x !== undefined);
                        const maxX = existingRow1.length > 0
                            ? Math.max(...existingRow1.map(t => t.x))
                            : -gap;

                        tile.x = maxX + tileWidth + gap;
                        tile.y = ROW_1_Y;
                    } else {
                        // 2-ci s…ôtr…ô …ôlav…ô et
                        const existingRow2 = myHand.filter(t => t.y === ROW_2_Y && t.x !== undefined);
                        const maxX = existingRow2.length > 0
                            ? Math.max(...existingRow2.map(t => t.x))
                            : -gap;

                        tile.x = maxX + tileWidth + gap;
                        tile.y = ROW_2_Y;
                    }

                    // Cache-…ô …ôlav…ô et
                    tilePositions[tile.id] = { x: tile.x, y: tile.y };
                });
            }

            // ‚úÖ 4. Board-u t…ômizl…ô v…ô render et
            board.innerHTML = '';

            myHand.forEach((tile, idx) => {
                const x = tile.x || 10;
                const y = tile.y || 10;

                const tileEl = document.createElement('div');
                tileEl.className = `okey-tile ${(tile.color || '').toLowerCase()}`;
                tileEl.dataset.idx = idx;
                tileEl.dataset.tileId = tile.id;
                tileEl.draggable = false;
                tileEl.style.left = x + 'px';
                tileEl.style.top = y + 'px';
                tileEl.style.cursor = 'grab';

                if (tile.isFakeJoker || tile.isJoker) {
                    tileEl.innerHTML = '<div class="tile-joker-star">‚òÖ</div>';
                    tileEl.classList.add('joker');
                } else {
                    const color = (tile.color || '').toLowerCase();
                    const dotColor =
                        color === 'red' ? '#d32f2f' :
                            color === 'yellow' ? '#f9a825' :
                                color === 'blue' ? '#1976d2' : '#212121';

                    tileEl.innerHTML = `
                <div class="tile-number">${tile.number}</div>
                <div class="tile-color-dot-container">
            <div class="tile-color-dot" style="background: ${dotColor};"></div>
            </div>
            `;
                }

                board.appendChild(tileEl);
            });

            setupFreeDragDrop();
            // setupMyDiscardZone();
            setupIndicatorDropZone();
        }



        function setupFreeDragDrop() {
            const board = document.getElementById('myBoard');
            const container = document.getElementById('myBoardContainer');
            const discardZone = document.getElementById('myDiscardZone');

            if (!board || !container) return;

            const tiles = board.querySelectorAll('.okey-tile');
            let activeTile = null;
            let activeIdx = null;
            let isDragging = false;
            let isOverDiscardZone = false;

            // ‚úÖ Tile-ƒ±n board i√ßind…ôki orijinal pozisiyasƒ±
            let startBoardX = 0;
            let startBoardY = 0;

            // ‚úÖ Mouse-un tile √ºz…ôrind…ôki offset-i
            let mouseOffsetX = 0;
            let mouseOffsetY = 0;

            const ROW_1_Y = 10;
            const ROW_2_Y = 75;
            const SNAP_THRESHOLD = 45;

            tiles.forEach((tileEl) => {
                const idx = parseInt(tileEl.dataset.idx);

                // ‚úÖ MOUSE DOWN
                tileEl.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    activeTile = tileEl;
                    activeIdx = idx;
                    isDragging = true;

                    // ‚úÖ Board i√ßind…ôki orijinal pozisiya
                    const boardRect = board.getBoundingClientRect();
                    const tileRect = tileEl.getBoundingClientRect();

                    startBoardX = tileRect.left - boardRect.left;
                    startBoardY = tileRect.top - boardRect.top;

                    // ‚úÖ Mouse tile √ºz…ôrind…ô harada?
                    mouseOffsetX = e.clientX - tileRect.left;
                    mouseOffsetY = e.clientY - tileRect.top;

                    // Style d…ôyi≈üiklikl…ôri
                    tileEl.style.cursor = 'grabbing';
                    tileEl.style.zIndex = '1000';
                    tileEl.style.opacity = '0.9';
                    tileEl.style.transition = 'none';
                    tileEl.classList.add('dragging');
                });

                // ‚úÖ DOUBLE-CLICK
                tileEl.addEventListener('dblclick', () => {
                    if (mustDiscard && hasDrawn && isMyTurn) {
                        const tileId = myHand[idx].id;

                        if (myHand.length === 1) {
                            log('üèÜ Son da≈ü ikiqat klik - oyun bitir!');
                            showNotification('Son da≈ü atƒ±ldƒ±! Yoxlanƒ±lƒ±r...', 'success');
                            setTimeout(() => declareWin(), 300);
                        } else {
                            discardTile(tileId);
                        }
                    }
                });

                // ‚úÖ TOUCH START
                tileEl.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];

                    activeTile = tileEl;
                    activeIdx = idx;
                    isDragging = true;

                    const boardRect = board.getBoundingClientRect();
                    const tileRect = tileEl.getBoundingClientRect();

                    startBoardX = tileRect.left - boardRect.left;
                    startBoardY = tileRect.top - boardRect.top;

                    mouseOffsetX = touch.clientX - tileRect.left;
                    mouseOffsetY = touch.clientY - tileRect.top;

                    tileEl.style.zIndex = '1000';
                    tileEl.style.opacity = '0.9';
                    tileEl.style.transition = 'none';
                    tileEl.classList.add('dragging');
                });
            });

            // ‚úÖ MOUSE MOVE - BOARD ƒ∞√áƒ∞ND∆è ABSOLUTE POZƒ∞Sƒ∞YA
            document.addEventListener('mousemove', (e) => {
                if (!isDragging || !activeTile) return;

                const boardRect = board.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();
                const discardRect = discardZone ? discardZone.getBoundingClientRect() : null;

                // ‚úÖ Mouse-un board-a nisb…ôt…ôn pozisiyasƒ±
                let boardX = e.clientX - boardRect.left - mouseOffsetX;
                let boardY = e.clientY - boardRect.top - mouseOffsetY;

                // ‚úÖ Container s…ôrh…ôdl…ôrind…ô saxla
                const tileWidth = 36;
                const tileHeight = 55;

                // Board-dan √ßƒ±xa bil…ôr amma container-dan √ßƒ±xmaz
                const minX = containerRect.left - boardRect.left - mouseOffsetX;
                const maxX = containerRect.right - boardRect.left - mouseOffsetX - tileWidth;
                const minY = containerRect.top - boardRect.top - mouseOffsetY;
                const maxY = containerRect.bottom - boardRect.top - mouseOffsetY - tileHeight;

                boardX = Math.max(minX, Math.min(boardX, maxX));
                boardY = Math.max(minY, Math.min(boardY, maxY));

                // ‚úÖ Pozisiyanƒ± t…ôtbiq et
                activeTile.style.left = boardX + 'px';
                activeTile.style.top = boardY + 'px';

                // ‚úÖ Discard zone √ºz…ôrind…ôdirs…ô?
                if (discardRect && hasDrawn && mustDiscard && isMyTurn) {
                    const tileCenterX = e.clientX;
                    const tileCenterY = e.clientY;

                    isOverDiscardZone =
                        tileCenterX >= discardRect.left &&
                        tileCenterX <= discardRect.right &&
                        tileCenterY >= discardRect.top &&
                        tileCenterY <= discardRect.bottom;

                    if (isOverDiscardZone) {
                        discardZone.classList.add('can-drop');
                    } else {
                        discardZone.classList.remove('can-drop');
                    }
                }
            });

            // ‚úÖ MOUSE UP
            document.addEventListener('mouseup', (e) => {
                if (isDragging && activeTile && activeIdx !== null) {
                    const boardRect = board.getBoundingClientRect();
                    const discardRect = discardZone ? discardZone.getBoundingClientRect() : null;

                    // ‚úÖ Discard zone-a atƒ±ldƒ±mƒ±?
                    if (discardRect && hasDrawn && mustDiscard && isMyTurn && isOverDiscardZone) {
                        const tileId = myHand[activeIdx].id;

                        discardZone.classList.remove('can-drop');
                        activeTile.remove();

                        if (myHand.length === 1) {
                            log('üèÜ Son da≈ü atƒ±lƒ±r - oyun bitir!');
                            showNotification('Son da≈ü atƒ±ldƒ±! Yoxlanƒ±lƒ±r...', 'success');
                            setTimeout(() => declareWin(), 300);
                        } else {
                            discardTile(tileId);
                        }
                    }
                    // ‚úÖ Board i√ßind…ôdirs…ô - snap
                    else {
                        // Board-a nisb…ôt…ôn pozisiya
                        let boardX = e.clientX - boardRect.left - mouseOffsetX;
                        let boardY = e.clientY - boardRect.top - mouseOffsetY;

                        // Board s…ôrh…ôdl…ôrind…ô saxla
                        const tileWidth = 36;
                        boardX = Math.max(0, Math.min(boardX, boardRect.width - tileWidth));

                        // Hansƒ± s…ôtir…ô snap?
                        const SNAP_THRESHOLD = 55; // ∆èvv…ôl 50 idi
                        const targetY = boardY < SNAP_THRESHOLD ? ROW_1_Y : ROW_2_Y;


                        let finalX = boardX;
                        let finalY = targetY;

                        // Toqqu≈üma yoxla
                        if (!isPositionValid(finalX, finalY, activeIdx)) {
                            const validPos = findNearestValidPosition(finalX, finalY, activeIdx, boardRect.width);
                            finalX = validPos.x;
                            finalY = validPos.y;
                        }

                        myHand[activeIdx].x = finalX;
                        myHand[activeIdx].y = finalY;

                        // ‚úÖ Cache-…ô …ôlav…ô et
                        tilePositions[myHand[activeIdx].id] = { x: finalX, y: finalY };

                        activeTile.style.transition = 'left 0.2s ease-out, top 0.2s ease-out';
                        activeTile.style.left = finalX + 'px';
                        activeTile.style.top = finalY + 'px';
                    }

                    // Reset
                    const tileToUpdate = activeTile;
                    setTimeout(() => {
                        if (tileToUpdate) {
                            tileToUpdate.style.cursor = 'grab';
                            tileToUpdate.style.zIndex = '1';
                            tileToUpdate.style.opacity = '1';
                            tileToUpdate.style.transition = 'none';
                            tileToUpdate.classList.remove('dragging');
                        }
                    }, 300);

                    if (discardZone) discardZone.classList.remove('can-drop');
                }

                isDragging = false;
                activeTile = null;
                activeIdx = null;
                isOverDiscardZone = false;
            });

            // ‚úÖ TOUCH MOVE
            document.addEventListener('touchmove', (e) => {
                if (!isDragging || !activeTile) return;
                e.preventDefault();

                const touch = e.touches[0];
                const boardRect = board.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();
                const discardRect = discardZone ? discardZone.getBoundingClientRect() : null;

                let boardX = touch.clientX - boardRect.left - mouseOffsetX;
                let boardY = touch.clientY - boardRect.top - mouseOffsetY;

                const tileWidth = 36;
                const tileHeight = 55;

                const minX = containerRect.left - boardRect.left - mouseOffsetX;
                const maxX = containerRect.right - boardRect.left - mouseOffsetX - tileWidth;
                const minY = containerRect.top - boardRect.top - mouseOffsetY;
                const maxY = containerRect.bottom - boardRect.top - mouseOffsetY - tileHeight;

                boardX = Math.max(minX, Math.min(boardX, maxX));
                boardY = Math.max(minY, Math.min(boardY, maxY));

                activeTile.style.left = boardX + 'px';
                activeTile.style.top = boardY + 'px';

                if (discardRect && hasDrawn && mustDiscard && isMyTurn) {
                    const tileCenterX = touch.clientX;
                    const tileCenterY = touch.clientY;

                    isOverDiscardZone =
                        tileCenterX >= discardRect.left &&
                        tileCenterX <= discardRect.right &&
                        tileCenterY >= discardRect.top &&
                        tileCenterY <= discardRect.bottom;

                    if (isOverDiscardZone) {
                        discardZone.classList.add('can-drop');
                    } else {
                        discardZone.classList.remove('can-drop');
                    }
                }
            });

            // ‚úÖ TOUCH END
            document.addEventListener('touchend', (e) => {
                if (isDragging && activeTile && activeIdx !== null) {
                    const touch = e.changedTouches[0];
                    const boardRect = board.getBoundingClientRect();
                    const discardRect = discardZone ? discardZone.getBoundingClientRect() : null;

                    if (discardRect && hasDrawn && mustDiscard && isMyTurn && isOverDiscardZone) {
                        const tileId = myHand[activeIdx].id;

                        discardZone.classList.remove('can-drop');
                        activeTile.remove();

                        if (myHand.length === 1) {
                            showNotification('Son da≈ü atƒ±ldƒ±!', 'success');
                            setTimeout(() => declareWin(), 300);
                        } else {
                            discardTile(tileId);
                        }
                    } else {
                        let boardX = touch.clientX - boardRect.left - mouseOffsetX;
                        let boardY = touch.clientY - boardRect.top - mouseOffsetY;

                        const tileWidth = 36;
                        boardX = Math.max(0, Math.min(boardX, boardRect.width - tileWidth));

                        const targetY = boardY < SNAP_THRESHOLD ? ROW_1_Y : ROW_2_Y;

                        let finalX = boardX;
                        let finalY = targetY;

                        if (!isPositionValid(finalX, finalY, activeIdx)) {
                            const validPos = findNearestValidPosition(finalX, finalY, activeIdx, boardRect.width);
                            finalX = validPos.x;
                            finalY = validPos.y;
                        }

                        myHand[activeIdx].x = finalX;
                        myHand[activeIdx].y = finalY;

                        // ‚úÖ Cache-…ô …ôlav…ô et
                        tilePositions[myHand[activeIdx].id] = { x: finalX, y: finalY };

                        activeTile.style.transition = 'left 0.2s ease-out, top 0.2s ease-out';
                        activeTile.style.left = finalX + 'px';
                        activeTile.style.top = finalY + 'px';
                    }

                    const tileToUpdate = activeTile;
                    setTimeout(() => {
                        if (tileToUpdate) {
                            tileToUpdate.style.zIndex = '1';
                            tileToUpdate.style.opacity = '1';
                            tileToUpdate.style.transition = 'none';
                            tileToUpdate.classList.remove('dragging');
                        }
                    }, 300);

                    if (discardZone) discardZone.classList.remove('can-drop');
                }

                isDragging = false;
                activeTile = null;
                activeIdx = null;
                isOverDiscardZone = false;
            });
        }



        function displayDiscardedTile(tile, playerPosition) {
            const relativePos = getRelativePosition(myPosition, playerPosition);
            let zoneId = '';

            if (relativePos === 'bottom') zoneId = 'myDiscardZone';
            else if (relativePos === 'top') zoneId = 'discardZoneTop';
            else if (relativePos === 'left') zoneId = 'discardZoneLeft';
            else if (relativePos === 'right') zoneId = 'discardZoneRight';

            const zone = document.getElementById(zoneId);
            if (zone && tile) {
                // if (zone.innerHTML.includes('üóëÔ∏è')) {
                //     zone.innerHTML = '';
                // }

                zone.insertAdjacentHTML('beforeend', createTileHTML(tile, 0));

                const tiles = zone.querySelectorAll('.okey-tile');
                if (tiles.length > 3) {
                    tiles[0].remove();
                }

                // ‚úÖ YENƒ∞ - 2 n…ôf…ôrlikd…ô top oyun√ßunun da≈üƒ±nƒ± g√∂t√ºr…ô bilm…ôk
                if (maxPlayers === 2 && zoneId === 'discardZoneTop') {
                    zone.classList.add('clickable');
                    zone.style.cursor = 'pointer';
                }
            }
        }

        function clearAllDiscardZones() {
            ['myDiscardZone', 'discardZoneTop', 'discardZoneLeft', 'discardZoneRight'].forEach(id => {
                const zone = document.getElementById(id);
                if (zone) {
                    // Tam t…ômizl…ô
                    zone.innerHTML = '';

                    // ƒ∞kon …ôlav…ô et
                    if (id === 'myDiscardZone') {
                        zone.innerHTML = '';
                    } else {
                        zone.innerHTML = '';
                    }

                    // Style-ƒ± sƒ±fƒ±rla
                    zone.classList.remove('clickable', 'can-drop');
                    zone.style.cursor = '';
                    zone.style.transform = '';
                    zone.style.boxShadow = '';
                    zone.style.borderColor = '';
                }
            });

            console.log('‚úÖ Discard zona-larƒ± t…ômizl…ôndi');
        }

        function updatePlayersDisplay(players) {
            // ∆èvv…ôlc…ô hamƒ±sƒ±nƒ± gizl…ôt
            ['playerInfoTop', 'playerInfoLeft', 'playerInfoRight'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.style.display = 'none';
                    el.classList.remove('active');
                }
            });

            players.forEach((player) => {
                const relativePos = getRelativePosition(myPosition, player.position);
                let infoId = '';

                if (relativePos === 'bottom') infoId = 'myPlayerInfo';
                else if (relativePos === 'top') infoId = 'playerInfoTop';
                else if (relativePos === 'left') infoId = 'playerInfoLeft';
                else if (relativePos === 'right') infoId = 'playerInfoRight';

                const infoEl = document.getElementById(infoId);
                if (!infoEl) return;

                // G√∂st…ôr
                infoEl.style.display = 'flex';

                const nameEl = infoEl.querySelector('.player-name');
                const scoreEl = infoEl.querySelector('.player-score');

                if (nameEl) nameEl.textContent = player.name;
                if (scoreEl) scoreEl.textContent = player.score;

                if (player.isActive) infoEl.classList.add('active');
                else infoEl.classList.remove('active');
            });
        }

        function setIndicatorTile(tile) {
            const el = document.getElementById('indicatorTile');
            if (el && tile) el.innerHTML = createTileHTML(tile, 0);
        }

        function setJokerTile(tile) {
            const el = document.getElementById('jokerTile');
            if (el && tile) el.innerHTML = createTileHTML(tile, 0);
        }

        async function tryDrawFromTopPlayer() {
            if (!isMyTurn || hasDrawn || mustDiscard) {
                if (mustDiscard) showNotification('∆èvv…ôlc…ô da≈ü atƒ±n!', 'error');
                else if (hasDrawn) showNotification('Artƒ±q da≈ü √ß…ôkmisiniz!', 'error');
                else showNotification('N√∂vb…ôniz deyil!', 'error');
                return;
            }

            const zone = document.getElementById('discardZoneTop');
            if (!zone || !zone.querySelector('.okey-tile')) {
                showNotification('R…ôqib h…ôl…ô da≈ü atmayƒ±b', 'error');
                return;
            }

            try {
                log('üé¥ Top oyun√ßudan da≈ü g√∂t√ºr√ºr…ôm...');
                await connection.invoke("DrawTile", "discard");
                setTimeout(() => {
                    zone.innerHTML = '';
                    log('‚úÖ Top oyun√ßunun da≈üƒ± silindi');
                }, 150);
            } catch (err) {
                log('‚ùå Draw from discard error:', err);
                showNotification('Da≈üƒ± g√∂t√ºrm…ôk m√ºmk√ºn olmadƒ±', 'error');
            }
        }

        // ‚úÖ Global scope-a …ôlav…ô et
        window.tryDrawFromTopPlayer = tryDrawFromTopPlayer;

        function updateTurnUI() {
            const deckStack = document.getElementById('deckStack');

            if (isMyTurn && !hasDrawn && !mustDiscard) {
                deckStack?.classList.remove('disabled');
            } else {
                deckStack?.classList.add('disabled');
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            log('üéÆ Okey Premium Loaded');
            document.getElementById('leaveRoomBtn')?.addEventListener('click', leaveRoom);
            document.getElementById('sortBtn')?.addEventListener('click', sortTiles);
            document.getElementById('deckStack')?.addEventListener('click', drawFromStock);

            initializeSignalR();
        });
        console.log(document.getElementById('myBoard')); // null deyils…ô OK
        console.log(myHand); // da≈ülar varmƒ±?
        window.joinRoom = joinRoom;
        window.tryDrawFromLeftPlayer = tryDrawFromLeftPlayer;

    </script>
</body>

</html>
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" /> -->

    <title>Okey</title>
    <link rel="stylesheet" href="./Okey.css">
</head>

<body>
    <div class="okey-game-container">
        <!-- <div class="notification">asjkdlfalsdjf</div> -->
        <div id="roomListScreen" class="screen active">
            <div class="room-list-container">
                <div class="header">
                    <button class="back-btn" onclick="backToGames()">
                        â†
                    </button>
                    <!-- <h1>OKEY 51</h1> -->
                        <div class="header-title" data-i18n="header_title">OKEY 51</div>
                    <!-- <span class="user-name" id="userName">YÃ¼klÉ™nir...</span> -->
                    <span class="user-balance" id="userBalance">0</span>

                </div>

                <div class="rooms-grid" id="roomsGrid">
                    <div class="loading-container" aria-live="polite">
                        <div class="sparkles" aria-hidden="true">
                            <span class="sparkle s1"></span>
                            <span class="sparkle s2"></span>
                            <span class="sparkle s3"></span>
                            <span class="sparkle s4"></span>
                            <span class="sparkle s5"></span>
                        </div>

                        <div class="okey-loading-stage">
                            <div class="rack-shadow" aria-hidden="true"></div>
                            <div class="rack-base" aria-hidden="true"></div>

                            <div class="tile-stack tile-a">
                                <div class="okey-tile red">
                                    <span class="tile-number">7</span>
                                    <span class="tile-dot"></span>
                                </div>
                            </div>

                            <div class="tile-stack tile-b">
                                <div class="okey-tile blue">
                                    <span class="tile-number">11</span>
                                    <span class="tile-dot"></span>
                                </div>
                            </div>

                            <div class="tile-stack tile-c">
                                <div class="okey-tile black">
                                    <span class="tile-number">3</span>
                                    <span class="tile-dot"></span>
                                </div>
                            </div>

                            <div class="tile-stack tile-joker">
                                <div class="okey-tile joker">
                                    <span class="tile-star">â˜…</span>
                                    <span class="tile-tag">OK</span>
                                </div>
                            </div>
                        </div>

                        <p class="loading-text" data-i18n="loading_rooms">Dealing your tiles...</p>
                    </div>
                </div>
                <!-- Lobby Bet Modal -->
                <div id="lobbyBetModal" class="modal-overlay" style="display: none;"
                    onclick="if(event.target === this) closeLobbyBetModal()">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h2 data-i18n="bet_select">Select Bet</h2>
                            <button class="modal-close" onclick="closeLobbyBetModal()">Ã—</button>
                        </div>
                        <div class="modal-body" id="lobbyBetOptions"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="gameScreen" class="screen">
            <div class="game-container">
                <div class="game-header">
                    <div class="game-info">
                        <span id="roomNameDisplay" data-i18n-placeholder="room_label">Room</span>
                        <!-- <span id="gameModeDisplay" style="color: #f39c12;">Mod: 51</span> -->
                        <span id="potAmountDisplay" style="color: #27ae60;">Pot: 0</span>
                    </div>
                    <div class="current-user-info">
                        <div class="player-name" id="myPlayerName" data-i18n-placeholder="you">You</div>
                        <!-- <div class="player-score" id="myScore">101</div> -->
                    </div>
                    <button id="leaveRoomBtn" class="btn btn-danger" data-i18n="leave">Leave</button>
                    <!-- <button onclick="goFullscreen()" class="btn btn-danger">Tam Ekran</button> -->
                </div>

                <div class="game-table">
                    <div class="player-section player-section-top">
                        <div class="player-deck-section">

                            <div class="player-deck-top" id="playerInfoTop">
                                <div class="player-avatar">ğŸ‘¤</div>
                                <div class="player-details detail-sides">
                                    <div id="topPlayerName" class="player-name" data-i18n-placeholder="waiting">Waiting</div>
                                    <!-- <div class="player-score">101</div> -->
                                </div>
                            </div>
                        </div>
                        <!-- <div class="discard-zone" id="discardZoneTop">ğŸ—‘ï¸</div> -->
                        <div class="discard-zone" id="discardZoneTop" onclick="tryDrawFromTopPlayer()">
                            <!-- ğŸ—‘ï¸ -->
                        </div>

                    </div>

                    <div class="player-section player-section-right">
                        <div class="discard-zone discard-zone-right" id="discardZoneRight">
                        </div>
                        <div class="player-deck-section deck-right">
                            <div class="player-deck-right" id="playerInfoRight">
                                <div class="player-avatar avatar-right">ğŸ‘¤</div>
                                <div class="player-details detail-sides">
                                    <div id="rightPlayerName" class="player-name" data-i18n-placeholder="waiting">Waiting</div>
                                    <!-- <div class="player-score">101</div> -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="player-section player-section-bottom">
                        <div class="my-board-container" id="myBoardContainer">

                            <div class="my-actions">
                                <!-- <button id="declareWinBtn" class="btn-action btn-success" disabled>ğŸ† Bitir</button> -->
                                <!-- <div class="player-info active" id="myPlayerInfo">
                                    <div class="player-avatar">ğŸ˜Š</div>
                                    <div class="player-details">
                                        <div class="player-name" id="myPlayerName">You</div>
                                        <div class="player-score" id="myScore">101</div>
                                    </div>
                                </div> -->
                                <!-- <button id="sortBtn" class="btn-action">SÄ±rala</button> -->
                            </div>

                            <div class="my-board" id="myBoard">
                                <!-- <div class="tile-row" id="myRow1"></div>
                                <div class="tile-row" id="myRow2"></div> -->
                            </div>
                            <div class="my-discard-zone" id="myDiscardZone">
                                <!-- ğŸ—‘ï¸
                                <div class="discard-label">BURAYA<br>AT</div> -->
                            </div>
                        </div>


                    </div>

                    <div class="player-section player-section-left">
                        <div class="player-deck-section deck-left">
                            <div class="player-deck-left" id="playerInfoLeft">
                                <div class="player-avatar avatar-left">ğŸ‘¤</div>
                                <div class="player-details detail-sides">
                                    <div id="leftPlayerName" class="player-name" data-i18n-placeholder="waiting">Waiting</div>
                                    <!-- <div class="player-score">101</div> -->
                                </div>
                            </div>
                        </div>
                        <div class="discard-zone clickable discard-zone-left" id="discardZoneLeft"
                            onclick="tryDrawFromLeftPlayer()">
                        </div>
                    </div>

                    <div class="center-area">
                        <!-- <div class="indicator-wrapper"> -->
                        <!-- <div class="indicator-label">ğŸ¯ OKEY</div> -->
                        <!-- </div> -->

                        <div id="indicatorTile"></div>
                        <div class="deck-stack" id="deckStack">
                            <div class="deck-tile-layer" id="deckCountLabel"></div>
                            <!-- <div class="deck-label" id="deckCountLabel">106</div> -->
                        </div>
                        <!-- <div id="notification" class="notification"></div> -->

                        <!-- âœ… Qazanan kombinasiya modalÄ± -->
                        <div id="winModal" class="win-modal">
                            <h2 data-i18n="win_combo_title">ğŸ† WINNING COMBINATION</h2>
                            <div id="winMeldsContainer" class="win-melds"></div>
                        </div>
                        <div class="indicator-wrapper">
                            <!-- <div class="indicator-label">ğŸƒ JOKER</div>
                        <div id="jokerTile"></div> -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- <div id="notification" class="notification"></div> -->


    </div>

    <script src="https://cdn.jsdelivr.net/npm/@microsoft/signalr@latest/dist/browser/signalr.min.js"></script>
    <script>

        playerPositions = {
            top: topPlayerName,
            right: rightPlayerName,
            left: leftPlayerName
        }

        function getPlayerNames() {
            return {
                top: document.getElementById("topPlayerName")?.textContent || "",
                right: document.getElementById("rightPlayerName")?.textContent || "",
                left: document.getElementById("leftPlayerName")?.textContent || ""
            };
        }
        let activeTimerInterval = null;
        function findPosition(username) {
            // Top player
            const topName = document.getElementById("topPlayerName")?.textContent;
            if (topName === username) return 'top';

            // Right player
            const rightName = document.getElementById("rightPlayerName")?.textContent;
            if (rightName === username) return 'right';

            // Left player
            const leftName = document.getElementById("leftPlayerName")?.textContent;
            if (leftName === username) return 'left';

            // Bottom (Ã¶zÃ¼m)
            const myName = document.querySelector('#myPlayerName')?.textContent;
            if (myName === username) return 'bottom';

            console.log(topName, rightName, leftName, myName);

            return null;
        }
        // function showTimer(username, seconds) {
        //     const position = findPosition(username);
        //     if (!position) {
        //         console.log('âŒ Player tapÄ±lmadÄ±:', username);
        //         return;
        //     }

        //     console.log(`âœ… Timer: ${username} (${position}) - ${seconds}s`);

        //     // ÆvvÉ™lki timer-lÉ™ri sil
        //     document.querySelectorAll('.player-deck-top, .player-deck-right, .player-deck-left').forEach(el => {
        //         el.classList.remove('timer-active');
        //     });

        //     // Element tap
        //     let deckElement = null;
        //     if (position === 'top') deckElement = document.querySelector('.player-deck-top');
        //     if (position === 'right') deckElement = document.querySelector('.player-deck-right');
        //     if (position === 'left') deckElement = document.querySelector('.player-deck-left');

        //     if (deckElement) {
        //         const percentage = (seconds / 30) * 100; // 30 = max saniyÉ™

        //         // RÉ™ng
        //         let color = '#4CAF50'; // yaÅŸÄ±l
        //         if (seconds <= 10) color = '#FFC107'; // sarÄ±
        //         if (seconds <= 5) color = '#f44336'; // qÄ±rmÄ±zÄ±

        //         deckElement.style.setProperty('--timer-progress', `${percentage}%`);
        //         deckElement.style.setProperty('--timer-color', color);
        //         deckElement.classList.add('timer-active');
        //     }
        // }

        function showTimer(username, seconds) {
            const position = findPosition(username);
            if (!position) {
                console.log('âŒ Player tapÄ±lmadÄ±:', username);
                return;
            }

            console.log(`âœ… Timer baÅŸladÄ±: ${username} (${position}) - ${seconds}s`);

            // KÃ¶hnÉ™ timer-i dayandÄ±r
            if (activeTimerInterval) {
                clearInterval(activeTimerInterval);
                activeTimerInterval = null;
            }

            // ÆvvÉ™lki timer-lÉ™ri sil
            document.querySelectorAll('.player-deck-top, .player-deck-right, .player-deck-left,.my-board').forEach(el => {
                el.classList.remove('timer-active');
            });

            // Element tap
            let deckElement = null;
            if (position === 'top') deckElement = document.querySelector('.player-deck-top');
            if (position === 'right') deckElement = document.querySelector('.player-deck-right');
            if (position === 'left') deckElement = document.querySelector('.player-deck-left');
            if (position === 'bottom') deckElement = document.querySelector('.my-board');

            if (!deckElement) return;

            let remainingSeconds = seconds;
            const maxSeconds = 33;

            // Ä°lk gÃ¶stÉ™r
            updateTimerDisplay(deckElement, remainingSeconds, maxSeconds);

            // HÉ™r saniyÉ™ yenilÉ™
            activeTimerInterval = setInterval(() => {
                remainingSeconds--;

                if (remainingSeconds <= 0) {
                    clearInterval(activeTimerInterval);
                    activeTimerInterval = null;
                    deckElement.classList.remove('timer-active');
                    console.log('â° Timer bitdi');
                    return;
                }

                updateTimerDisplay(deckElement, remainingSeconds, maxSeconds);
            }, 1000);
        }
        function updateTimerDisplay(element, seconds, maxSeconds) {
            const percentage = (seconds / maxSeconds) * 100;

            // RÉ™ng
            let color = '#4CAF50'; // yaÅŸÄ±l
            if (seconds <= 10) color = '#FFC107'; // sarÄ±
            if (seconds <= 5) color = '#f44336'; // qÄ±rmÄ±zÄ±

            element.style.setProperty('--timer-progress', `${percentage}%`);
            element.style.setProperty('--timer-color', color);
            element.classList.add('timer-active');

            console.log(`â±ï¸ Timer: ${seconds}s (${percentage.toFixed(0)}%)`);
        }
        // function clearTimers() {
        //     document.querySelectorAll('.player-deck-top, .player-deck-right, .player-deck-left').forEach(el => {
        //         el.classList.remove('timer-active');
        //     });
        // }

        function clearTimers() {
            if (activeTimerInterval) {
                clearInterval(activeTimerInterval);
                activeTimerInterval = null;
            }

            document.querySelectorAll('.player-deck-top, .player-deck-right, .player-deck-left').forEach(el => {
                el.classList.remove('timer-active');
            });

            console.log('ğŸ§¹ Timer-lÉ™r tÉ™mizlÉ™ndi');
        }

        window.addEventListener("load", () => {
            setTimeout(() => {
                window.scrollTo(0, 1);
            }, 100);
        });

        function checkTileCollision(x1, y1, x2, y2) {
            const tileWidth = 36;
            const tileHeight = 55;
            const tolerance = 4; // âœ… 4px overlap-É™ icazÉ™ ver

            return !(
                x1 + tileWidth - tolerance <= x2 ||
                x2 + tileWidth - tolerance <= x1 ||
                y1 + tileHeight - tolerance <= y2 ||
                y2 + tileHeight - tolerance <= y1
            );
        }

        function isPositionValid(x, y, currentIdx) {
            for (let i = 0; i < myHand.length; i++) {
                if (i === currentIdx) continue;
                const otherTile = myHand[i];
                if (otherTile.x !== undefined && otherTile.y !== undefined) {
                    if (checkTileCollision(x, y, otherTile.x, otherTile.y)) {
                        return false;
                    }
                }
            }
            return true;
        }

        function findNearestValidPosition(targetX, targetY, currentIdx, boardWidth) {
            const tileWidth = 36;
            const gap = 3; // âœ… Gap artÄ±rÄ±ldÄ±
            const ROW_1_Y = 10;
            const ROW_2_Y = 70; // âœ… YenilÉ™ndi

            const snappedY = targetY < 55 ? ROW_1_Y : ROW_2_Y; // âœ… Threshold yenilÉ™ndi

            // âœ… Ä°lk olaraq dÉ™qiq yeri yoxla
            if (isPositionValid(targetX, snappedY, currentIdx)) {
                return { x: targetX, y: snappedY };
            }

            // âœ… X eksenindÉ™ kiÃ§ik addÄ±mlarla yoxla
            const step = tileWidth + gap;
            const maxSearchDistance = boardWidth;

            for (let offset = gap; offset < maxSearchDistance; offset += step) {
                // SaÄŸa yoxla
                let testX = targetX + offset;
                if (testX + tileWidth <= boardWidth && isPositionValid(testX, snappedY, currentIdx)) {
                    return { x: testX, y: snappedY };
                }

                // Sola yoxla
                testX = targetX - offset;
                if (testX >= 0 && isPositionValid(testX, snappedY, currentIdx)) {
                    return { x: testX, y: snappedY };
                }
            }

            // âœ… BaÅŸqa sÉ™tirdÉ™ yoxla
            const alternateY = snappedY === ROW_1_Y ? ROW_2_Y : ROW_1_Y;

            if (isPositionValid(targetX, alternateY, currentIdx)) {
                return { x: targetX, y: alternateY };
            }

            for (let offset = gap; offset < maxSearchDistance; offset += step) {
                let testX = targetX + offset;
                if (testX + tileWidth <= boardWidth && isPositionValid(testX, alternateY, currentIdx)) {
                    return { x: testX, y: alternateY };
                }

                testX = targetX - offset;
                if (testX >= 0 && isPositionValid(testX, alternateY, currentIdx)) {
                    return { x: testX, y: alternateY };
                }
            }

            // âœ… HeÃ§ yer tapÄ±lmasa, orijinal yeri saxla
            return {
                x: myHand[currentIdx].x || targetX,
                y: myHand[currentIdx].y || snappedY
            };
        }
        function autoArrangeTiles() {
            const tileWidth = 36;
            const gap = 3;
            const startX = 10;
            const maxPerRow = 8;
            const ROW_1_Y = 10;
            const ROW_2_Y = 70;

            myHand.forEach((tile, idx) => {
                const row = Math.floor(idx / maxPerRow);
                const col = idx % maxPerRow;

                tile.x = startX + col * (tileWidth + gap);
                tile.y = row === 0 ? ROW_1_Y : ROW_2_Y;

                // âœ… Cache-É™ É™lavÉ™ et
                tilePositions[tile.id] = { x: tile.x, y: tile.y };
            });
        }


        // âœ… Bu yeni dÉ™yiÅŸÉ™nlÉ™ri ÆLAVÆ ET (scriptÄ±n É™vvÉ™lindÉ™):
        let IFRAME_TOKEN = null;
        let IFRAME_USER = null;

        const translations = {
                en: {
                    app_title: 'Okey',
                    header_title: 'OKEY 51',
                loading_rooms: 'Dealing your tiles...',
                bet_select: 'Select Bet',
                room_label: 'Room',
                pot_label: 'Pot: {amount}â‚¼',
                you: 'You',
                leave: 'Leave',
                waiting: 'Waiting',
                win_combo_title: 'ğŸ† WINNING COMBINATION',
                token_not_found: 'Token not found!',
                connection_success: 'Connected successfully!',
                connection_error: 'Connection error',
                connection_error_with: 'Connection error: {message}',
                joined_room: 'You joined the room',
                your_turn_draw: 'Your turn! DRAW A TILE!',
                tile_drawn_discard: 'You drew a tile, now DISCARD!',
                player_timeout_auto_discard: '{player} timed out - tile auto discarded',
                player_joined: '{player} joined',
                player_left: '{player} left',
                player_drew: '{player} drew a tile',
                auto_action: 'Auto action',
                draw_turn_wait: 'Wait for your turn',
                discard_now: 'DISCARD NOW!',
                discard_first: 'Discard first!',
                already_drew: 'You already drew a tile!',
                not_your_turn: 'Not your turn!',
                opponent_not_discarded: 'Opponent has not discarded yet',
                draw_failed: 'Could not draw the tile',
                draw_first: 'Draw a tile first!',
                error_occurred: 'An error occurred',
                room_list_empty: 'No rooms found',
                players_label: 'Players',
                no_rooms: 'No rooms',
                player_count_game: '{count} Player Game',
                no_rooms_for_count: 'No rooms for this player count',
                joining: 'Joining...',
                join_failed: 'Unable to join',
                sort_done: 'Sorted',
                you_start: 'You start the game! DISCARD! ğŸ®',
                game_started: 'Game started! ğŸ®',
                winner_announcement: 'ğŸ‰ {winner} won!',
                group_label: 'Group {index}:',
                finish_type: 'ğŸ–ï¸ Finish type: <strong>{type}</strong>',
                final_winner: 'ğŸ† Final winner: {winner}',
                rank_updated: 'ğŸ–ï¸ {rank} - Level {level}',
                ten_seconds_left: 'â° 10 seconds left!',
                five_seconds_left: 'âš ï¸ 5 seconds left! Hurry!',
                auto_discarding: 'ğŸš¨ AUTO DISCARDING!',
                new_round_preparing: 'New round is being prepared...',
                leave_confirm: 'Do you want to leave?',
                deck_count: 'ğŸ“š {count}',
                deck_empty: 'âŒ EMPTY',
                last_tile_discarded_checking: 'Last tile discarded! Checking...',
                last_tile_discarded: 'Last tile discarded!'
            },
            tr: {
                app_title: 'Okey',
                header_title: 'OKEY 51',
                loading_rooms: 'TaÅŸlar daÄŸÄ±tÄ±lÄ±yor...',
                bet_select: 'Bahis SeÃ§',
                room_label: 'Oda',
                pot_label: 'Pot: {amount}â‚¼',
                you: 'Sen',
                leave: 'Ã‡Ä±k',
                waiting: 'Bekliyor',
                win_combo_title: 'ğŸ† KAZANAN KOMBÄ°NASYON',
                token_not_found: 'Token bulunamadÄ±!',
                connection_success: 'BaÄŸlantÄ± baÅŸarÄ±lÄ±!',
                connection_error: 'BaÄŸlantÄ± hatasÄ±',
                connection_error_with: 'BaÄŸlantÄ± hatasÄ±: {message}',
                joined_room: 'Odaya girdiniz',
                your_turn_draw: 'SÄ±ra sende! TAÅ Ã‡EK!',
                tile_drawn_discard: 'TaÅŸ Ã§ektin, ÅŸimdi TAÅ AT!',
                player_timeout_auto_discard: '{player} sÃ¼resi doldu - taÅŸ otomatik atÄ±ldÄ±',
                player_joined: '{player} katÄ±ldÄ±',
                player_left: '{player} Ã§Ä±ktÄ±',
                player_drew: '{player} taÅŸ Ã§ekti',
                auto_action: 'Otomatik iÅŸlem',
                draw_turn_wait: 'SÄ±ranÄ± bekle',
                discard_now: 'HEMEN TAÅ AT!',
                discard_first: 'Ã–nce taÅŸ at!',
                already_drew: 'Zaten taÅŸ Ã§ektin!',
                not_your_turn: 'SÄ±ran deÄŸil!',
                opponent_not_discarded: 'Rakip henÃ¼z taÅŸ atmadÄ±',
                draw_failed: 'TaÅŸ alÄ±namadÄ±',
                draw_first: 'Ã–nce taÅŸ Ã§ek!',
                error_occurred: 'Bir hata oluÅŸtu',
                room_list_empty: 'Oda bulunamadÄ±',
                players_label: 'KiÅŸilik',
                no_rooms: 'Oda yok',
                player_count_game: '{count} KiÅŸilik Oyun',
                no_rooms_for_count: 'Bu oyuncu sayÄ±sÄ± iÃ§in oda yok',
                joining: 'KatÄ±lÄ±yor...',
                join_failed: 'KatÄ±lÄ±m baÅŸarÄ±sÄ±z',
                sort_done: 'SÄ±ralandÄ±',
                you_start: 'Oyunu sen baÅŸlÄ±yorsun! TAÅ AT! ğŸ®',
                game_started: 'Oyun baÅŸladÄ±! ğŸ®',
                winner_announcement: 'ğŸ‰ {winner} kazandÄ±!',
                group_label: 'Grup {index}:',
                finish_type: 'ğŸ–ï¸ BitiriÅŸ tÃ¼rÃ¼: <strong>{type}</strong>',
                final_winner: 'ğŸ† Final kazanan: {winner}',
                rank_updated: 'ğŸ–ï¸ {rank} - Seviye {level}',
                ten_seconds_left: 'â° 10 saniye kaldÄ±!',
                five_seconds_left: 'âš ï¸ 5 saniye kaldÄ±! Hadi!',
                auto_discarding: 'ğŸš¨ OTOMATÄ°K TAÅ ATILIYOR!',
                new_round_preparing: 'Yeni tur hazÄ±rlanÄ±yor...',
                leave_confirm: 'Ã‡Ä±kmak istiyor musunuz?',
                deck_count: 'ğŸ“š {count}',
                deck_empty: 'âŒ BOÅ',
                last_tile_discarded_checking: 'Son taÅŸ atÄ±ldÄ±! Kontrol ediliyor...',
                last_tile_discarded: 'Son taÅŸ atÄ±ldÄ±!'
            },
            hi: {
                app_title: 'à¤“à¤•à¥‡',
                header_title: 'OKEY 51',
                loading_rooms: 'à¤Ÿà¤¾à¤‡à¤²à¥‡à¤‚ à¤¬à¤¾à¤à¤Ÿà¥€ à¤œà¤¾ à¤°à¤¹à¥€ à¤¹à¥ˆà¤‚...',
                bet_select: 'à¤¬à¥‡à¤Ÿ à¤šà¥à¤¨à¥‡à¤‚',
                room_label: 'à¤•à¤®à¤°à¤¾',
                pot_label: 'à¤ªà¥‰à¤Ÿ: {amount}â‚¼',
                you: 'à¤†à¤ª',
                leave: 'à¤¬à¤¾à¤¹à¤° à¤œà¤¾à¤à¤‚',
                waiting: 'à¤ªà¥à¤°à¤¤à¥€à¤•à¥à¤·à¤¾',
                win_combo_title: 'ğŸ† à¤µà¤¿à¤œà¥‡à¤¤à¤¾ à¤¸à¤‚à¤¯à¥‹à¤œà¤¨',
                token_not_found: 'à¤Ÿà¥‹à¤•à¤¨ à¤¨à¤¹à¥€à¤‚ à¤®à¤¿à¤²à¤¾!',
                connection_success: 'à¤•à¤¨à¥‡à¤•à¥à¤¶à¤¨ à¤¸à¤«à¤²!',
                connection_error: 'à¤•à¤¨à¥‡à¤•à¥à¤¶à¤¨ à¤¤à¥à¤°à¥à¤Ÿà¤¿',
                connection_error_with: 'à¤•à¤¨à¥‡à¤•à¥à¤¶à¤¨ à¤¤à¥à¤°à¥à¤Ÿà¤¿: {message}',
                joined_room: 'à¤†à¤ª à¤•à¤®à¤°à¥‡ à¤®à¥‡à¤‚ à¤¶à¤¾à¤®à¤¿à¤² à¤¹à¥à¤',
                your_turn_draw: 'à¤†à¤ªà¤•à¥€ à¤¬à¤¾à¤°à¥€ à¤¹à¥ˆ! à¤Ÿà¤¾à¤‡à¤² à¤²à¥‡à¤‚!',
                tile_drawn_discard: 'à¤†à¤ªà¤¨à¥‡ à¤Ÿà¤¾à¤‡à¤² à¤²à¥€, à¤…à¤¬ à¤«à¥‡à¤‚à¤•à¥‡à¤‚!',
                player_timeout_auto_discard: '{player} à¤•à¤¾ à¤¸à¤®à¤¯ à¤¸à¤®à¤¾à¤ªà¥à¤¤ - à¤Ÿà¤¾à¤‡à¤² à¤…à¤ªà¤¨à¥‡ à¤†à¤ª à¤«à¥‡à¤‚à¤•à¥€ à¤—à¤ˆ',
                player_joined: '{player} à¤¶à¤¾à¤®à¤¿à¤² à¤¹à¥à¤†',
                player_left: '{player} à¤¬à¤¾à¤¹à¤° à¤—à¤¯à¤¾',
                player_drew: '{player} à¤¨à¥‡ à¤Ÿà¤¾à¤‡à¤² à¤²à¥€',
                auto_action: 'à¤¸à¥à¤µà¤šà¤¾à¤²à¤¿à¤¤ à¤•à¥à¤°à¤¿à¤¯à¤¾',
                draw_turn_wait: 'à¤…à¤ªà¤¨à¥€ à¤¬à¤¾à¤°à¥€ à¤•à¤¾ à¤‡à¤‚à¤¤à¤œà¤¾à¤° à¤•à¤°à¥‡à¤‚',
                discard_now: 'à¤…à¤­à¥€ à¤«à¥‡à¤‚à¤•à¥‡à¤‚!',
                discard_first: 'à¤ªà¤¹à¤²à¥‡ à¤Ÿà¤¾à¤‡à¤² à¤«à¥‡à¤‚à¤•à¥‡à¤‚!',
                already_drew: 'à¤†à¤ª à¤ªà¤¹à¤²à¥‡ à¤¹à¥€ à¤Ÿà¤¾à¤‡à¤² à¤²à¥‡ à¤šà¥à¤•à¥‡ à¤¹à¥ˆà¤‚!',
                not_your_turn: 'à¤†à¤ªà¤•à¥€ à¤¬à¤¾à¤°à¥€ à¤¨à¤¹à¥€à¤‚ à¤¹à¥ˆ!',
                opponent_not_discarded: 'à¤ªà¥à¤°à¤¤à¤¿à¤¦à¥à¤µà¤‚à¤¦à¥à¤µà¥€ à¤¨à¥‡ à¤…à¤­à¥€ à¤¤à¤• à¤Ÿà¤¾à¤‡à¤² à¤¨à¤¹à¥€à¤‚ à¤«à¥‡à¤‚à¤•à¥€',
                draw_failed: 'à¤Ÿà¤¾à¤‡à¤² à¤¨à¤¹à¥€à¤‚ à¤²à¥€ à¤œà¤¾ à¤¸à¤•à¥€',
                draw_first: 'à¤ªà¤¹à¤²à¥‡ à¤Ÿà¤¾à¤‡à¤² à¤²à¥‡à¤‚!',
                error_occurred: 'à¤à¤• à¤¤à¥à¤°à¥à¤Ÿà¤¿ à¤¹à¥à¤ˆ',
                room_list_empty: 'à¤•à¥‹à¤ˆ à¤•à¤®à¤°à¤¾ à¤¨à¤¹à¥€à¤‚ à¤®à¤¿à¤²à¤¾',
                players_label: 'à¤–à¤¿à¤²à¤¾à¤¡à¤¼à¥€',
                no_rooms: 'à¤•à¥‹à¤ˆ à¤•à¤®à¤°à¤¾ à¤¨à¤¹à¥€à¤‚',
                player_count_game: '{count} à¤–à¤¿à¤²à¤¾à¤¡à¤¼à¥€ à¤–à¥‡à¤²',
                no_rooms_for_count: 'à¤‡à¤¸ à¤–à¤¿à¤²à¤¾à¤¡à¤¼à¥€ à¤¸à¤‚à¤–à¥à¤¯à¤¾ à¤•à¥‡ à¤²à¤¿à¤ à¤•à¥‹à¤ˆ à¤•à¤®à¤°à¤¾ à¤¨à¤¹à¥€à¤‚',
                joining: 'à¤œà¥à¤¡à¤¼ à¤°à¤¹à¥‡ à¤¹à¥ˆà¤‚...',
                join_failed: 'à¤¶à¤¾à¤®à¤¿à¤² à¤¹à¥‹à¤¨à¤¾ à¤…à¤¸à¤«à¤²',
                sort_done: 'à¤•à¥à¤°à¤®à¤¬à¤¦à¥à¤§',
                you_start: 'à¤†à¤ª à¤–à¥‡à¤² à¤¶à¥à¤°à¥‚ à¤•à¤°à¤¤à¥‡ à¤¹à¥ˆà¤‚! à¤Ÿà¤¾à¤‡à¤² à¤«à¥‡à¤‚à¤•à¥‡à¤‚! ğŸ®',
                game_started: 'à¤–à¥‡à¤² à¤¶à¥à¤°à¥‚ à¤¹à¥à¤†! ğŸ®',
                winner_announcement: 'ğŸ‰ {winner} à¤œà¥€à¤¤à¤¾!',
                group_label: 'à¤¸à¤®à¥‚à¤¹ {index}:',
                finish_type: 'ğŸ–ï¸ à¤¸à¤®à¤¾à¤ªà¥à¤¤à¤¿ à¤ªà¥à¤°à¤•à¤¾à¤°: <strong>{type}</strong>',
                final_winner: 'ğŸ† à¤…à¤‚à¤¤à¤¿à¤® à¤µà¤¿à¤œà¥‡à¤¤à¤¾: {winner}',
                rank_updated: 'ğŸ–ï¸ {rank} - à¤¸à¥à¤¤à¤° {level}',
                ten_seconds_left: 'â° 10 à¤¸à¥‡à¤•à¤‚à¤¡ à¤¬à¤šà¥‡!',
                five_seconds_left: 'âš ï¸ 5 à¤¸à¥‡à¤•à¤‚à¤¡ à¤¬à¤šà¥‡! à¤œà¤²à¥à¤¦à¥€!',
                auto_discarding: 'ğŸš¨ à¤¸à¥à¤µà¤šà¤¾à¤²à¤¿à¤¤ à¤Ÿà¤¾à¤‡à¤² à¤«à¥‡à¤‚à¤•à¥€ à¤œà¤¾ à¤°à¤¹à¥€ à¤¹à¥ˆ!',
                new_round_preparing: 'à¤¨à¤¯à¤¾ à¤°à¤¾à¤‰à¤‚à¤¡ à¤¤à¥ˆà¤¯à¤¾à¤° à¤¹à¥‹ à¤°à¤¹à¤¾ à¤¹à¥ˆ...',
                leave_confirm: 'à¤•à¥à¤¯à¤¾ à¤†à¤ª à¤¬à¤¾à¤¹à¤° à¤œà¤¾à¤¨à¤¾ à¤šà¤¾à¤¹à¤¤à¥‡ à¤¹à¥ˆà¤‚?',
                deck_count: 'ğŸ“š {count}',
                deck_empty: 'âŒ à¤–à¤¾à¤²à¥€',
                last_tile_discarded_checking: 'à¤†à¤–à¤¿à¤°à¥€ à¤Ÿà¤¾à¤‡à¤² à¤«à¥‡à¤‚à¤•à¥€ à¤—à¤ˆ! à¤œà¤¾à¤‚à¤š à¤¹à¥‹ à¤°à¤¹à¥€ à¤¹à¥ˆ...',
                last_tile_discarded: 'à¤†à¤–à¤¿à¤°à¥€ à¤Ÿà¤¾à¤‡à¤² à¤«à¥‡à¤‚à¤•à¥€ à¤—à¤ˆ!'
            },
            ru: {
                app_title: 'ĞĞºĞµĞ¹',
                header_title: 'OKEY 51',
                loading_rooms: 'Ğ Ğ°Ğ·Ğ´Ğ°ĞµĞ¼ ĞºĞ¾ÑÑ‚Ğ¸...',
                bet_select: 'Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ÑÑ‚Ğ°Ğ²ĞºÑƒ',
                room_label: 'ĞšĞ¾Ğ¼Ğ½Ğ°Ñ‚Ğ°',
                pot_label: 'Ğ‘Ğ°Ğ½Ğº: {amount}â‚¼',
                you: 'Ğ’Ñ‹',
                leave: 'Ğ’Ñ‹Ğ¹Ñ‚Ğ¸',
                waiting: 'ĞĞ¶Ğ¸Ğ´Ğ°Ğ½Ğ¸Ğµ',
                win_combo_title: 'ğŸ† ĞŸĞĞ‘Ğ•Ğ”ĞĞĞ¯ ĞšĞĞœĞ‘Ğ˜ĞĞĞ¦Ğ˜Ğ¯',
                token_not_found: 'Ğ¢Ğ¾ĞºĞµĞ½ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½!',
                connection_success: 'ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾!',
                connection_error: 'ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ',
                connection_error_with: 'ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ: {message}',
                joined_room: 'Ğ’Ñ‹ Ğ²Ğ¾ÑˆĞ»Ğ¸ Ğ² ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ñƒ',
                your_turn_draw: 'Ğ’Ğ°Ñˆ Ñ…Ğ¾Ğ´! Ğ’ĞĞ—Ğ¬ĞœĞ˜Ğ¢Ğ• Ğ¤Ğ˜Ğ¨ĞšĞ£!',
                tile_drawn_discard: 'Ğ’Ñ‹ Ğ²Ğ·ÑĞ»Ğ¸ Ñ„Ğ¸ÑˆĞºÑƒ, Ñ‚ĞµĞ¿ĞµÑ€ÑŒ Ğ¡Ğ‘Ğ ĞĞ¡Ğ¬Ğ¢Ğ•!',
                player_timeout_auto_discard: '{player} Ğ½Ğµ ÑƒÑĞ¿ĞµĞ» - Ñ„Ğ¸ÑˆĞºĞ° ÑĞ±Ñ€Ğ¾ÑˆĞµĞ½Ğ° Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸',
                player_joined: '{player} Ğ²Ğ¾ÑˆĞµĞ»',
                player_left: '{player} Ğ²Ñ‹ÑˆĞµĞ»',
                player_drew: '{player} Ğ²Ğ·ÑĞ» Ñ„Ğ¸ÑˆĞºÑƒ',
                auto_action: 'ĞĞ²Ñ‚Ğ¾Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ',
                draw_turn_wait: 'Ğ–Ğ´Ğ¸Ñ‚Ğµ ÑĞ²Ğ¾Ğ¹ Ñ…Ğ¾Ğ´',
                discard_now: 'Ğ¡Ğ‘Ğ ĞĞ¡Ğ¬Ğ¢Ğ• Ğ¡Ğ•Ğ™Ğ§ĞĞ¡!',
                discard_first: 'Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° ÑĞ±Ñ€Ğ¾ÑÑŒÑ‚Ğµ!',
                already_drew: 'Ğ’Ñ‹ ÑƒĞ¶Ğµ Ğ²Ğ·ÑĞ»Ğ¸ Ñ„Ğ¸ÑˆĞºÑƒ!',
                not_your_turn: 'Ğ¡ĞµĞ¹Ñ‡Ğ°Ñ Ğ½Ğµ Ğ²Ğ°Ñˆ Ñ…Ğ¾Ğ´!',
                opponent_not_discarded: 'Ğ¡Ğ¾Ğ¿ĞµÑ€Ğ½Ğ¸Ğº ĞµÑ‰Ğµ Ğ½Ğµ ÑĞ±Ñ€Ğ¾ÑĞ¸Ğ»',
                draw_failed: 'ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ²Ğ·ÑÑ‚ÑŒ Ñ„Ğ¸ÑˆĞºÑƒ',
                draw_first: 'Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ğ²Ğ¾Ğ·ÑŒĞ¼Ğ¸Ñ‚Ğµ Ñ„Ğ¸ÑˆĞºÑƒ!',
                error_occurred: 'ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°',
                room_list_empty: 'ĞšĞ¾Ğ¼Ğ½Ğ°Ñ‚Ñ‹ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ñ‹',
                players_label: 'Ğ˜Ğ³Ñ€Ğ¾ĞºĞ¾Ğ²',
                no_rooms: 'ĞšĞ¾Ğ¼Ğ½Ğ°Ñ‚ Ğ½ĞµÑ‚',
                player_count_game: 'Ğ˜Ğ³Ñ€Ğ° Ğ½Ğ° {count} Ğ¸Ğ³Ñ€Ğ¾ĞºĞ¾Ğ²',
                no_rooms_for_count: 'ĞĞµÑ‚ ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚ Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ° Ğ¸Ğ³Ñ€Ğ¾ĞºĞ¾Ğ²',
                joining: 'Ğ’Ñ…Ğ¾Ğ´Ğ¸Ğ¼...',
                join_failed: 'ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ²Ğ¾Ğ¹Ñ‚Ğ¸',
                sort_done: 'ĞÑ‚ÑĞ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾',
                you_start: 'Ğ’Ñ‹ Ğ½Ğ°Ñ‡Ğ¸Ğ½Ğ°ĞµÑ‚Ğµ! Ğ¡Ğ‘Ğ ĞĞ¡Ğ¬Ğ¢Ğ•! ğŸ®',
                game_started: 'Ğ˜Ğ³Ñ€Ğ° Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ°ÑÑŒ! ğŸ®',
                winner_announcement: 'ğŸ‰ {winner} Ğ¿Ğ¾Ğ±ĞµĞ´Ğ¸Ğ»!',
                group_label: 'Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ° {index}:',
                finish_type: 'ğŸ–ï¸ Ğ¢Ğ¸Ğ¿ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ: <strong>{type}</strong>',
                final_winner: 'ğŸ† Ğ¤Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ±ĞµĞ´Ğ¸Ñ‚ĞµĞ»ÑŒ: {winner}',
                rank_updated: 'ğŸ–ï¸ {rank} - Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ {level}',
                ten_seconds_left: 'â° ĞÑÑ‚Ğ°Ğ»Ğ¾ÑÑŒ 10 ÑĞµĞºÑƒĞ½Ğ´!',
                five_seconds_left: 'âš ï¸ ĞÑÑ‚Ğ°Ğ»Ğ¾ÑÑŒ 5 ÑĞµĞºÑƒĞ½Ğ´! Ğ‘Ñ‹ÑÑ‚Ñ€ĞµĞµ!',
                auto_discarding: 'ğŸš¨ ĞĞ’Ğ¢ĞĞ¡Ğ‘Ğ ĞĞ¡!',
                new_round_preparing: 'Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¸Ñ‚ÑÑ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ñ€Ğ°ÑƒĞ½Ğ´...',
                leave_confirm: 'Ğ’Ñ‹Ğ¹Ñ‚Ğ¸ Ğ¸Ğ· Ğ¸Ğ³Ñ€Ñ‹?',
                deck_count: 'ğŸ“š {count}',
                deck_empty: 'âŒ ĞŸĞ£Ğ¡Ğ¢Ğ',
                last_tile_discarded_checking: 'ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½ÑÑ Ñ„Ğ¸ÑˆĞºĞ° ÑĞ±Ñ€Ğ¾ÑˆĞµĞ½Ğ°! ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°...',
                last_tile_discarded: 'ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½ÑÑ Ñ„Ğ¸ÑˆĞºĞ° ÑĞ±Ñ€Ğ¾ÑˆĞµĞ½Ğ°!'
            },
            ar: {
                app_title: 'Ø£ÙˆÙƒÙŠ',
                header_title: 'OKEY 51',
                loading_rooms: 'ÙŠØªÙ… ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù‚Ø·Ø¹...',
                bet_select: 'Ø§Ø®ØªØ± Ø§Ù„Ø±Ù‡Ø§Ù†',
                room_label: 'ØºØ±ÙØ©',
                pot_label: 'Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹: {amount}â‚¼',
                you: 'Ø£Ù†Øª',
                leave: 'Ø®Ø±ÙˆØ¬',
                waiting: 'Ø¨Ø§Ù†ØªØ¸Ø§Ø±',
                win_combo_title: 'ğŸ† Ø§Ù„ØªØ±ÙƒÙŠØ¨Ø© Ø§Ù„ÙØ§Ø¦Ø²Ø©',
                token_not_found: 'Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø±Ù…Ø²!',
                connection_success: 'ØªÙ… Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù†Ø¬Ø§Ø­!',
                connection_error: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„',
                connection_error_with: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„: {message}',
                joined_room: 'Ø§Ù†Ø¶Ù…Ù…Øª Ø¥Ù„Ù‰ Ø§Ù„ØºØ±ÙØ©',
                your_turn_draw: 'Ø¯ÙˆØ±Ùƒ! Ø§Ø³Ø­Ø¨ Ø­Ø¬Ø±Ù‹Ø§!',
                tile_drawn_discard: 'Ø³Ø­Ø¨Øª Ø­Ø¬Ø±Ù‹Ø§ØŒ Ø§Ù„Ø¢Ù† Ø§Ø±Ù…Ù!',
                player_timeout_auto_discard: 'Ø§Ù†ØªÙ‡Ù‰ ÙˆÙ‚Øª {player} - ØªÙ… Ø§Ù„Ø±Ù…ÙŠ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§',
                player_joined: 'Ø§Ù†Ø¶Ù… {player}',
                player_left: 'ØºØ§Ø¯Ø± {player}',
                player_drew: 'Ø³Ø­Ø¨ {player} Ø­Ø¬Ø±Ù‹Ø§',
                auto_action: 'Ø¥Ø¬Ø±Ø§Ø¡ ØªÙ„Ù‚Ø§Ø¦ÙŠ',
                draw_turn_wait: 'Ø§Ù†ØªØ¸Ø± Ø¯ÙˆØ±Ùƒ',
                discard_now: 'Ø§Ø±Ù…Ù Ø§Ù„Ø¢Ù†!',
                discard_first: 'Ø§Ø±Ù…Ù Ø£ÙˆÙ„Ù‹Ø§!',
                already_drew: 'Ù„Ù‚Ø¯ Ø³Ø­Ø¨Øª Ø­Ø¬Ø±Ù‹Ø§ Ø¨Ø§Ù„ÙØ¹Ù„!',
                not_your_turn: 'Ù„ÙŠØ³ Ø¯ÙˆØ±Ùƒ!',
                opponent_not_discarded: 'Ø§Ù„Ø®ØµÙ… Ù„Ù… ÙŠØ±Ù…Ù Ø¨Ø¹Ø¯',
                draw_failed: 'ØªØ¹Ø°Ø± Ø³Ø­Ø¨ Ø§Ù„Ø­Ø¬Ø±',
                draw_first: 'Ø§Ø³Ø­Ø¨ Ø­Ø¬Ø±Ù‹Ø§ Ø£ÙˆÙ„Ù‹Ø§!',
                error_occurred: 'Ø­Ø¯Ø« Ø®Ø·Ø£',
                room_list_empty: 'Ù„Ø§ ØªÙˆØ¬Ø¯ ØºØ±Ù',
                players_label: 'Ù„Ø§Ø¹Ø¨ÙŠÙ†',
                no_rooms: 'Ù„Ø§ ØªÙˆØ¬Ø¯ ØºØ±Ù',
                player_count_game: 'Ù„Ø¹Ø¨Ø© {count} Ù„Ø§Ø¹Ø¨ÙŠÙ†',
                no_rooms_for_count: 'Ù„Ø§ ØªÙˆØ¬Ø¯ ØºØ±Ù Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ù‡Ø°Ø§',
                joining: 'Ø¬Ø§Ø±Ù Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù…...',
                join_failed: 'ÙØ´Ù„ Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù…',
                sort_done: 'ØªÙ… Ø§Ù„ÙØ±Ø²',
                you_start: 'Ø£Ù†Øª ØªØ¨Ø¯Ø£! Ø§Ø±Ù…Ù! ğŸ®',
                game_started: 'Ø¨Ø¯Ø£Øª Ø§Ù„Ù„Ø¹Ø¨Ø©! ğŸ®',
                winner_announcement: 'ğŸ‰ {winner} ÙØ§Ø²!',
                group_label: 'Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© {index}:',
                finish_type: 'ğŸ–ï¸ Ù†ÙˆØ¹ Ø§Ù„Ø¥Ù†Ù‡Ø§Ø¡: <strong>{type}</strong>',
                final_winner: 'ğŸ† Ø§Ù„ÙØ§Ø¦Ø² Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ: {winner}',
                rank_updated: 'ğŸ–ï¸ {rank} - Ø§Ù„Ù…Ø³ØªÙˆÙ‰ {level}',
                ten_seconds_left: 'â° ØªØ¨Ù‚Ù‰ 10 Ø«ÙˆØ§Ù†Ù!',
                five_seconds_left: 'âš ï¸ ØªØ¨Ù‚Ù‰ 5 Ø«ÙˆØ§Ù†Ù! Ø£Ø³Ø±Ø¹!',
                auto_discarding: 'ğŸš¨ Ø±Ù…ÙŠ ØªÙ„Ù‚Ø§Ø¦ÙŠ!',
                new_round_preparing: 'ÙŠØªÙ… ØªØ¬Ù‡ÙŠØ² Ø¬ÙˆÙ„Ø© Ø¬Ø¯ÙŠØ¯Ø©...',
                leave_confirm: 'Ù‡Ù„ ØªØ±ÙŠØ¯ Ø§Ù„Ø®Ø±ÙˆØ¬ØŸ',
                deck_count: 'ğŸ“š {count}',
                deck_empty: 'âŒ ÙØ§Ø±Øº',
                last_tile_discarded_checking: 'ØªÙ… Ø±Ù…ÙŠ Ø¢Ø®Ø± Ø­Ø¬Ø±! Ø¬Ø§Ø±Ù Ø§Ù„ØªØ­Ù‚Ù‚...',
                last_tile_discarded: 'ØªÙ… Ø±Ù…ÙŠ Ø¢Ø®Ø± Ø­Ø¬Ø±!'
            },
            uz: {
                app_title: 'Okey',
                header_title: 'OKEY 51',
                loading_rooms: 'Toshlar tarqatilmoqda...',
                bet_select: 'Tikishni tanlang',
                room_label: 'Xona',
                pot_label: 'Pot: {amount}â‚¼',
                you: 'Siz',
                leave: 'Chiqish',
                waiting: 'Kutilmoqda',
                win_combo_title: 'ğŸ† Gâ€˜OLIB KOMBINATSIYA',
                token_not_found: 'Token topilmadi!',
                connection_success: 'Ulanish muvaffaqiyatli!',
                connection_error: 'Ulanish xatosi',
                connection_error_with: 'Ulanish xatosi: {message}',
                joined_room: 'Xonaga kirdingiz',
                your_turn_draw: 'Sizning navbatingiz! TOSH OLING!',
                tile_drawn_discard: 'Tosh oldingiz, endi TASHLANG!',
                player_timeout_auto_discard: '{player} vaqti tugadi - tosh avtomatik tashlandi',
                player_joined: '{player} qoâ€˜shildi',
                player_left: '{player} chiqdi',
                player_drew: '{player} tosh oldi',
                auto_action: 'Avto harakat',
                draw_turn_wait: 'Navbatingizni kuting',
                discard_now: 'HOZIR TASHLANG!',
                discard_first: 'Avval tashlang!',
                already_drew: 'Siz allaqachon tosh oldingiz!',
                not_your_turn: 'Navbat sizniki emas!',
                opponent_not_discarded: 'Raqib hali tosh tashlamadi',
                draw_failed: 'Toshni olishning iloji boâ€˜lmadi',
                draw_first: 'Avval tosh oling!',
                error_occurred: 'Xatolik yuz berdi',
                room_list_empty: 'Xonalar topilmadi',
                players_label: 'Kishilik',
                no_rooms: 'Xona yoâ€˜q',
                player_count_game: '{count} kishilik oâ€˜yin',
                no_rooms_for_count: 'Bu oâ€˜yinchi soni uchun xona yoâ€˜q',
                joining: 'Kirilmoqda...',
                join_failed: 'Kirish amalga oshmadi',
                sort_done: 'Saralandi',
                you_start: 'Oâ€˜yinni siz boshlaysiz! TASHLANG! ğŸ®',
                game_started: 'Oâ€˜yin boshlandi! ğŸ®',
                winner_announcement: 'ğŸ‰ {winner} yutdi!',
                group_label: 'Guruh {index}:',
                finish_type: 'ğŸ–ï¸ Yakun turi: <strong>{type}</strong>',
                final_winner: 'ğŸ† Yakuniy gâ€˜olib: {winner}',
                rank_updated: 'ğŸ–ï¸ {rank} - Daraja {level}',
                ten_seconds_left: 'â° 10 soniya qoldi!',
                five_seconds_left: 'âš ï¸ 5 soniya qoldi! Tezroq!',
                auto_discarding: 'ğŸš¨ AVTO TASHLASH!',
                new_round_preparing: 'Yangi raund tayyorlanmoqda...',
                leave_confirm: 'Chiqishni xohlaysizmi?',
                deck_count: 'ğŸ“š {count}',
                deck_empty: 'âŒ BOâ€˜SH',
                last_tile_discarded_checking: 'Oxirgi tosh tashlandi! Tekshirilmoqda...',
                last_tile_discarded: 'Oxirgi tosh tashlandi!'
            }
        };

        const languageAliases = {
            en: 'en',
            eng: 'en',
            english: 'en',
            tr: 'tr',
            turkish: 'tr',
            tÃ¼rkÃ§e: 'tr',
            turkce: 'tr',
            hi: 'hi',
            hindi: 'hi',
            indian: 'hi',
            ru: 'ru',
            russian: 'ru',
            ar: 'ar',
            arabic: 'ar',
            uz: 'uz',
            uzbek: 'uz'
        };

        let currentLanguage = 'en';
        let currentPotAmount = 0;
        let currentStockCount = null;
        let pendingApply = false;

        function normalizeLanguage(lang) {
            if (!lang) return 'en';
            const key = String(lang).trim().toLowerCase();
            return languageAliases[key] || key;
        }

        function t(key, vars = {}) {
            const base = translations[currentLanguage] || translations.en;
            const fallback = translations.en;
            let text = base[key] || fallback[key] || key;
            Object.keys(vars).forEach((k) => {
                text = text.replace(new RegExp(`\\{${k}\\}`, 'g'), vars[k]);
            });
            return text;
        }

        function applyTranslations() {
            if (document.readyState === 'loading') {
                if (!pendingApply) {
                    pendingApply = true;
                    document.addEventListener('DOMContentLoaded', () => {
                        pendingApply = false;
                        applyTranslations();
                    }, { once: true });
                }
                return;
            }

            document.title = t('app_title');
            document.querySelectorAll('[data-i18n]').forEach((el) => {
                const key = el.getAttribute('data-i18n');
                if (!key) return;
                el.textContent = t(key);
            });

            const placeholderValues = {
                waiting: new Set(Object.values(translations).map((l) => l.waiting)),
                you: new Set(Object.values(translations).map((l) => l.you)),
                room_label: new Set(Object.values(translations).map((l) => l.room_label))
            };

            document.querySelectorAll('[data-i18n-placeholder]').forEach((el) => {
                const key = el.getAttribute('data-i18n-placeholder');
                if (!key) return;
                const current = (el.textContent || '').trim();
                if (!current || placeholderValues[key]?.has(current)) {
                    el.textContent = t(key);
                }
            });

            updatePotAmount(currentPotAmount);
            if (currentStockCount !== null && currentStockCount !== undefined) {
                updateStockCount(currentStockCount);
            }
        }

        function setLanguage(lang) {
            const normalized = normalizeLanguage(lang);
            currentLanguage = translations[normalized] ? normalized : 'en';
            document.documentElement.lang = currentLanguage;
            document.documentElement.dir = currentLanguage === 'ar' ? 'rtl' : 'ltr';
            applyTranslations();
        }

        // âœ… Bu yeni funksiyanÄ± ÆLAVÆ ET (getToken yerinÉ™):
        function waitForUserData() {
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('User data timeout'));
                }, 10000); // 10 saniyÉ™ gÃ¶zlÉ™

                const checkData = () => {
                    if (IFRAME_TOKEN && IFRAME_USER) {
                        clearTimeout(timeout);
                        clearInterval(interval);
                        resolve();
                    }
                };

                const interval = setInterval(checkData, 100);
                checkData(); // Ä°lk yoxlama
            });
        }

        // âœ… postMessage dinlÉ™yicisini ÆLAVÆ ET (DOMContentLoaded-dÉ™n ÆVVÆL):
        window.addEventListener('message', (event) => {
            // ğŸ”’ TÉ™hlÃ¼kÉ™sizlik: yalnÄ±z eyni origin-dÉ™n qÉ™bul et
            if (event.origin !== window.location.origin) {
                console.warn('âš ï¸ Rejected message from:', event.origin);
                return;
            }

            const { type, payload, language } = event.data || {};

            if (language || payload?.language) {
                setLanguage(language || payload.language);
            }

            if (type === 'INIT_USER') {
                log('ğŸ“¥ React-dan user data alÄ±ndÄ±:', payload);

                IFRAME_TOKEN = payload.token;
                IFRAME_USER = {
                    id: payload.userId,
                    username: payload.username,
                    fullName: payload.fullName,
                    balance: payload.balance
                };

                // UI-Ä± yenilÉ™
                if (document.getElementById('userName')) {
                    document.getElementById('userName').textContent = payload.username;
                }
                if (document.getElementById('userBalance')) {
                    document.getElementById('userBalance').textContent = `${payload.balance}â‚¼`;
                }
                if (document.getElementById('myPlayerName')) {
                    document.getElementById('myPlayerName').textContent = payload.username;
                }

                log('âœ… User data saxlanÄ±ldÄ± vÉ™ UI yenilÉ™ndi');
            }
        });


        // -----
        const CONFIG = { HUB_URL: 'https://nehemiah-paginal-alan.ngrok-free.dev/okeyHub', DEBUG: true };
        let connection, currentUser, currentRoomId, myHand = [], myPosition = 0;
        let hasDrawn = false, isMyTurn = false, mustDiscard = false;
        let draggedTile = null, draggedFromIndex = null;
        let maxPlayers = 4;
        let currentTurnTimer = null;
        let turnTimeRemaining = 0;
        // TILE POSITIONS 
        let tilePositions = {}; // âœ… Tile ID â†’ {x, y} cache


        function log(...args) { if (CONFIG.DEBUG) console.log('ğŸ®', ...args); }

        function updatePotAmount(amount) {
            currentPotAmount = amount ?? 0;
            const el = document.getElementById('potAmountDisplay');
            if (el) el.textContent = t('pot_label', { amount: currentPotAmount });
        }

        function updateStockCount(count) {
            currentStockCount = count;
            const label = document.getElementById('deckCountLabel');
            if (!label) return;

            if (count <= 10 && count > 0) {
                label.style.color = '#f39c12';
            } else if (count === 0) {
                label.style.color = '#e74c3c';
            } else {
                label.style.color = 'white';
            }

            if (count === 0) {
                label.textContent = t('deck_empty');
            } else {
                label.textContent = t('deck_count', { count });
            }
        }


        function showNotification(message, type = 'info') {
            const notif = document.createElement('div');
            notif.className = 'notification';
            notif.textContent = message;
            document.body.appendChild(notif);
            setTimeout(() => notif.remove(), 3000);
        }


        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(id)?.classList.add('active');
        }

        // function getToken() {
        //     const raw = document.cookie.split("; ").find(r => r.startsWith("AuthToken="))?.split("=")[1];
        //     return raw ? decodeURIComponent(raw).trim() : "";
        // }

        // async function initializeSignalR() {
        //     const token = getToken();
        //     if (!token) {
        //         showNotification('Token tapÄ±lmadÄ±!', 'error');
        //         setTimeout(() => window.location.href = '/frontend/index.html', 3000);
        //         return;
        //     }

        //     try {
        //         connection = new signalR.HubConnectionBuilder()
        //             .withUrl(CONFIG.HUB_URL, {
        //                 accessTokenFactory: () => token,
        //                 transport: signalR.HttpTransportType.WebSockets | signalR.HttpTransportType.LongPolling
        //             })
        //             .withAutomaticReconnect()
        //             .configureLogging(signalR.LogLevel.Information)
        //             .build();

        //         setupSignalREvents();
        //         await connection.start();
        //         log('âœ… Connected');
        //         showNotification('BaÄŸlantÄ± uÄŸurlu!', 'success');
        //         setTimeout(() => loadRooms(), 500);
        //     } catch (err) {
        //         log('âŒ Error:', err);
        //         showNotification('BaÄŸlantÄ± xÉ™tasÄ±', 'error');
        //     }
        // }

        async function initializeSignalR() {
            try {
                // React-dan data gÃ¶zlÉ™
                log('â³ React-dan user data gÃ¶zlÉ™nilir...');
                await waitForUserData();

                const token = IFRAME_TOKEN;

                if (!token) {
                    showNotification(t('token_not_found'), 'error');
                    return;
                }

                log('ğŸ”‘ Token alÄ±ndÄ±, SignalR baÄŸlanÄ±r...');

                connection = new signalR.HubConnectionBuilder()
                    .withUrl(CONFIG.HUB_URL, {
                        accessTokenFactory: () => token,
                        transport: signalR.HttpTransportType.WebSockets | signalR.HttpTransportType.LongPolling
                    })
                    .withAutomaticReconnect()
                    .configureLogging(signalR.LogLevel.Information)
                    .build();

                setupSignalREvents();
                await connection.start();
                log('âœ… Connected');
                showNotification(t('connection_success'), 'success');
                setTimeout(() => loadRooms(), 500);
            } catch (err) {
                log('âŒ Error:', err);
                showNotification(t('connection_error_with', { message: err.message }), 'error');
            }
        }

        function setupSignalREvents() {

            connection.on("UserData", (d) => {
                // SignalR-dan gÉ™lÉ™n data ilÉ™ yenilÉ™ (React data ilÉ™ birlÉ™ÅŸdir)
                currentUser = {
                    ...IFRAME_USER,
                    ...d
                };

                document.getElementById('userName').textContent = d.username || IFRAME_USER.username;
                document.getElementById('userBalance').textContent = `${d.balance}`;
                document.getElementById('userRank').textContent = d.rank;
                document.getElementById('myPlayerName').textContent = d.username || IFRAME_USER.username;
            });
            connection.on("BalanceUpdated", (balance) => {
                document.getElementById('userBalance').textContent = `${balance}`;
            });

            connection.on("RoomCreated", () => loadRooms());
            connection.on("RoomDeleted", () => loadRooms());


            // âœ… PlayerTimeout eventi
            // connection.on("PlayerTimeout", (data) => {
            //     log('â° Player timeout:', data);
            //     showNotification(data.message || 'OyunÃ§u vaxt bitirdi', 'warning');
            //     clearAllTimers();
            // });


            connection.on("PlayerTimeout", (data) => {
                log('â° TIMEOUT:', data);

                const { playerName, discardedTile, message } = data;

                showNotification(t('player_timeout_auto_discard', { player: playerName }), 'success');

                // ğŸ¯ 2. Avtomatik daÅŸ atma animasiyasÄ±
                if (discardedTile) {
                    showAutoDiscardAnimation(playerName, discardedTile);
                }

                // ğŸ¯ 3. EkrandakÄ± oyunÃ§unun infosunu yenilÉ™
                updatePlayerUIAfterTimeout(playerName);
            });




            // âœ… TurnTimerStarted eventi
            connection.on("TurnTimerStarted", (data) => {
                console.log('â±ï¸ Timer started:', data);
                showTimer(data.username, data.seconds);
            });

            connection.on("JoinedRoom", (d) => {
                currentRoomId = d.roomId;
                myPosition = d.position;
                maxPlayers = d.maxPlayers || 4;
                document.getElementById('roomNameDisplay').textContent = d.roomName;

                adjustTableLayout(maxPlayers);


                if (d.hand && d.hand.length > 0) {
                    myHand = d.hand;
                    renderMyTiles();
                    autoArrangeTiles();
                }
                showScreen('gameScreen');
                showNotification(t('joined_room'), 'success');
            });
            connection.on("TurnTimerUpdate", (data) => {
                console.log('â±ï¸ Timer update:', data);
                showTimer(data.username, data.seconds);
            });

            connection.on("TurnTimerStopped", () => {
                console.log('â¹ï¸ Timer stopped');
                clearTimers();
            });

            // âœ… PlayerAction event-i (avtomatik daÅŸ atma bildiriÅŸi)
            connection.on("PlayerAction", (data) => {
                if (data.action === "AutoDiscard") {
                    showNotification(data.message, 'info');
                    log('â° AUTO ACTION:', data);
                }
            });

            // âœ… YourTurn event-dÉ™ timer-i tÉ™mizlÉ™
            const originalYourTurnHandler = connection.on("YourTurn", () => {
                isMyTurn = true;
                hasDrawn = false;
                mustDiscard = false;
                clearAllTimers();
                updateTurnUI();
                showNotification(t('your_turn_draw'), 'info');
            });

            connection.on("TileDrawn", (d) => {
                myHand = d.hand;
                hasDrawn = true;
                mustDiscard = true;
                renderMyTiles();
                updateTurnUI();

                // âœ… Vizual olaraq dÉ™stÉ™dÉ™n daÅŸ Ã§É™kilmÉ™sini gÃ¶stÉ™r
                const deckStack = document.getElementById('deckStack');
                if (deckStack) {
                    deckStack.style.transform = 'scale(1.1)';
                    setTimeout(() => {
                        deckStack.style.transform = '';
                    }, 200);
                }

                showNotification(t('tile_drawn_discard'), 'success');
            });

            // âœ… TileDiscarded event-dÉ™ timer tÉ™mizlÉ™
            connection.on("TileDiscarded", (d) => {
                myHand = d.hand;
                hasDrawn = false;
                isMyTurn = false;
                mustDiscard = false;
                clearAllTimers();
                renderMyTiles();
                updateTurnUI();
            });


            // âœ… PlayerDiscardedTile - vizual animasiya
            connection.on("PlayerDiscardedTile", (d) => {
                if (d.tile && d.playerPosition !== undefined) {
                    displayDiscardedTile(d.tile, d.playerPosition);

                    // âœ… Animasiya
                    const relativePos = getRelativePosition(myPosition, d.playerPosition);
                    let zoneId = '';

                    if (relativePos === 'bottom') zoneId = 'myDiscardZone';
                    else if (relativePos === 'top') zoneId = 'discardZoneTop';
                    else if (relativePos === 'left') zoneId = 'discardZoneLeft';
                    else if (relativePos === 'right') zoneId = 'discardZoneRight';

                    const zone = document.getElementById(zoneId);
                    if (zone) {
                        // Atma animasiyasÄ±
                        zone.style.transform = 'scale(1.15)';
                        zone.style.boxShadow = '0 0 30px rgba(231, 76, 60, 0.8)';

                        setTimeout(() => {
                            zone.style.transform = '';
                            zone.style.boxShadow = '';
                        }, 300);
                    }
                }
            });

            // âœ… GameReset event-dÉ™ timer tÉ™mizlÉ™
            connection.on("GameReset", () => {
                console.log('ğŸ”„ Game Reset - tÉ™mizlÉ™mÉ™ baÅŸlayÄ±r...');

                // âœ… Oyun vÉ™ziyyÉ™tini sÄ±fÄ±rla
                myHand = [];
                hasDrawn = false;
                mustDiscard = false;
                isMyTurn = false;

                tilePositions = {};

                // âœ… Timer-lÉ™ri tÉ™mizlÉ™
                clearAllTimers();

                // âœ… LÃ¶vhÉ™ni tÉ™mizlÉ™
                const row1 = document.getElementById('myRow1');
                const row2 = document.getElementById('myRow2');
                if (row1) row1.innerHTML = '';
                if (row2) row2.innerHTML = '';

                // âœ… BÃ¼tÃ¼n discard zona-larÄ± tÉ™mizlÉ™
                clearAllDiscardZones();

                // âœ… GÃ¶stÉ™rici vÉ™ joker-i tÉ™mizlÉ™
                const indicatorEl = document.getElementById('indicatorTile');
                const jokerEl = document.getElementById('jokerTile');
                if (indicatorEl) indicatorEl.innerHTML = '';
                if (jokerEl) jokerEl.innerHTML = '';

                // âœ… DÉ™stÉ™ sayÄ±nÄ± sÄ±fÄ±rla
                updateStockCount(106);

                // âœ… Modal-Ä± baÄŸla
                document.getElementById('winModal')?.classList.remove('show');

                // âœ… BildiriÅŸ
                showNotification(t('new_round_preparing'), 'info');

                console.log('âœ… TÉ™mizlÉ™mÉ™ tamamlandÄ±');
            });

            // âœ… DÉ™stÉ™ vizual yenilÉ™mÉ™
            connection.on("GameStateUpdated", (state) => {
                if (state.stockCount !== undefined) {
                    updateStockCount(state.stockCount);
                }

                if (state.potAmount !== undefined) {
                    updatePotAmount(state.potAmount);
                }

                if (state.players) {
                    updatePlayersDisplay(state.players);
                }
            });

            connection.on("JoinError", (msg) => showNotification(msg, 'error'));
            connection.on("PlayerJoined", (d) => showNotification(t('player_joined', { player: d.playerName }), 'info'));
            connection.on("PlayerLeft", (d) => showNotification(t('player_left', { player: d.playerName }), 'info'));
            connection.on("PlayersList", (players) => updatePlayersDisplay(players));

            connection.on("GameStarted", (d) => {
                log('GameStarted:', d);
                myHand = d.hand || [];

                adjustTableLayout(maxPlayers);

                tilePositions = {};
                if (myHand.length > 0) {
                    autoArrangeTiles();
                }


                if (myHand.length === 15) {
                    hasDrawn = true;
                    mustDiscard = true;
                    isMyTurn = true;
                    showNotification(t('you_start'), 'success');
                } else {
                    hasDrawn = false;
                    mustDiscard = false;
                    isMyTurn = d.isYourTurn || false;
                }

                renderMyTiles();
                if (d.indicator) setIndicatorTile(d.indicator);
                if (d.joker) setJokerTile(d.joker);

                // document.getElementById('gameModeDisplay').textContent = `Mod: ${d.gameMode}`;
                document.getElementById('myScore').textContent = d.initialScore;
                updateTurnUI();

                const playerPositions = getPlayerNames();
                console.log(playerPositions);

                if (!mustDiscard) showNotification(t('game_started'), 'success');
            });

            connection.on("GameStateUpdated", (state) => {
                if (state.stockCount !== undefined)
                    updateStockCount(state.stockCount);
                if (state.potAmount !== undefined)
                    updatePotAmount(state.potAmount);
                if (state.players) updatePlayersDisplay(state.players);
            });


            connection.on("TileDrawn", (d) => {
                myHand = d.hand;
                hasDrawn = true;
                mustDiscard = true;
                renderMyTiles();
                updateTurnUI();
                showNotification(t('tile_drawn_discard'), 'success');
            });

            connection.on("PlayerDrew", (d) => showNotification(t('player_drew', { player: d.playerName }), 'info'));



            connection.on("PlayerDiscardedTile", (d) => {
                if (d.tile && d.playerPosition !== undefined)
                    displayDiscardedTile(d.tile, d.playerPosition);
            });

            connection.on("ActionError", (msg) => showNotification(msg, 'error'));

            // connection.on("RoundOver", (d) => showNotification(`ğŸ‰ ${d.winner} qazandÄ±!`, 'success'));
            connection.on("RoundOver", (d) => {
                console.log('ğŸ‰ RoundOver:', d);

                showNotification(t('winner_announcement', { winner: d.winner }), 'success');

                // âœ… KombinasiyalarÄ± masanÄ±n ortasÄ±nda modal ilÉ™ gÃ¶stÉ™r
                const modal = document.getElementById('winModal');
                const container = document.getElementById('winMeldsContainer');

                if (modal && container && d.melds && d.melds.length > 0) {
                    container.innerHTML = '';

                    d.melds.forEach((meld, idx) => {
                        const meldDiv = document.createElement('div');
                        meldDiv.className = 'win-meld-group';
                        meldDiv.innerHTML = `<strong style="color: #f39c12; min-width: 80px;">${t('group_label', { index: idx + 1 })}</strong>`;

                        meld.forEach(tile => {
                            meldDiv.innerHTML += createTileHTML(tile, 0);
                        });

                        container.appendChild(meldDiv);
                    });

                    const winTypeEl = document.createElement('p');
                    winTypeEl.style.cssText = 'margin-top: 25px; font-size: 20px; text-align: center; color: #f39c12; font-weight: 800;';
                    winTypeEl.innerHTML = t('finish_type', { type: d.winType });
                    container.appendChild(winTypeEl);

                    modal.classList.add('show');

                    setTimeout(() => modal.classList.remove('show'), 10000);
                }
            });

            connection.on("GameOver", (d) => {
                if (d.reason) {
                    showNotification(d.reason, 'error');
                } else {
                    showNotification(t('final_winner', { winner: d.finalWinner }), 'success');
                }

                // âœ… Final xallarÄ± gÃ¶stÉ™r
                if (d.finalScores && d.finalScores.length > 0) {
                    console.log('ğŸ“Š Final Scores:', d.finalScores);
                }

                // âœ… 5 saniyÉ™ sonra otaq siyahÄ±sÄ±na qayÄ±t
                setTimeout(() => {
                    showScreen('roomListScreen');
                    loadRooms();
                }, 5000);
            });

            // connection.on("GameReset", () => {
            //     myHand = [];
            //     hasDrawn = false;
            //     mustDiscard = false;
            //     isMyTurn = false;
            //     renderMyTiles();
            //     clearAllDiscardZones();
            //     document.getElementById('winModal')?.classList.remove('show');
            //     showNotification('Yeni raund...', 'info');
            // });

            connection.on("WinDeclared", (d) => showNotification(d.message, d.isValid ? 'success' : 'error'));
            connection.on("RankUpdated", (d) => {
                document.getElementById('userRank').textContent = d.rank;
                showNotification(t('rank_updated', { rank: d.rank, level: d.level }), 'success');
            });

            connection.on("LeftRoom", () => {
                currentRoomId = null;
                myHand = [];
                showScreen('roomListScreen');
                loadRooms();
            });

            connection.on("LeaveError", (msg) => showNotification(msg, 'error'));
        }




        function adjustTableLayout(playerCount) {
            const table = document.querySelector('.game-table');
            if (!table) return;

            // ÆvvÉ™lki class-larÄ± sil
            table.classList.remove('players-2', 'players-3', 'players-4');

            // Yeni class É™lavÉ™ et
            table.classList.add(`players-${playerCount}`);

            log(`ğŸ® Masa ${playerCount} nÉ™fÉ™rlik rejimdÉ™`);
        }
        // ============autoDiscard============== 
        // âœ… AVTOMATIK DAÅ ATMA ANÄ°MASÄ°YASI
        function showAutoDiscardAnimation(playerName, tile) {
            const relativePos = getRelativePositionByName(playerName);
            let zoneId = '';

            if (relativePos === 'bottom') zoneId = 'myDiscardZone';
            else if (relativePos === 'top') zoneId = 'discardZoneTop';
            else if (relativePos === 'left') zoneId = 'discardZoneLeft';
            else if (relativePos === 'right') zoneId = 'discardZoneRight';

            const zone = document.getElementById(zoneId);
            if (!zone) return;

            // ğŸ¯ DaÅŸ elementi yarat
            const autoTile = document.createElement('div');
            autoTile.className = `okey-tile ${(tile.color || '').toLowerCase()}`;
            autoTile.style.position = 'fixed';
            autoTile.style.width = '36px';
            autoTile.style.height = '55px';
            autoTile.style.zIndex = '7777';
            autoTile.style.animation = 'autoDiscardFly 0.8s ease-in-out forwards';

            // DaÅŸ Ã¼zÉ™rindÉ™ mÉ™tn
            if (tile.isJoker || tile.isFakeJoker) {
                autoTile.innerHTML = '<div class="tile-joker-star">â˜…</div>';
            } else {
                const color = (tile.color || '').toLowerCase();
                const dotColor = color === 'red' ? '#d32f2f' :
                    color === 'yellow' ? '#f9a825' :
                        color === 'blue' ? '#1976d2' : '#212121';
                autoTile.innerHTML = `
            <div class="tile-number">${tile.number}</div>

            <div class="tile-color-dot-container">
            <div class="tile-color-dot" style="background: ${dotColor};"></div>
            </div>
        `;
            }

            // ğŸ¯ BaÅŸlanÄŸÄ±c position (oyunÃ§unun masada yerlÉ™ÅŸdiyi yer)
            const playerInfo = getPlayerInfoElement(relativePos);
            if (playerInfo) {
                const rect = playerInfo.getBoundingClientRect();
                autoTile.style.left = (rect.left + rect.width / 2 - 28) + 'px';
                autoTile.style.top = (rect.top + rect.height / 2 - 41) + 'px';
            }

            // ğŸ¯ CSS-dÉ™ hedef pozisiyanÄ± tÉ™yin et
            autoTile.setAttribute('data-target-zone', zoneId);

            // ğŸ¯ Sona Ã§atdÄ±ÄŸÄ±nda
            autoTile.addEventListener('animationend', () => {
                autoTile.remove();

                // ğŸ¯ Atma zonasÄ±na daÅŸ É™lavÉ™ et
                displayDiscardedTile(tile, getPlayerPositionByName(playerName));

                // ğŸ¯ Zona vizual feedback
                zone.style.transform = 'scale(1.15)';
                zone.style.boxShadow = '0 0 30px rgba(39, 174, 96, 0.8)';

                setTimeout(() => {
                    zone.style.transform = '';
                    zone.style.boxShadow = '';
                }, 300);
            });

            document.body.appendChild(autoTile);
            log('âœ¨ Auto discard animation started');
        }

        // âœ… OyunÃ§unun adÄ±ndan position tapa bilmÉ™k Ã¼Ã§Ã¼n helper
        function getRelativePositionByName(playerName) {
            const players = document.querySelectorAll('[class*="player-info"]');

            for (let el of players) {
                const nameEl = el.querySelector('.player-name');
                if (nameEl && nameEl.textContent === playerName) {
                    // Element ID-dÉ™n position tap
                    if (el.id === 'myPlayerInfo') return 'bottom';
                    if (el.id === 'playerInfoTop') return 'top';
                    if (el.id === 'playerInfoLeft') return 'left';
                    if (el.id === 'playerInfoRight') return 'right';
                }
            }
            return 'bottom';
        }

        // âœ… Position-dan player info elementi tapa bilmÉ™k
        function getPlayerInfoElement(position) {
            const idMap = {
                'bottom': 'myPlayerInfo',
                'top': 'playerInfoTop',
                'left': 'playerInfoLeft',
                'right': 'playerInfoRight'
            };
            return document.getElementById(idMap[position]);
        }

        // âœ… OyunÃ§unun adÄ±ndan position tapa bilmÉ™k Ã¼Ã§Ã¼n backup
        function getPlayerPositionByName(playerName) {
            const players = document.querySelectorAll('[class*="player-info"]');

            for (let el of players) {
                const nameEl = el.querySelector('.player-name');
                if (nameEl && nameEl.textContent === playerName) {
                    if (el.id === 'myPlayerInfo') return 0; // myPosition
                    // DigÉ™rlÉ™rini É™ksik - lazÄ±m olsa doldur
                }
            }
            return myPosition;
        }

        // âœ… UI-Ä± yenilÉ™ (daÅŸ sayÄ±nÄ± azalt)
        function updatePlayerUIAfterTimeout(playerName) {
            const players = document.querySelectorAll('[class*="player-info"]');

            for (let el of players) {
                const nameEl = el.querySelector('.player-name');
                if (nameEl && nameEl.textContent === playerName) {
                    const scoreEl = el.querySelector('.player-score');
                    if (scoreEl) {
                        const currentScore = parseInt(scoreEl.textContent) || 0;
                        // DaÅŸ sayÄ± 1 azalÄ±r
                        if (currentScore > 0) {
                            scoreEl.textContent = currentScore - 1;

                            // ğŸ¯ Visual pulse
                            el.style.animation = 'playerPulse 0.5s ease-out';
                            setTimeout(() => {
                                el.style.animation = '';
                            }, 500);
                        }
                    }
                    break;
                }
            }
        }

        // âœ… CSS ANÄ°MASÄ°YA (style tag-Ä±na É™lavÉ™ et)
        // ÆgÉ™r artÄ±q var isÉ™, yoxla vÉ™ yenisini É™lavÉ™ et
        const style = document.createElement('style');
        style.textContent = `
    @keyframes autoDiscardFly {
        0% {
            transform: scale(1) rotate(0deg);
            opacity: 1;
        }
        50% {
            transform: scale(1.1) rotate(-15deg);
            box-shadow: 0 10px 40px rgba(102, 126, 234, 0.7);
        }
        100% {
            transform: scale(0.85) rotate(5deg);
            opacity: 0.9;
        }
    }

    @keyframes playerPulse {
        0% {
            transform: scale(1);
        }
        50% {
            transform: scale(1.08);
            box-shadow: 0 0 25px rgba(231, 76, 60, 0.8);
        }
        100% {
            transform: scale(1);
        }
    }

    @keyframes slideInRight {
        from {
            transform: translateX(500px);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }
`;
        document.head.appendChild(style);

        // ========================================== 
        function updatePlayerTimer(playerPosition, seconds) {
            const relativePos = getRelativePosition(myPosition, playerPosition);
            let infoId = '';

            if (relativePos === 'bottom') infoId = 'myPlayerInfo';
            else if (relativePos === 'top') infoId = 'playerInfoTop';
            else if (relativePos === 'left') infoId = 'playerInfoLeft';
            else if (relativePos === 'right') infoId = 'playerInfoRight';

            const playerInfo = document.getElementById(infoId);
            if (!playerInfo) return;

            // KÃ¶hnÉ™ timer-i sil
            let timerBadge = playerInfo.querySelector('.timer-badge');
            if (!timerBadge) {
                timerBadge = document.createElement('div');
                timerBadge.className = 'timer-badge';
                playerInfo.style.position = 'relative';
                playerInfo.appendChild(timerBadge);
            }

            // Yeni vaxt gÃ¶stÉ™r
            timerBadge.textContent = seconds;

            // RÉ™ng dÉ™yiÅŸ
            timerBadge.classList.remove('warning', 'critical');
            if (seconds <= 5) {
                timerBadge.classList.add('critical');
            } else if (seconds <= 10) {
                timerBadge.classList.add('warning');
            }

            // âœ… MÉ™nim nÃ¶vbÉ™mdÉ™dirsÉ™ - bildiriÅŸ
            if (relativePos === 'bottom') {
                if (seconds === 10) {
                    showNotification(t('ten_seconds_left'), 'info');
                } else if (seconds === 5) {
                    showNotification(t('five_seconds_left'), 'error');
                } else if (seconds === 1) {
                    showNotification(t('auto_discarding'), 'error');
                }
            }
        }

        // âœ… BÃ¼tÃ¼n timer-lÉ™ri tÉ™mizlÉ™
        function clearAllTimers() {
            ['myPlayerInfo', 'playerInfoTop', 'playerInfoLeft', 'playerInfoRight'].forEach(id => {
                const playerInfo = document.getElementById(id);
                if (playerInfo) {
                    const timerBadge = playerInfo.querySelector('.timer-badge');
                    if (timerBadge) {
                        timerBadge.remove();
                    }
                }
            });
        }

        // Lobby yÃ¼klÉ™mÉ™ funksiyasÄ±
        // Lobby yÃ¼klÉ™mÉ™ funksiyasÄ±
        async function loadRooms() {
            try {
                const rooms = await connection.invoke("GetRoomList");
                const grid = document.getElementById('roomsGrid');

                if (!rooms || rooms.length === 0) {
                    grid.innerHTML = `<div style="text-align: center; padding: 50px; color: white;">${t('room_list_empty')}</div>`;
                    return;
                }

                // OtaqlarÄ± saxla (modal Ã¼Ã§Ã¼n)
                window.availableRooms = rooms;

                // OyunÃ§u sayÄ± seÃ§imlÉ™ri
                grid.innerHTML = `
            <div class="player-selection-container">
                <div class="player-options">
                    ${[2, 3, 4].map(playerCount => {
                    const playerRooms = rooms.filter(r => r.maxPlayers === playerCount);
                    const totalPlayers = playerRooms.reduce((sum, r) => sum + r.playerCount, 0);
                    // <span class="player-count-info">${totalPlayers} oyunÃ§u</span>
                    // <div class="player-icon-large">ğŸ‘¥</div>

                    return `
                            <div class="player-option-card" onclick="openBetModal(${playerCount})">
                                <div class="player-count-large">${playerCount}</div>
                                <div class="player-label">${t('players_label')}</div>
                                ${playerRooms.length > 0 ? `
                                ` : `<div class="no-rooms">${t('no_rooms')}</div>`}
                            </div>
                        `;
                }).join('')}
                </div>
            </div>
        `;

            } catch (err) {
                console.error('âŒ Load rooms error:', err);
            }
        }

        // Bet modal aÃ§ma
        function openBetModal(playerCount) {
            const rooms = window.availableRooms.filter(r => r.maxPlayers === playerCount);

            if (!rooms || rooms.length === 0) {
                showNotification(t('no_rooms_for_count'), 'error');
                return;
            }

            // Modal yaradÄ±rÄ±q vÉ™ ya tapÄ±rÄ±q
            let modal = document.getElementById('lobbyBetModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'lobbyBetModal';
                modal.className = 'modal-overlay';
                modal.style.display = 'none';
                document.body.appendChild(modal);

                // Overlay-É™ klik edÉ™ndÉ™ baÄŸlansÄ±n
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) closeLobbyBetModal();
                });
            }

            // Unikal bet mÉ™blÉ™ÄŸlÉ™ri
            const uniqueBets = [...new Set(rooms.map(r => r.entryFee))].sort((a, b) => a - b);

            // <div class="bet-info-small">${room.playerCount}/${playerCount} oyunÃ§u</div>
            // Modal content-i yenilÉ™
            modal.innerHTML = `
        <div class="modal-content">
            <div class="modal-header">
                <h2>${t('player_count_game', { count: playerCount })}</h2>
                <button class="modal-close" onclick="closeLobbyBetModal()">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="bet-grid" id="betOptions">
                    ${uniqueBets.map(bet => {
                const room = rooms.find(r => r.entryFee === bet);
                return `
                            <button class="lobby-bet-card" onclick="joinRoom('${room.roomId}')">
                                <div class="bet-amount">ğŸ’° ${bet}</div>
                            </button>
                        `;
            }).join('')}
                </div>
            </div>
        </div>
    `;

            modal.style.display = 'flex';
        }

        // Modal baÄŸlama
        function closeLobbyBetModal() {
            const modal = document.getElementById('lobbyBetModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // OtaÄŸa qoÅŸulma
        async function joinRoom(roomId) {
            try {
                closeLobbyBetModal();
                showNotification(t('joining'), 'info');
                await connection.invoke("JoinRoom", roomId, null);
                sortTiles();
            } catch (err) {
                console.error('âŒ Join error:', err);
                showNotification(t('join_failed'), 'error');
            }
        }

        // Auto refresh
        // setInterval(() => {
        //     if (document.getElementById('roomListScreen').classList.contains('active') && connection) {
        //         loadRooms();
        //     }
        // }, 3000);

        // âœ… YENÄ° FUNKSIYA: GÃ¶stÉ™rici Ã¼zÉ™rinÉ™ daÅŸ atmaq
        function setupIndicatorDropZone() {
            const indicatorEl = document.getElementById('indicatorTile');
            if (!indicatorEl) return;

            indicatorEl.addEventListener('dragenter', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (hasDrawn && mustDiscard && isMyTurn && draggedTile) {
                    indicatorEl.style.border = '3px solid #27ae60';
                    indicatorEl.style.transform = 'scale(1.1)';
                }
            });

            indicatorEl.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (hasDrawn && mustDiscard && isMyTurn && draggedTile) {
                    e.dataTransfer.dropEffect = 'move';
                }
            });

            indicatorEl.addEventListener('dragleave', (e) => {
                const rect = indicatorEl.getBoundingClientRect();
                if (e.clientX < rect.left || e.clientX > rect.right ||
                    e.clientY < rect.top || e.clientY > rect.bottom) {
                    indicatorEl.style.border = '';
                    indicatorEl.style.transform = '';
                }
            });

            indicatorEl.addEventListener('drop', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                indicatorEl.style.border = '';
                indicatorEl.style.transform = '';

                if (hasDrawn && mustDiscard && isMyTurn && draggedTile) {
                    const tileId = draggedTile.id;
                    draggedTile = null;
                    draggedFromIndex = null;

                    try {
                        log('ğŸ¯ GÃ¶stÉ™rici Ã¼zÉ™rinÉ™ daÅŸ atÄ±lÄ±r - oyun bitir!');
                        await connection.invoke("DiscardOnIndicator", tileId);
                    } catch (err) {
                        log('âŒ DiscardOnIndicator error:', err);
                        showNotification(t('error_occurred'), 'error');
                    }
                }
            });
        }

        async function leaveRoom() {
            if (!confirm(t('leave_confirm'))) return;
            try {
                await connection.invoke("LeaveRoom");
            } catch (err) {
                log('âŒ Leave error:', err);
                showScreen('roomListScreen');
                loadRooms();
            }
        }

        async function drawFromStock() {
            if (!isMyTurn || hasDrawn || mustDiscard) {
                showNotification(mustDiscard ? t('discard_now') : t('draw_turn_wait'), 'error');
                return;
            }

            // âœ… Vizual animasiya
            const deckStack = document.getElementById('deckStack');
            if (deckStack) {
                deckStack.style.transform = 'scale(1.15) translateY(-10px)';
                deckStack.style.boxShadow = '0 10px 35px rgba(52, 152, 219, 0.8)';

                setTimeout(() => {
                    deckStack.style.transform = '';
                    deckStack.style.boxShadow = '';
                }, 300);
            }

            try {
                await connection.invoke("DrawTile", "stock");
            } catch (err) {
                log('âŒ Draw error:', err);
            }
        }

        async function tryDrawFromLeftPlayer() {
            if (!isMyTurn || hasDrawn || mustDiscard) {
                if (mustDiscard) showNotification(t('discard_first'), 'error');
                else if (hasDrawn) showNotification(t('already_drew'), 'error');
                else showNotification(t('not_your_turn'), 'error');
                return;
            }

            const zone = document.getElementById('discardZoneTop');
            if (!zone || !zone.querySelector('.okey-tile')) {
                showNotification(t('opponent_not_discarded'), 'error');
                return;
            }

            try {
                log('ğŸ´ Top oyunÃ§udan daÅŸ gÃ¶tÃ¼rÃ¼rÉ™m...');
                await connection.invoke("DrawTile", "discard");
                setTimeout(() => {
                    zone.innerHTML = '';
                    log('âœ… Top oyunÃ§unun daÅŸÄ± silindi');
                }, 150);
            } catch (err) {
                log('âŒ Draw from discard error:', err);
                showNotification(t('draw_failed'), 'error');
            }
        }

        async function discardTile(tileId) {
            if (!hasDrawn || !mustDiscard) {
                showNotification(t('draw_first'), 'error');
                return;
            }

            // âœ… Vizual animasiya - atma zonasÄ±
            const myDiscardZone = document.getElementById('myDiscardZone');
            if (myDiscardZone) {
                myDiscardZone.style.transform = 'scale(1.1)';
                myDiscardZone.style.borderColor = '#27ae60';

                setTimeout(() => {
                    myDiscardZone.style.transform = '';
                    myDiscardZone.style.borderColor = '';
                }, 300);
            }

            try {
                await connection.invoke("DiscardTile", tileId);
            } catch (err) {
                log('âŒ Discard error:', err);
            }
        }

        async function declareWin() {
            try {
                await connection.invoke("DeclareWin");
            } catch (err) { log('âŒ Win error:', err); }
        }

        // âœ… SORT FUNKSIYASINI YENILÆ
        function sortTiles() {
            const colorOrder = { red: 0, yellow: 1, blue: 2, black: 3, fakejoker: 4 };

            myHand.sort((a, b) => {
                const colorA = (a.color || '').toLowerCase();
                const colorB = (b.color || '').toLowerCase();
                const colorDiff = (colorOrder[colorA] || 0) - (colorOrder[colorB] || 0);
                return colorDiff !== 0 ? colorDiff : a.number - b.number;
            });

            // âœ… Cache-i tÉ™mizlÉ™ vÉ™ yenidÉ™n dÃ¼zÉ™lt
            tilePositions = {};
            autoArrangeTiles();
            renderMyTiles();

            showNotification(t('sort_done'), 'success');
        }

        function getRelativePosition(myPos, targetPos) {
            const diff = (targetPos - myPos + maxPlayers) % maxPlayers;

            if (maxPlayers === 2) {
                // 2 nÉ™fÉ™r: bottom, top
                if (diff === 0) return 'bottom';
                if (diff === 1) return 'top';
            } else if (maxPlayers === 3) {
                // 3 nÉ™fÉ™r: bottom, left, right
                if (diff === 0) return 'bottom';
                if (diff === 1) return 'right';
                if (diff === 2) return 'left';
            } else {
                // 4 nÉ™fÉ™r: bottom, right, top, left
                if (diff === 0) return 'bottom';
                if (diff === 1) return 'right';
                if (diff === 2) return 'top';
                if (diff === 3) return 'left';
            }

            return 'bottom';
        }

        // âœ… Tile HTML yaratmaq Ã¼Ã§Ã¼n kÃ¶mÉ™kÃ§i funksiya
        function createTileHTML(tile, globalIdx) {
            if (!tile) return '';

            let className = `okey-tile ${(tile.color || '').toLowerCase()}`;
            let content = '';

            if (tile.isFakeJoker || tile.isJoker) {
                content = '<div class="tile-joker-star">â˜…</div>';
                className += ' joker';
            } else {
                const color = (tile.color || '').toLowerCase();
                const dotColor =
                    color === 'red' ? '#d32f2f' :
                        color === 'yellow' ? '#f9a825' :
                            color === 'blue' ? '#1976d2' : '#212121';

                content = `
            <div class="tile-number">${tile.number}</div>
            <div class="tile-color-dot-container">
            <div class="tile-color-dot" style="background: ${dotColor};"></div>
            </div>
        `;
            }

            return `<div class="${className}" data-tile-id="${tile.id}" data-idx="${globalIdx}" draggable="true">${content}</div>`;
        }


        function renderMyTiles() {
            const board = document.getElementById('myBoard');
            if (!board) {
                console.error('âŒ myBoard tapÄ±lmadÄ±!');
                return;
            }

            const tileWidth = 36;
            const gap = 3;
            const ROW_1_Y = 10;
            const ROW_2_Y = 70;

            // âœ… 1. KÃ¶hnÉ™ daÅŸlarÄ±n pozisiyalarÄ±nÄ± cache-É™ saxla
            myHand.forEach(tile => {
                if (tile.x !== undefined && tile.y !== undefined) {
                    tilePositions[tile.id] = { x: tile.x, y: tile.y };
                }
            });

            // âœ… 2. Cache-dÉ™n pozisiyalarÄ± geri qaytar
            myHand.forEach(tile => {
                if (tilePositions[tile.id]) {
                    tile.x = tilePositions[tile.id].x;
                    tile.y = tilePositions[tile.id].y;
                }
            });

            // âœ… 3. Yeni daÅŸlarÄ± (pozisiyasÄ± olmayan) sona yerlÉ™ÅŸdir
            const tilesWithoutPosition = myHand.filter(t => t.x === undefined || t.y === undefined);

            if (tilesWithoutPosition.length > 0) {
                // HÉ™r iki sÉ™tirdÉ™ mÃ¶vcud daÅŸlarÄ± say
                const row1Count = myHand.filter(t => t.y === ROW_1_Y && t.x !== undefined).length;
                const row2Count = myHand.filter(t => t.y === ROW_2_Y && t.x !== undefined).length;

                // Yeni daÅŸlarÄ± yerlÉ™ÅŸdir
                tilesWithoutPosition.forEach(tile => {
                    if (row1Count < 8) {
                        // 1-ci sÉ™trÉ™ É™lavÉ™ et
                        const existingRow1 = myHand.filter(t => t.y === ROW_1_Y && t.x !== undefined);
                        const maxX = existingRow1.length > 0
                            ? Math.max(...existingRow1.map(t => t.x))
                            : -gap;

                        tile.x = maxX + tileWidth + gap;
                        tile.y = ROW_1_Y;
                    } else {
                        // 2-ci sÉ™trÉ™ É™lavÉ™ et
                        const existingRow2 = myHand.filter(t => t.y === ROW_2_Y && t.x !== undefined);
                        const maxX = existingRow2.length > 0
                            ? Math.max(...existingRow2.map(t => t.x))
                            : -gap;

                        tile.x = maxX + tileWidth + gap;
                        tile.y = ROW_2_Y;
                    }

                    // Cache-É™ É™lavÉ™ et
                    tilePositions[tile.id] = { x: tile.x, y: tile.y };
                });
            }

            // âœ… 4. Board-u tÉ™mizlÉ™ vÉ™ render et
            board.innerHTML = '';

            myHand.forEach((tile, idx) => {
                const x = tile.x || 10;
                const y = tile.y || 10;

                const tileEl = document.createElement('div');
                tileEl.className = `okey-tile ${(tile.color || '').toLowerCase()}`;
                tileEl.dataset.idx = idx;
                tileEl.dataset.tileId = tile.id;
                tileEl.draggable = false;
                tileEl.style.left = x + 'px';
                tileEl.style.top = y + 'px';
                tileEl.style.cursor = 'grab';

                if (tile.isFakeJoker || tile.isJoker) {
                    tileEl.innerHTML = '<div class="tile-joker-star">â˜…</div>';
                    tileEl.classList.add('joker');
                } else {
                    const color = (tile.color || '').toLowerCase();
                    const dotColor =
                        color === 'red' ? '#d32f2f' :
                            color === 'yellow' ? '#f9a825' :
                                color === 'blue' ? '#1976d2' : '#212121';

                    tileEl.innerHTML = `
                <div class="tile-number">${tile.number}</div>
                <div class="tile-color-dot-container">
            <div class="tile-color-dot" style="background: ${dotColor};"></div>
            </div>
            `;
                }

                board.appendChild(tileEl);
            });

            setupFreeDragDrop();
            // setupMyDiscardZone();
            setupIndicatorDropZone();
        }



        function setupFreeDragDrop() {
            const board = document.getElementById('myBoard');
            const container = document.getElementById('myBoardContainer');
            const discardZone = document.getElementById('myDiscardZone');

            if (!board || !container) return;

            const tiles = board.querySelectorAll('.okey-tile');
            let activeTile = null;
            let activeIdx = null;
            let isDragging = false;
            let isOverDiscardZone = false;

            // âœ… Tile-Ä±n board iÃ§indÉ™ki orijinal pozisiyasÄ±
            let startBoardX = 0;
            let startBoardY = 0;

            // âœ… Mouse-un tile Ã¼zÉ™rindÉ™ki offset-i
            let mouseOffsetX = 0;
            let mouseOffsetY = 0;

            const ROW_1_Y = 10;
            const ROW_2_Y = 75;
            const SNAP_THRESHOLD = 45;

            tiles.forEach((tileEl) => {
                const idx = parseInt(tileEl.dataset.idx);

                // âœ… MOUSE DOWN
                tileEl.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    activeTile = tileEl;
                    activeIdx = idx;
                    isDragging = true;

                    // âœ… Board iÃ§indÉ™ki orijinal pozisiya
                    const boardRect = board.getBoundingClientRect();
                    const tileRect = tileEl.getBoundingClientRect();

                    startBoardX = tileRect.left - boardRect.left;
                    startBoardY = tileRect.top - boardRect.top;

                    // âœ… Mouse tile Ã¼zÉ™rindÉ™ harada?
                    mouseOffsetX = e.clientX - tileRect.left;
                    mouseOffsetY = e.clientY - tileRect.top;

                    // Style dÉ™yiÅŸikliklÉ™ri
                    tileEl.style.cursor = 'grabbing';
                    tileEl.style.zIndex = '1000';
                    tileEl.style.opacity = '0.9';
                    tileEl.style.transition = 'none';
                    tileEl.classList.add('dragging');
                });

                // âœ… DOUBLE-CLICK
                tileEl.addEventListener('dblclick', () => {
                    if (mustDiscard && hasDrawn && isMyTurn) {
                        const tileId = myHand[idx].id;

                        if (myHand.length === 1) {
                            log('ğŸ† Son daÅŸ ikiqat klik - oyun bitir!');
                            showNotification(t('last_tile_discarded_checking'), 'success');
                            setTimeout(() => declareWin(), 300);
                        } else {
                            discardTile(tileId);
                        }
                    }
                });

                // âœ… TOUCH START
                tileEl.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];

                    activeTile = tileEl;
                    activeIdx = idx;
                    isDragging = true;

                    const boardRect = board.getBoundingClientRect();
                    const tileRect = tileEl.getBoundingClientRect();

                    startBoardX = tileRect.left - boardRect.left;
                    startBoardY = tileRect.top - boardRect.top;

                    mouseOffsetX = touch.clientX - tileRect.left;
                    mouseOffsetY = touch.clientY - tileRect.top;

                    tileEl.style.zIndex = '1000';
                    tileEl.style.opacity = '0.9';
                    tileEl.style.transition = 'none';
                    tileEl.classList.add('dragging');
                });
            });

            // âœ… MOUSE MOVE - BOARD Ä°Ã‡Ä°NDÆ ABSOLUTE POZÄ°SÄ°YA
            document.addEventListener('mousemove', (e) => {
                if (!isDragging || !activeTile) return;

                const boardRect = board.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();
                const discardRect = discardZone ? discardZone.getBoundingClientRect() : null;

                // âœ… Mouse-un board-a nisbÉ™tÉ™n pozisiyasÄ±
                let boardX = e.clientX - boardRect.left - mouseOffsetX;
                let boardY = e.clientY - boardRect.top - mouseOffsetY;

                // âœ… Container sÉ™rhÉ™dlÉ™rindÉ™ saxla
                const tileWidth = 36;
                const tileHeight = 55;

                // Board-dan Ã§Ä±xa bilÉ™r amma container-dan Ã§Ä±xmaz
                const minX = containerRect.left - boardRect.left - mouseOffsetX;
                const maxX = containerRect.right - boardRect.left - mouseOffsetX - tileWidth;
                const minY = containerRect.top - boardRect.top - mouseOffsetY;
                const maxY = containerRect.bottom - boardRect.top - mouseOffsetY - tileHeight;

                boardX = Math.max(minX, Math.min(boardX, maxX));
                boardY = Math.max(minY, Math.min(boardY, maxY));

                // âœ… PozisiyanÄ± tÉ™tbiq et
                activeTile.style.left = boardX + 'px';
                activeTile.style.top = boardY + 'px';

                // âœ… Discard zone Ã¼zÉ™rindÉ™dirsÉ™?
                if (discardRect && hasDrawn && mustDiscard && isMyTurn) {
                    const tileCenterX = e.clientX;
                    const tileCenterY = e.clientY;

                    isOverDiscardZone =
                        tileCenterX >= discardRect.left &&
                        tileCenterX <= discardRect.right &&
                        tileCenterY >= discardRect.top &&
                        tileCenterY <= discardRect.bottom;

                    if (isOverDiscardZone) {
                        discardZone.classList.add('can-drop');
                    } else {
                        discardZone.classList.remove('can-drop');
                    }
                }
            });

            // âœ… MOUSE UP
            document.addEventListener('mouseup', (e) => {
                if (isDragging && activeTile && activeIdx !== null) {
                    const boardRect = board.getBoundingClientRect();
                    const discardRect = discardZone ? discardZone.getBoundingClientRect() : null;

                    // âœ… Discard zone-a atÄ±ldÄ±mÄ±?
                    if (discardRect && hasDrawn && mustDiscard && isMyTurn && isOverDiscardZone) {
                        const tileId = myHand[activeIdx].id;

                        discardZone.classList.remove('can-drop');
                        activeTile.remove();

                        if (myHand.length === 1) {
                            log('ğŸ† Son daÅŸ atÄ±lÄ±r - oyun bitir!');
                            showNotification(t('last_tile_discarded_checking'), 'success');
                            setTimeout(() => declareWin(), 300);
                        } else {
                            discardTile(tileId);
                        }
                    }
                    // âœ… Board iÃ§indÉ™dirsÉ™ - snap
                    else {
                        // Board-a nisbÉ™tÉ™n pozisiya
                        let boardX = e.clientX - boardRect.left - mouseOffsetX;
                        let boardY = e.clientY - boardRect.top - mouseOffsetY;

                        // Board sÉ™rhÉ™dlÉ™rindÉ™ saxla
                        const tileWidth = 36;
                        boardX = Math.max(0, Math.min(boardX, boardRect.width - tileWidth));

                        // HansÄ± sÉ™tirÉ™ snap?
                        const SNAP_THRESHOLD = 55; // ÆvvÉ™l 50 idi
                        const targetY = boardY < SNAP_THRESHOLD ? ROW_1_Y : ROW_2_Y;


                        let finalX = boardX;
                        let finalY = targetY;

                        // ToqquÅŸma yoxla
                        if (!isPositionValid(finalX, finalY, activeIdx)) {
                            const validPos = findNearestValidPosition(finalX, finalY, activeIdx, boardRect.width);
                            finalX = validPos.x;
                            finalY = validPos.y;
                        }

                        myHand[activeIdx].x = finalX;
                        myHand[activeIdx].y = finalY;

                        // âœ… Cache-É™ É™lavÉ™ et
                        tilePositions[myHand[activeIdx].id] = { x: finalX, y: finalY };

                        activeTile.style.transition = 'left 0.2s ease-out, top 0.2s ease-out';
                        activeTile.style.left = finalX + 'px';
                        activeTile.style.top = finalY + 'px';
                    }

                    // Reset
                    const tileToUpdate = activeTile;
                    setTimeout(() => {
                        if (tileToUpdate) {
                            tileToUpdate.style.cursor = 'grab';
                            tileToUpdate.style.zIndex = '1';
                            tileToUpdate.style.opacity = '1';
                            tileToUpdate.style.transition = 'none';
                            tileToUpdate.classList.remove('dragging');
                        }
                    }, 300);

                    if (discardZone) discardZone.classList.remove('can-drop');
                }

                isDragging = false;
                activeTile = null;
                activeIdx = null;
                isOverDiscardZone = false;
            });

            // âœ… TOUCH MOVE
            document.addEventListener('touchmove', (e) => {
                if (!isDragging || !activeTile) return;
                e.preventDefault();

                const touch = e.touches[0];
                const boardRect = board.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();
                const discardRect = discardZone ? discardZone.getBoundingClientRect() : null;

                let boardX = touch.clientX - boardRect.left - mouseOffsetX;
                let boardY = touch.clientY - boardRect.top - mouseOffsetY;

                const tileWidth = 36;
                const tileHeight = 55;

                const minX = containerRect.left - boardRect.left - mouseOffsetX;
                const maxX = containerRect.right - boardRect.left - mouseOffsetX - tileWidth;
                const minY = containerRect.top - boardRect.top - mouseOffsetY;
                const maxY = containerRect.bottom - boardRect.top - mouseOffsetY - tileHeight;

                boardX = Math.max(minX, Math.min(boardX, maxX));
                boardY = Math.max(minY, Math.min(boardY, maxY));

                activeTile.style.left = boardX + 'px';
                activeTile.style.top = boardY + 'px';

                if (discardRect && hasDrawn && mustDiscard && isMyTurn) {
                    const tileCenterX = touch.clientX;
                    const tileCenterY = touch.clientY;

                    isOverDiscardZone =
                        tileCenterX >= discardRect.left &&
                        tileCenterX <= discardRect.right &&
                        tileCenterY >= discardRect.top &&
                        tileCenterY <= discardRect.bottom;

                    if (isOverDiscardZone) {
                        discardZone.classList.add('can-drop');
                    } else {
                        discardZone.classList.remove('can-drop');
                    }
                }
            });

            // âœ… TOUCH END
            document.addEventListener('touchend', (e) => {
                if (isDragging && activeTile && activeIdx !== null) {
                    const touch = e.changedTouches[0];
                    const boardRect = board.getBoundingClientRect();
                    const discardRect = discardZone ? discardZone.getBoundingClientRect() : null;

                    if (discardRect && hasDrawn && mustDiscard && isMyTurn && isOverDiscardZone) {
                        const tileId = myHand[activeIdx].id;

                        discardZone.classList.remove('can-drop');
                        activeTile.remove();

                        if (myHand.length === 1) {
                            showNotification(t('last_tile_discarded'), 'success');
                            setTimeout(() => declareWin(), 300);
                        } else {
                            discardTile(tileId);
                        }
                    } else {
                        let boardX = touch.clientX - boardRect.left - mouseOffsetX;
                        let boardY = touch.clientY - boardRect.top - mouseOffsetY;

                        const tileWidth = 36;
                        boardX = Math.max(0, Math.min(boardX, boardRect.width - tileWidth));

                        const targetY = boardY < SNAP_THRESHOLD ? ROW_1_Y : ROW_2_Y;

                        let finalX = boardX;
                        let finalY = targetY;

                        if (!isPositionValid(finalX, finalY, activeIdx)) {
                            const validPos = findNearestValidPosition(finalX, finalY, activeIdx, boardRect.width);
                            finalX = validPos.x;
                            finalY = validPos.y;
                        }

                        myHand[activeIdx].x = finalX;
                        myHand[activeIdx].y = finalY;

                        // âœ… Cache-É™ É™lavÉ™ et
                        tilePositions[myHand[activeIdx].id] = { x: finalX, y: finalY };

                        activeTile.style.transition = 'left 0.2s ease-out, top 0.2s ease-out';
                        activeTile.style.left = finalX + 'px';
                        activeTile.style.top = finalY + 'px';
                    }

                    const tileToUpdate = activeTile;
                    setTimeout(() => {
                        if (tileToUpdate) {
                            tileToUpdate.style.zIndex = '1';
                            tileToUpdate.style.opacity = '1';
                            tileToUpdate.style.transition = 'none';
                            tileToUpdate.classList.remove('dragging');
                        }
                    }, 300);

                    if (discardZone) discardZone.classList.remove('can-drop');
                }

                isDragging = false;
                activeTile = null;
                activeIdx = null;
                isOverDiscardZone = false;
            });
        }



        function displayDiscardedTile(tile, playerPosition) {
            const relativePos = getRelativePosition(myPosition, playerPosition);
            let zoneId = '';

            if (relativePos === 'bottom') zoneId = 'myDiscardZone';
            else if (relativePos === 'top') zoneId = 'discardZoneTop';
            else if (relativePos === 'left') zoneId = 'discardZoneLeft';
            else if (relativePos === 'right') zoneId = 'discardZoneRight';

            const zone = document.getElementById(zoneId);
            if (zone && tile) {
                // if (zone.innerHTML.includes('ğŸ—‘ï¸')) {
                //     zone.innerHTML = '';
                // }

                zone.insertAdjacentHTML('beforeend', createTileHTML(tile, 0));

                const tiles = zone.querySelectorAll('.okey-tile');
                if (tiles.length > 3) {
                    tiles[0].remove();
                }

                // âœ… YENÄ° - 2 nÉ™fÉ™rlikdÉ™ top oyunÃ§unun daÅŸÄ±nÄ± gÃ¶tÃ¼rÉ™ bilmÉ™k
                if (maxPlayers === 2 && zoneId === 'discardZoneTop') {
                    zone.classList.add('clickable');
                    zone.style.cursor = 'pointer';
                }
            }
        }

        function clearAllDiscardZones() {
            ['myDiscardZone', 'discardZoneTop', 'discardZoneLeft', 'discardZoneRight'].forEach(id => {
                const zone = document.getElementById(id);
                if (zone) {
                    // Tam tÉ™mizlÉ™
                    zone.innerHTML = '';

                    // Ä°kon É™lavÉ™ et
                    if (id === 'myDiscardZone') {
                        zone.innerHTML = '';
                    } else {
                        zone.innerHTML = '';
                    }

                    // Style-Ä± sÄ±fÄ±rla
                    zone.classList.remove('clickable', 'can-drop');
                    zone.style.cursor = '';
                    zone.style.transform = '';
                    zone.style.boxShadow = '';
                    zone.style.borderColor = '';
                }
            });

            console.log('âœ… Discard zona-larÄ± tÉ™mizlÉ™ndi');
        }

        function updatePlayersDisplay(players) {
            // ÆvvÉ™lcÉ™ hamÄ±sÄ±nÄ± gizlÉ™t
            ['playerInfoTop', 'playerInfoLeft', 'playerInfoRight'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.style.display = 'none';
                    el.classList.remove('active');
                }
            });

            players.forEach((player) => {
                const relativePos = getRelativePosition(myPosition, player.position);
                let infoId = '';

                if (relativePos === 'bottom') infoId = 'myPlayerInfo';
                else if (relativePos === 'top') infoId = 'playerInfoTop';
                else if (relativePos === 'left') infoId = 'playerInfoLeft';
                else if (relativePos === 'right') infoId = 'playerInfoRight';

                const infoEl = document.getElementById(infoId);
                if (!infoEl) return;

                // GÃ¶stÉ™r
                infoEl.style.display = 'flex';

                const nameEl = infoEl.querySelector('.player-name');
                const scoreEl = infoEl.querySelector('.player-score');

                if (nameEl) nameEl.textContent = player.name;
                if (scoreEl) scoreEl.textContent = player.score;

                if (player.isActive) infoEl.classList.add('active');
                else infoEl.classList.remove('active');
            });
        }

        function setIndicatorTile(tile) {
            const el = document.getElementById('indicatorTile');
            if (el && tile) el.innerHTML = createTileHTML(tile, 0);
        }

        function setJokerTile(tile) {
            const el = document.getElementById('jokerTile');
            if (el && tile) el.innerHTML = createTileHTML(tile, 0);
        }

        async function tryDrawFromTopPlayer() {
            if (!isMyTurn || hasDrawn || mustDiscard) {
                if (mustDiscard) showNotification(t('discard_first'), 'error');
                else if (hasDrawn) showNotification(t('already_drew'), 'error');
                else showNotification(t('not_your_turn'), 'error');
                return;
            }

            const zone = document.getElementById('discardZoneTop');
            if (!zone || !zone.querySelector('.okey-tile')) {
                showNotification(t('opponent_not_discarded'), 'error');
                return;
            }

            try {
                log('ğŸ´ Top oyunÃ§udan daÅŸ gÃ¶tÃ¼rÃ¼rÉ™m...');
                await connection.invoke("DrawTile", "discard");
                setTimeout(() => {
                    zone.innerHTML = '';
                    log('âœ… Top oyunÃ§unun daÅŸÄ± silindi');
                }, 150);
            } catch (err) {
                log('âŒ Draw from discard error:', err);
                showNotification(t('draw_failed'), 'error');
            }
        }

        // âœ… Global scope-a É™lavÉ™ et
        window.tryDrawFromTopPlayer = tryDrawFromTopPlayer;

        function updateTurnUI() {
            const deckStack = document.getElementById('deckStack');

            if (isMyTurn && !hasDrawn && !mustDiscard) {
                deckStack?.classList.remove('disabled');
            } else {
                deckStack?.classList.add('disabled');
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            log('ğŸ® Okey Premium Loaded');
            setLanguage(currentLanguage);
            updatePotAmount(currentPotAmount);
            document.getElementById('leaveRoomBtn')?.addEventListener('click', leaveRoom);
            document.getElementById('sortBtn')?.addEventListener('click', sortTiles);
            document.getElementById('deckStack')?.addEventListener('click', drawFromStock);

            initializeSignalR();
        });
        function backToGames() {
            window.parent.postMessage({ type: 'BACK_TO_GAMES', payload: {} }, '*');
        }
        console.log(document.getElementById('myBoard')); // null deyilsÉ™ OK
        console.log(myHand); // daÅŸlar varmÄ±?
        window.joinRoom = joinRoom;
        window.tryDrawFromLeftPlayer = tryDrawFromLeftPlayer;

    </script>
</body>

</html>

<!DOCTYPE html>
<html lang="az">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÆ Okey Premium</title>
    <link rel="stylesheet" href="./Okey.css">
</head>

<body>
    <div id="roomListScreen" class="screen active">
        <div class="room-list-container">
            <div class="header">
                <div>
                    <h1>üéÆ Okey Premium</h1>
                    <p style="color: #7f8c8d; margin-top: 5px;">Klassik Okey Oyunu</p>
                </div>
                <div class="user-info">
                    <span class="user-name" id="userName">Y√ºkl…ônir...</span>
                    <span class="rank-badge" id="userRank">Yeni</span>
                    <span class="user-balance" id="userBalance">üí∞ 0‚Çº</span>
                </div>
            </div>
            <div class="rooms-grid" id="roomsGrid">
                <div style="text-align: center; padding: 50px; color: white;">
                    <div class="loading"></div>
                    <p style="margin-top: 20px;">Y√ºkl…ônir...</p>
                </div>
            </div>
        </div>
    </div>

    <div id="gameScreen" class="screen">
        <div class="game-container">
            <div class="game-header">
                <div class="game-info">
                    <span id="roomNameDisplay">Otaq</span>
                    <span id="gameModeDisplay" style="color: #f39c12;">Mod: 101</span>
                    <span id="potAmountDisplay" style="color: #27ae60;">Pot: 0‚Çº</span>
                </div>
                <button id="leaveRoomBtn" class="btn btn-danger">√áƒ±x</button>
            </div>

            <div class="game-table">
                <div class="player-section player-section-top">
                    <div class="player-info" id="playerInfoTop">
                        <div class="player-avatar">üë§</div>
                        <div class="player-details">
                            <div class="player-name">G√∂zl…ôyir</div>
                            <div class="player-score">101</div>
                        </div>
                    </div>
                    <div class="discard-zone" id="discardZoneTop">üóëÔ∏è</div>
                </div>

                <div class="player-section player-section-right">
                    <div class="discard-zone" id="discardZoneRight">üóëÔ∏è</div>
                    <div class="player-info" id="playerInfoRight">
                        <div class="player-avatar">üë§</div>
                        <div class="player-details">
                            <div class="player-name">G√∂zl…ôyir</div>
                            <div class="player-score">101</div>
                        </div>
                    </div>
                </div>

                <div class="player-section player-section-bottom">
                    <div class="my-actions">
                        <button id="sortBtn" class="btn-action">üî§ Sƒ±rala</button>
                        <button id="declareWinBtn" class="btn-action btn-success" disabled>üèÜ Bitir</button>
                    </div>

                    <div class="my-board-container">
                        <div class="my-board" id="myBoard">
                            <!-- <div class="tile-row" id="myRow1"></div>
                            <div class="tile-row" id="myRow2"></div> -->
                        </div>
                        <div class="my-discard-zone" id="myDiscardZone">
                            üóëÔ∏è
                            <div class="discard-label">BURAYA<br>AT</div>
                        </div>
                    </div>

                    <div class="player-info active" id="myPlayerInfo">
                        <div class="player-avatar">üòä</div>
                        <div class="player-details">
                            <div class="player-name" id="myPlayerName">Siz</div>
                            <div class="player-score" id="myScore">101</div>
                        </div>
                    </div>
                </div>

                <div class="player-section player-section-left">
                    <div class="player-info" id="playerInfoLeft">
                        <div class="player-avatar">üë§</div>
                        <div class="player-details">
                            <div class="player-name">G√∂zl…ôyir</div>
                            <div class="player-score">101</div>
                        </div>
                    </div>
                    <div class="discard-zone clickable" id="discardZoneLeft" onclick="tryDrawFromLeftPlayer()">üóëÔ∏è</div>
                </div>

                <div class="center-area">
                    <div class="indicator-wrapper">
                        <div class="indicator-label">üéØ G√ñST∆èRƒ∞Cƒ∞</div>
                        <div id="indicatorTile"></div>
                    </div>

                    <div class="deck-stack" id="deckStack">
                        <div class="deck-tile-layer">üé¥</div>
                        <div class="deck-tile-layer">üé¥</div>
                        <div class="deck-tile-layer">üé¥</div>
                        <div class="deck-label" id="deckCountLabel">üìö 106</div>
                    </div>

                    <div class="indicator-wrapper">
                        <div class="indicator-label">üÉè JOKER</div>
                        <div id="jokerTile"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="notification" class="notification"></div>

    <script src="https://cdn.jsdelivr.net/npm/@microsoft/signalr@latest/dist/browser/signalr.min.js"></script>
    <script>



        //Collusion test etc

        // ‚úÖ ƒ∞ki da≈ü toqqu≈üurmu?
        function checkTileCollision(x1, y1, x2, y2, tileWidth = 55, tileHeight = 70) {
            return !(x1 + tileWidth <= x2 ||
                x2 + tileWidth <= x1 ||
                y1 + tileHeight <= y2 ||
                y2 + tileHeight <= y1);
        }

        // ‚úÖ Pozisiya s…ôrb…ôstdirmi? (ba≈üqa da≈üla toqqu≈ümur?)
        function isPositionValid(x, y, currentIdx) {
            const tileWidth = 55;
            const tileHeight = 70;

            for (let i = 0; i < myHand.length; i++) {
                if (i === currentIdx) continue; // √ñz√ºn√º yoxlama

                const otherTile = myHand[i];
                if (checkTileCollision(x, y, otherTile.x, otherTile.y, tileWidth, tileHeight)) {
                    return false; // Toqqu≈üma var!
                }
            }
            return true; // S…ôrb…ôstdir
        }

        // ‚úÖ ∆èn yaxƒ±n bo≈ü yeri tap
        function findNearestValidPosition(targetX, targetY, currentIdx, boardWidth) {
            const tileWidth = 55;
            const gap = 5;
            const ROW_1_Y = 10;
            const ROW_2_Y = 90;

            // Hansƒ± s…ôtird…ô?
            const snappedY = targetY < 50 ? ROW_1_Y : ROW_2_Y;

            // X eksenind…ô sola-saƒüa yoxla
            for (let offset = 0; offset < boardWidth; offset += (tileWidth + gap)) {
                // Saƒüa yoxla
                let testX = targetX + offset;
                if (testX + tileWidth <= boardWidth && isPositionValid(testX, snappedY, currentIdx)) {
                    return { x: testX, y: snappedY };
                }

                // Sola yoxla
                testX = targetX - offset;
                if (testX >= 0 && isPositionValid(testX, snappedY, currentIdx)) {
                    return { x: testX, y: snappedY };
                }
            }

            // Ba≈üqa s…ôtird…ô yoxla
            const alternateY = snappedY === ROW_1_Y ? ROW_2_Y : ROW_1_Y;
            for (let offset = 0; offset < boardWidth; offset += (tileWidth + gap)) {
                let testX = targetX + offset;
                if (testX + tileWidth <= boardWidth && isPositionValid(testX, alternateY, currentIdx)) {
                    return { x: testX, y: alternateY };
                }

                testX = targetX - offset;
                if (testX >= 0 && isPositionValid(testX, alternateY, currentIdx)) {
                    return { x: testX, y: alternateY };
                }
            }

            // He√ß yer tapƒ±lmadƒ±, orijinal yeri saxla
            return { x: myHand[currentIdx].x, y: myHand[currentIdx].y };
        }

        // ‚úÖ Bu yeni d…ôyi≈ü…ônl…ôri ∆èLAV∆è ET (scriptƒ±n …ôvv…ôlind…ô):
        let IFRAME_TOKEN = null;
        let IFRAME_USER = null;

        // ‚úÖ Bu yeni funksiyanƒ± ∆èLAV∆è ET (getToken yerin…ô):
        function waitForUserData() {
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('User data timeout'));
                }, 10000); // 10 saniy…ô g√∂zl…ô

                const checkData = () => {
                    if (IFRAME_TOKEN && IFRAME_USER) {
                        clearTimeout(timeout);
                        clearInterval(interval);
                        resolve();
                    }
                };

                const interval = setInterval(checkData, 100);
                checkData(); // ƒ∞lk yoxlama
            });
        }

        // ‚úÖ postMessage dinl…ôyicisini ∆èLAV∆è ET (DOMContentLoaded-d…ôn ∆èVV∆èL):
        window.addEventListener('message', (event) => {
            // üîí T…ôhl√ºk…ôsizlik: yalnƒ±z eyni origin-d…ôn q…ôbul et
            if (event.origin !== window.location.origin) {
                console.warn('‚ö†Ô∏è Rejected message from:', event.origin);
                return;
            }

            const { type, payload } = event.data;

            if (type === 'INIT_USER') {
                log('üì• React-dan user data alƒ±ndƒ±:', payload);

                IFRAME_TOKEN = payload.token;
                IFRAME_USER = {
                    id: payload.userId,
                    username: payload.username,
                    fullName: payload.fullName,
                    balance: payload.balance
                };

                // UI-ƒ± yenil…ô
                if (document.getElementById('userName')) {
                    document.getElementById('userName').textContent = payload.fullName;
                }
                if (document.getElementById('userBalance')) {
                    document.getElementById('userBalance').textContent = `üí∞ ${payload.balance}‚Çº`;
                }
                if (document.getElementById('myPlayerName')) {
                    document.getElementById('myPlayerName').textContent = payload.fullName;
                }

                log('‚úÖ User data saxlanƒ±ldƒ± v…ô UI yenil…ôndi');
            }
        });


        // -----
        const CONFIG = { HUB_URL: 'https://nehemiah-paginal-alan.ngrok-free.dev/okeyHub', DEBUG: true };
        let connection, currentUser, currentRoomId, myHand = [], myPosition = 0;
        let hasDrawn = false, isMyTurn = false, mustDiscard = false;
        let draggedTile = null, draggedFromIndex = null;

        function log(...args) { if (CONFIG.DEBUG) console.log('üéÆ', ...args); }

        function showNotification(msg, type = 'info') {
            const n = document.getElementById('notification');
            n.textContent = msg;
            n.className = `notification ${type} show`;
            setTimeout(() => n.classList.remove('show'), 3000);
        }

        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(id)?.classList.add('active');
        }

        // function getToken() {
        //     const raw = document.cookie.split("; ").find(r => r.startsWith("AuthToken="))?.split("=")[1];
        //     return raw ? decodeURIComponent(raw).trim() : "";
        // }

        // async function initializeSignalR() {
        //     const token = getToken();
        //     if (!token) {
        //         showNotification('Token tapƒ±lmadƒ±!', 'error');
        //         setTimeout(() => window.location.href = '/frontend/index.html', 3000);
        //         return;
        //     }

        //     try {
        //         connection = new signalR.HubConnectionBuilder()
        //             .withUrl(CONFIG.HUB_URL, {
        //                 accessTokenFactory: () => token,
        //                 transport: signalR.HttpTransportType.WebSockets | signalR.HttpTransportType.LongPolling
        //             })
        //             .withAutomaticReconnect()
        //             .configureLogging(signalR.LogLevel.Information)
        //             .build();

        //         setupSignalREvents();
        //         await connection.start();
        //         log('‚úÖ Connected');
        //         showNotification('Baƒülantƒ± uƒüurlu!', 'success');
        //         setTimeout(() => loadRooms(), 500);
        //     } catch (err) {
        //         log('‚ùå Error:', err);
        //         showNotification('Baƒülantƒ± x…ôtasƒ±', 'error');
        //     }
        // }
        async function initializeSignalR() {
            try {
                // React-dan data g√∂zl…ô
                log('‚è≥ React-dan user data g√∂zl…ônilir...');
                await waitForUserData();

                const token = IFRAME_TOKEN;

                if (!token) {
                    showNotification('Token tapƒ±lmadƒ±!', 'error');
                    return;
                }

                log('üîë Token alƒ±ndƒ±, SignalR baƒülanƒ±r...');

                connection = new signalR.HubConnectionBuilder()
                    .withUrl(CONFIG.HUB_URL, {
                        accessTokenFactory: () => token,
                        transport: signalR.HttpTransportType.WebSockets | signalR.HttpTransportType.LongPolling
                    })
                    .withAutomaticReconnect()
                    .configureLogging(signalR.LogLevel.Information)
                    .build();

                setupSignalREvents();
                await connection.start();
                log('‚úÖ Connected');
                showNotification('Baƒülantƒ± uƒüurlu!', 'success');
                setTimeout(() => loadRooms(), 500);
            } catch (err) {
                log('‚ùå Error:', err);
                showNotification('Baƒülantƒ± x…ôtasƒ±: ' + err.message, 'error');
            }
        }
        function setupSignalREvents() {
            // connection.on("UserData", (d) => {
            //     currentUser = d;
            //     document.getElementById('userName').textContent = d.fullName;
            //     document.getElementById('userBalance').textContent = `üí∞ ${d.balance}‚Çº`;
            //     document.getElementById('userRank').textContent = d.rank;
            //     document.getElementById('myPlayerName').textContent = d.fullName;
            // });
            connection.on("UserData", (d) => {
                // SignalR-dan g…ôl…ôn data il…ô yenil…ô (React data il…ô birl…ô≈üdir)
                currentUser = {
                    ...IFRAME_USER,
                    ...d
                };

                document.getElementById('userName').textContent = d.fullName || IFRAME_USER.fullName;
                document.getElementById('userBalance').textContent = `üí∞ ${d.balance}‚Çº`;
                document.getElementById('userRank').textContent = d.rank;
                document.getElementById('myPlayerName').textContent = d.fullName || IFRAME_USER.fullName;
            });
            connection.on("BalanceUpdated", (balance) => {
                document.getElementById('userBalance').textContent = `üí∞ ${balance}‚Çº`;
            });

            connection.on("RoomCreated", () => loadRooms());
            connection.on("RoomDeleted", () => loadRooms());

            connection.on("JoinedRoom", (d) => {
                currentRoomId = d.roomId;
                myPosition = d.position;
                document.getElementById('roomNameDisplay').textContent = d.roomName;
                if (d.hand && d.hand.length > 0) {
                    myHand = d.hand;
                    renderMyTiles();
                }
                showScreen('gameScreen');
                showNotification('Otaƒüa daxil oldunuz', 'success');
            });

            connection.on("JoinError", (msg) => showNotification(msg, 'error'));
            connection.on("PlayerJoined", (d) => showNotification(`${d.playerName} qo≈üuldu`, 'info'));
            connection.on("PlayerLeft", (d) => showNotification(`${d.playerName} √ßƒ±xdƒ±`, 'info'));
            connection.on("PlayersList", (players) => updatePlayersDisplay(players));

            connection.on("GameStarted", (d) => {
                log('GameStarted:', d);
                myHand = d.hand || [];

                if (myHand.length === 15) {
                    hasDrawn = true;
                    mustDiscard = true;
                    isMyTurn = true;
                    showNotification('Oyunu Sƒ∞Z ba≈ülayƒ±rsƒ±nƒ±z! DA≈û ATIN! üéÆ', 'success');
                } else {
                    hasDrawn = false;
                    mustDiscard = false;
                    isMyTurn = d.isYourTurn || false;
                }

                renderMyTiles();
                if (d.indicator) setIndicatorTile(d.indicator);
                if (d.joker) setJokerTile(d.joker);

                document.getElementById('gameModeDisplay').textContent = `Mod: ${d.gameMode}`;
                document.getElementById('myScore').textContent = d.initialScore;
                updateTurnUI();

                if (!mustDiscard) showNotification('Oyun ba≈üladƒ±! üéÆ', 'success');
            });

            connection.on("GameStateUpdated", (state) => {
                if (state.stockCount !== undefined)
                    document.getElementById('deckCountLabel').textContent = `üìö ${state.stockCount}`;
                if (state.potAmount !== undefined)
                    document.getElementById('potAmountDisplay').textContent = `Pot: ${state.potAmount}‚Çº`;
                if (state.players) updatePlayersDisplay(state.players);
            });

            connection.on("YourTurn", () => {
                isMyTurn = true;
                hasDrawn = false;
                mustDiscard = false;
                updateTurnUI();
                showNotification('Sizin n√∂vb…ônizdir! DA≈û √á∆èKƒ∞N!', 'info');
            });

            connection.on("TileDrawn", (d) => {
                myHand = d.hand;
                hasDrawn = true;
                mustDiscard = true;
                renderMyTiles();
                updateTurnUI();
                showNotification('Da≈ü √ß…ôkdiniz, indi DA≈û ATIN!', 'success');
            });

            connection.on("PlayerDrew", (d) => showNotification(`${d.playerName} da≈ü √ß…ôkdi`, 'info'));

            connection.on("TileDiscarded", (d) => {
                myHand = d.hand;
                hasDrawn = false;
                isMyTurn = false;
                mustDiscard = false;
                renderMyTiles();
                updateTurnUI();
            });

            connection.on("PlayerDiscardedTile", (d) => {
                if (d.tile && d.playerPosition !== undefined)
                    displayDiscardedTile(d.tile, d.playerPosition);
            });

            connection.on("ActionError", (msg) => showNotification(msg, 'error'));
            connection.on("RoundOver", (d) => showNotification(`üéâ ${d.winner} qazandƒ±!`, 'success'));
            connection.on("GameOver", (d) => {
                showNotification(`üèÜ Qalibi: ${d.finalWinner}`, 'success');
                setTimeout(() => { showScreen('roomListScreen'); loadRooms(); }, 5000);
            });

            connection.on("GameReset", () => {
                myHand = [];
                hasDrawn = false;
                mustDiscard = false;
                isMyTurn = false;
                renderMyTiles();
                clearAllDiscardZones();
                showNotification('Yeni raund...', 'info');
            });

            connection.on("WinDeclared", (d) => showNotification(d.message, d.isValid ? 'success' : 'error'));
            connection.on("RankUpdated", (d) => {
                document.getElementById('userRank').textContent = d.rank;
                showNotification(`üéñÔ∏è ${d.rank} - Lvl ${d.level}`, 'success');
            });

            connection.on("LeftRoom", () => {
                currentRoomId = null;
                myHand = [];
                showScreen('roomListScreen');
                loadRooms();
            });

            connection.on("LeaveError", (msg) => showNotification(msg, 'error'));
        }

        async function loadRooms() {
            try {
                const rooms = await connection.invoke("GetRoomList");
                const grid = document.getElementById('roomsGrid');
                if (!rooms || rooms.length === 0) {
                    grid.innerHTML = '<div style="text-align: center; padding: 50px; color: white;">Otaq tapƒ±lmadƒ±</div>';
                    return;
                }
                grid.innerHTML = rooms.map(r => `
                        <div class="room-card" onclick="joinRoom('${r.roomId}')">
                            <div class="room-name">${r.roomName}</div>
                            <div class="room-detail"><span>Yaradƒ±cƒ±:</span><span>${r.creatorName}</span></div>
                            <div class="room-detail"><span>Mod:</span><span>${r.gameMode === 'Okey51' ? '‚ö° 51' : 'üéØ 101'}</span></div>
                            <div class="room-detail"><span>Giri≈ü:</span><span>üí∞ ${r.entryFee}‚Çº</span></div>
                            <div class="room-detail"><span>Oyun√ßular:</span><span>üë• ${r.playerCount}/4</span></div>
                        </div>
                    `).join('');
            } catch (err) { log('‚ùå Load rooms error:', err); }
        }

        setInterval(() => {
            if (document.getElementById('roomListScreen').classList.contains('active') && connection) loadRooms();
        }, 3000);

        async function joinRoom(roomId) {
            try {
                showNotification('Qo≈üulma...', 'info');
                await connection.invoke("JoinRoom", roomId, null);
            } catch (err) {
                log('‚ùå Join error:', err);
                showNotification('Qo≈üulmaq alƒ±nmadƒ±', 'error');
            }
        }

        async function leaveRoom() {
            if (!confirm('√áƒ±xmaq ist…ôyirsiniz?')) return;
            try {
                await connection.invoke("LeaveRoom");
            } catch (err) {
                log('‚ùå Leave error:', err);
                showScreen('roomListScreen');
                loadRooms();
            }
        }

        async function drawFromStock() {
            if (!isMyTurn || hasDrawn || mustDiscard) {
                showNotification(mustDiscard ? 'DA≈û ATIN!' : 'N√∂vb…ônizi g√∂zl…ôyin', 'error');
                return;
            }
            try {
                await connection.invoke("DrawTile", "stock");
            } catch (err) { log('‚ùå Draw error:', err); }
        }

        async function tryDrawFromLeftPlayer() {
            if (!isMyTurn || hasDrawn || mustDiscard) {
                if (mustDiscard) showNotification('∆èvv…ôlc…ô da≈ü atƒ±n!', 'error');
                else if (hasDrawn) showNotification('Artƒ±q da≈ü √ß…ôkmisiniz!', 'error');
                else showNotification('N√∂vb…ôniz deyil!', 'error');
                return;
            }

            const zone = document.getElementById('discardZoneLeft');
            if (!zone || !zone.querySelector('.okey-tile')) {
                showNotification('Sol oyun√ßu h…ôl…ô da≈ü atmayƒ±b', 'error');
                return;
            }

            try {
                log('üé¥ Sol oyun√ßudan da≈ü g√∂t√ºr√ºr…ôm...');
                await connection.invoke("DrawTile", "discard");
                setTimeout(() => {
                    zone.innerHTML = 'üóëÔ∏è';
                    log('‚úÖ Sol oyun√ßunun da≈üƒ± silindi');
                }, 150);
            } catch (err) {
                log('‚ùå Draw from discard error:', err);
                showNotification('Da≈üƒ± g√∂t√ºrm…ôk m√ºmk√ºn olmadƒ±', 'error');
            }
        }

        async function discardTile(tileId) {
            if (!hasDrawn || !mustDiscard) {
                showNotification('∆èvv…ôlc…ô da≈ü √ß…ôkin!', 'error');
                return;
            }
            try {
                await connection.invoke("DiscardTile", tileId);
            } catch (err) { log('‚ùå Discard error:', err); }
        }

        async function declareWin() {
            try {
                await connection.invoke("DeclareWin");
            } catch (err) { log('‚ùå Win error:', err); }
        }

        function sortTiles() {
            const colorOrder = { red: 0, yellow: 1, blue: 2, black: 3, fakejoker: 4 };
            myHand.sort((a, b) => {
                const colorA = (a.color || '').toLowerCase();
                const colorB = (b.color || '').toLowerCase();
                const colorDiff = (colorOrder[colorA] || 0) - (colorOrder[colorB] || 0);
                return colorDiff !== 0 ? colorDiff : a.number - b.number;
            });

            autoArrangeTiles(); // Yenid…ôn d√ºz…ôlt
            renderMyTiles();
            showNotification('Sƒ±ralandƒ±', 'success');
        }

        // function sortTiles() {
        //     const colorOrder = { red: 0, yellow: 1, blue: 2, black: 3, fakejoker: 4 };
        //     myHand.sort((a, b) => {
        //         const colorA = (a.color || '').toLowerCase();
        //         const colorB = (b.color || '').toLowerCase();
        //         const colorDiff = (colorOrder[colorA] || 0) - (colorOrder[colorB] || 0);
        //         return colorDiff !== 0 ? colorDiff : a.number - b.number;
        //     });
        //     renderMyTiles();
        //     showNotification('Sƒ±ralandƒ±', 'success');
        // }




        function getRelativePosition(myPos, targetPos) {
            const diff = (targetPos - myPos + 4) % 4;
            if (diff === 0) return 'bottom';
            if (diff === 1) return 'right';
            if (diff === 2) return 'top';
            if (diff === 3) return 'left';
        }

        // function renderMyTiles() {
        //     const row1 = document.getElementById('myRow1');
        //     const row2 = document.getElementById('myRow2');
        //     if (!row1 || !row2) return;

        //     const mid = Math.ceil(myHand.length / 2);
        //     const firstRowTiles = myHand.slice(0, mid);
        //     const secondRowTiles = myHand.slice(mid);

        //     row1.innerHTML = firstRowTiles.map((tile, idx) => createTileHTML(tile, idx)).join('');
        //     row2.innerHTML = secondRowTiles.map((tile, idx) => createTileHTML(tile, mid + idx)).join('');

        //     setupTileDragDrop(row1, 1);
        //     setupTileDragDrop(row2, 2);
        //     setupMyDiscardZone();
        // }
        function renderMyTiles() {
            const board = document.getElementById('myBoard');
            if (!board) {
                console.error('‚ùå myBoard tapƒ±lmadƒ±!');
                return;
            }

            // ƒ∞lk d…ôf…ô pozisiya yoxdursa, avtomatik d√ºz…ôlt
            if (!myHand[0]?.x && myHand.length > 0) {
                autoArrangeTiles();
            }

            // Board-u t…ômizl…ô
            board.innerHTML = '';

            // H…ôr bir da≈üƒ± …ôlav…ô et
            myHand.forEach((tile, idx) => {
                const x = tile.x || (idx * 60);
                const y = tile.y || 10;

                const tileEl = document.createElement('div');
                tileEl.className = `okey-tile ${(tile.color || '').toLowerCase()}`;
                tileEl.dataset.idx = idx;
                tileEl.draggable = true;
                tileEl.style.left = x + 'px';
                tileEl.style.top = y + 'px';

                // ƒ∞√ß…ôrik
                if (tile.isFakeJoker || tile.isJoker) {
                    tileEl.innerHTML = '<div class="tile-joker-star">‚òÖ</div>';
                    tileEl.classList.add('joker');
                } else {
                    const color = (tile.color || '').toLowerCase();
                    const dotColor =
                        color === 'red' ? '#d32f2f' :
                            color === 'yellow' ? '#f9a825' :
                                color === 'blue' ? '#1976d2' : '#212121';

                    tileEl.innerHTML = `
                <div class="tile-number">${tile.number}</div>
                <div class="tile-color-dot" style="background: ${dotColor};"></div>
            `;
                }

                board.appendChild(tileEl);
            });

            // Drag & Drop qur
            setupFreeDragDrop();
            setupMyDiscardZone();
        }
        // ‚úÖ YENƒ∞: S…ôrb…ôst Drag & Drop


        // ‚úÖ YENƒ∞: Avtomatik d√ºz…ôlt (ilk d…ôf…ô)

        // function setupFreeDragDrop() {
        //     const board = document.getElementById('myBoard');
        //     if (!board) return;

        //     const tiles = board.querySelectorAll('.okey-tile');
        //     let activeTile = null;
        //     let activeIdx = null;
        //     let offsetX = 0, offsetY = 0;
        //     let isDragging = false;

        //     tiles.forEach((tileEl) => {
        //         const idx = parseInt(tileEl.dataset.idx);

        //         // ‚úÖ MOUSE DOWN - Drag ba≈ülat
        //         tileEl.addEventListener('mousedown', (e) => {
        //             e.preventDefault();

        //             activeTile = tileEl;
        //             activeIdx = idx;
        //             isDragging = true;

        //             const rect = tileEl.getBoundingClientRect();
        //             offsetX = e.clientX - rect.left;
        //             offsetY = e.clientY - rect.top;

        //             // Vizual feedback
        //             tileEl.style.cursor = 'grabbing';
        //             tileEl.style.zIndex = '1000';
        //             tileEl.style.opacity = '0.8';
        //             tileEl.style.transition = 'none'; // Animasiya s√∂nd√ºr
        //         });

        //         // Double-click il…ô at
        //         tileEl.addEventListener('dblclick', () => {
        //             if (mustDiscard && hasDrawn && isMyTurn) {
        //                 const tileId = myHand[idx].id;

        //                 if (myHand.length === 1) {
        //                     showNotification('Son da≈ü atƒ±ldƒ±!', 'success');
        //                     setTimeout(() => declareWin(), 300);
        //                 } else {
        //                     discardTile(tileId);
        //                 }
        //             }
        //         });
        //     });

        //     // ‚úÖ MOUSE MOVE - Real-time h…ôr…ôk…ôt
        //     board.addEventListener('mousemove', (e) => {
        //         if (!isDragging || !activeTile) return;

        //         const boardRect = board.getBoundingClientRect();
        //         let newX = e.clientX - boardRect.left - offsetX;
        //         let newY = e.clientY - boardRect.top - offsetY;

        //         // S…ôrh…ôdl…ôrd…ô saxla
        //         newX = Math.max(0, Math.min(newX, boardRect.width - 55));
        //         newY = Math.max(0, Math.min(newY, boardRect.height - 70));

        //         // ‚ö° D∆èRHAL YERƒ∞Nƒ∞ DEYƒ∞≈û
        //         activeTile.style.left = newX + 'px';
        //         activeTile.style.top = newY + 'px';

        //         // Array-d…ô d…ô saxla
        //         myHand[activeIdx].x = newX;
        //         myHand[activeIdx].y = newY;
        //     });

        //     // ‚úÖ MOUSE UP - Drag bitir
        //     board.addEventListener('mouseup', () => {
        //         if (isDragging && activeTile) {
        //             activeTile.style.cursor = 'grab';
        //             activeTile.style.zIndex = '1';
        //             activeTile.style.opacity = '1';
        //         }

        //         isDragging = false;
        //         activeTile = null;
        //         activeIdx = null;
        //     });

        //     // ‚úÖ MOUSE LEAVE - Board-dan √ßƒ±xsa burax
        //     board.addEventListener('mouseleave', () => {
        //         if (isDragging && activeTile) {
        //             activeTile.style.cursor = 'grab';
        //             activeTile.style.zIndex = '1';
        //             activeTile.style.opacity = '1';
        //         }

        //         isDragging = false;
        //         activeTile = null;
        //         activeIdx = null;
        //     });

        //     // ‚úÖ TOUCH EVENTS - Mobil √º√ß√ºn
        //     // Touch event-l…ôr (setupFreeDragDrop i√ßin…ô …ôlav…ô et)
        //     tiles.forEach((tileEl) => {
        //         const idx = parseInt(tileEl.dataset.idx);

        //         // TOUCH START
        //         tileEl.addEventListener('touchstart', (e) => {
        //             const touch = e.touches[0];

        //             activeTile = tileEl;
        //             activeIdx = idx;
        //             isDragging = true;

        //             const rect = tileEl.getBoundingClientRect();
        //             offsetX = touch.clientX - rect.left;
        //             offsetY = touch.clientY - rect.top;

        //             tileEl.style.zIndex = '1000';
        //             tileEl.style.opacity = '0.8';
        //         });
        //     });

        //     // TOUCH MOVE
        //     board.addEventListener('touchmove', (e) => {
        //         if (!isDragging || !activeTile) return;
        //         e.preventDefault();

        //         const touch = e.touches[0];
        //         const boardRect = board.getBoundingClientRect();

        //         let newX = touch.clientX - boardRect.left - offsetX;
        //         let newY = touch.clientY - boardRect.top - offsetY;

        //         newX = Math.max(0, Math.min(newX, boardRect.width - 55));
        //         newY = Math.max(0, Math.min(newY, boardRect.height - 70));

        //         activeTile.style.left = newX + 'px';
        //         activeTile.style.top = newY + 'px';

        //         myHand[activeIdx].x = newX;
        //         myHand[activeIdx].y = newY;
        //     });

        //     // TOUCH END
        //     board.addEventListener('touchend', () => {
        //         if (isDragging && activeTile) {
        //             activeTile.style.zIndex = '1';
        //             activeTile.style.opacity = '1';
        //         }

        //         isDragging = false;
        //         activeTile = null;
        //         activeIdx = null;
        //     });

        // }



        // function autoArrangeTiles() {
        //     const tileWidth = 55;
        //     const gap = 5;
        //     const startX = 10;
        //     const startY = 10;
        //     const maxPerRow = 8; // H…ôr s…ôtird…ô 8 da≈ü

        //     myHand.forEach((tile, idx) => {
        //         const row = Math.floor(idx / maxPerRow);
        //         const col = idx % maxPerRow;

        //         tile.x = startX + col * (tileWidth + gap);
        //         tile.y = startY + row * 80; // 80px h…ôr s…ôtir
        //     });
        // }

        // function createTileHTML(tile, globalIdx) {
        //     if (!tile) return '';
        //     let className = `okey-tile ${(tile.color || '').toLowerCase()}`;
        //     let content = '';

        //     if (tile.isFakeJoker || tile.isJoker) {
        //         content = '<div class="tile-joker-star">‚òÖ</div>';
        //         className += ' joker';
        //     } else {
        //         const color = (tile.color || '').toLowerCase();
        //         const dotColor =
        //             color === 'red' ? '#d32f2f' :
        //                 color === 'yellow' ? '#f9a825' :
        //                     color === 'blue' ? '#1976d2' : '#212121';

        //         content = `
        //                 <div class="tile-number">${tile.number}</div>
        //                 <div class="tile-color-dot" style="background: ${dotColor};"></div>
        //             `;
        //     }
        //     return `<div class="${className}" data-tile-id="${tile.id}" data-idx="${globalIdx}" draggable="true">${content}</div>`;
        // }

        // ‚úÖ YENƒ∞: Tile HTML (pozisiya il…ô)

        function setupFreeDragDrop() {
            const board = document.getElementById('myBoard');
            if (!board) return;

            const tiles = board.querySelectorAll('.okey-tile');
            let activeTile = null;
            let activeIdx = null;
            let offsetX = 0, offsetY = 0;
            let isDragging = false;

            // ‚úÖ YENI: 2 s…ôtir √º√ß√ºn sabitl…ôr
            const ROW_HEIGHT = 80; // H…ôr s…ôtirin h√ºnd√ºrl√ºy√º
            const ROW_1_Y = 10;    // Yuxarƒ± s…ôtir Y pozisiyasƒ±
            const ROW_2_Y = 90;    // A≈üaƒüƒ± s…ôtir Y pozisiyasƒ±
            const SNAP_THRESHOLD = ROW_HEIGHT / 2; // Orta n√∂qt…ô (40px)

            tiles.forEach((tileEl) => {
                const idx = parseInt(tileEl.dataset.idx);

                // MOUSE DOWN
                tileEl.addEventListener('mousedown', (e) => {
                    e.preventDefault();

                    activeTile = tileEl;
                    activeIdx = idx;
                    isDragging = true;

                    const rect = tileEl.getBoundingClientRect();
                    offsetX = e.clientX - rect.left;
                    offsetY = e.clientY - rect.top;

                    tileEl.style.cursor = 'grabbing';
                    tileEl.style.zIndex = '1000';
                    tileEl.style.opacity = '0.8';
                    tileEl.style.transition = 'none';
                });

                // DOUBLE-CLICK
                tileEl.addEventListener('dblclick', () => {
                    if (mustDiscard && hasDrawn && isMyTurn) {
                        const tileId = myHand[idx].id;

                        if (myHand.length === 1) {
                            showNotification('Son da≈ü atƒ±ldƒ±!', 'success');
                            setTimeout(() => declareWin(), 300);
                        } else {
                            discardTile(tileId);
                        }
                    }
                });

                // ‚úÖ TOUCH START (mobil)
                tileEl.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];

                    activeTile = tileEl;
                    activeIdx = idx;
                    isDragging = true;

                    const rect = tileEl.getBoundingClientRect();
                    offsetX = touch.clientX - rect.left;
                    offsetY = touch.clientY - rect.top;

                    tileEl.style.zIndex = '1000';
                    tileEl.style.opacity = '0.8';
                    tileEl.style.transition = 'none';
                });
            });

            // MOUSE MOVE
            // MOUSE MOVE
            board.addEventListener('mousemove', (e) => {
                if (!isDragging || !activeTile) return;

                const boardRect = board.getBoundingClientRect();
                let newX = e.clientX - boardRect.left - offsetX;
                let newY = e.clientY - boardRect.top - offsetY;

                // ‚úÖ Board s…ôrh…ôdl…ôrind…ô saxla
                const tileWidth = 55;
                const tileHeight = 70;
                newX = Math.max(0, Math.min(newX, boardRect.width - tileWidth));
                newY = Math.max(0, Math.min(newY, ROW_2_Y + tileHeight - 10));

                // ‚úÖ Real-time h…ôr…ôk…ôt (toqqu≈üma yoxlamasƒ± olmadan, vizual feedback √º√ß√ºn)
                activeTile.style.left = newX + 'px';
                activeTile.style.top = newY + 'px';

                // M√ºv…ôqq…ôti saxla (snap zamanƒ± yoxlanacaq)
                myHand[activeIdx].tempX = newX;
                myHand[activeIdx].tempY = newY;
            });

            // ‚úÖ MOUSE UP - SNAP TO ROW!
            // ‚úÖ MOUSE UP - SNAP + COLLISION CHECK!
            board.addEventListener('mouseup', () => {
                if (isDragging && activeTile && activeIdx !== null) {
                    const boardRect = board.getBoundingClientRect();
                    const currentX = myHand[activeIdx].tempX || myHand[activeIdx].x;
                    const currentY = myHand[activeIdx].tempY || myHand[activeIdx].y;

                    // Hansƒ± s…ôtr…ô snap?
                    const SNAP_THRESHOLD = 50;
                    const targetY = currentY < SNAP_THRESHOLD ? ROW_1_Y : ROW_2_Y;

                    // ‚úÖ Toqqu≈üma yoxla
                    let finalX = currentX;
                    let finalY = targetY;

                    if (!isPositionValid(finalX, finalY, activeIdx)) {
                        // ‚ö†Ô∏è Toqqu≈üma var! ∆èn yaxƒ±n bo≈ü yeri tap
                        const validPos = findNearestValidPosition(finalX, finalY, activeIdx, boardRect.width);
                        finalX = validPos.x;
                        finalY = validPos.y;

                        log('‚ö†Ô∏è Toqqu≈üma a≈ükarlandƒ±! Yeni pozisiya:', validPos);
                    }

                    // ‚úÖ Final pozisiyanƒ± saxla
                    myHand[activeIdx].x = finalX;
                    myHand[activeIdx].y = finalY;

                    // Animasiya il…ô yerl…ô≈üdir
                    activeTile.style.transition = 'left 0.2s ease-out, top 0.2s ease-out';
                    activeTile.style.left = finalX + 'px';
                    activeTile.style.top = finalY + 'px';

                    // Vizual geri qaytar
                    setTimeout(() => {
                        activeTile.style.cursor = 'grab';
                        activeTile.style.zIndex = '1';
                        activeTile.style.opacity = '1';
                        activeTile.style.transition = 'none';
                    }, 200);
                }

                isDragging = false;
                activeTile = null;
                activeIdx = null;
            });

            // MOUSE LEAVE
            board.addEventListener('mouseleave', () => {
                if (isDragging && activeTile && activeIdx !== null) {
                    const currentY = myHand[activeIdx].y;

                    // Snap to row
                    let snappedY = currentY < SNAP_THRESHOLD ? ROW_1_Y : ROW_2_Y;
                    myHand[activeIdx].y = snappedY;
                    activeTile.style.top = snappedY + 'px';

                    activeTile.style.cursor = 'grab';
                    activeTile.style.zIndex = '1';
                    activeTile.style.opacity = '1';
                }

                isDragging = false;
                activeTile = null;
                activeIdx = null;
            });

            // ‚úÖ TOUCH MOVE (mobil)
            // ‚úÖ TOUCH MOVE (mobil)
            board.addEventListener('touchmove', (e) => {
                if (!isDragging || !activeTile) return;
                e.preventDefault();

                const touch = e.touches[0];
                const boardRect = board.getBoundingClientRect();

                let newX = touch.clientX - boardRect.left - offsetX;
                let newY = touch.clientY - boardRect.top - offsetY;

                // ‚úÖ Board s…ôrh…ôdl…ôrind…ô saxla
                const tileWidth = 55;
                const tileHeight = 70;
                newX = Math.max(0, Math.min(newX, boardRect.width - tileWidth));
                newY = Math.max(0, Math.min(newY, ROW_2_Y + tileHeight - 10));

                activeTile.style.left = newX + 'px';
                activeTile.style.top = newY + 'px';

                myHand[activeIdx].tempX = newX;
                myHand[activeIdx].tempY = newY;
            });

            // ‚úÖ TOUCH END - SNAP!
            // ‚úÖ TOUCH END - SNAP + COLLISION CHECK!
            board.addEventListener('touchend', () => {
                if (isDragging && activeTile && activeIdx !== null) {
                    const boardRect = board.getBoundingClientRect();
                    const currentX = myHand[activeIdx].tempX || myHand[activeIdx].x;
                    const currentY = myHand[activeIdx].tempY || myHand[activeIdx].y;

                    const SNAP_THRESHOLD = 50;
                    const targetY = currentY < SNAP_THRESHOLD ? ROW_1_Y : ROW_2_Y;

                    let finalX = currentX;
                    let finalY = targetY;

                    if (!isPositionValid(finalX, finalY, activeIdx)) {
                        const validPos = findNearestValidPosition(finalX, finalY, activeIdx, boardRect.width);
                        finalX = validPos.x;
                        finalY = validPos.y;
                    }

                    myHand[activeIdx].x = finalX;
                    myHand[activeIdx].y = finalY;

                    activeTile.style.transition = 'left 0.2s ease-out, top 0.2s ease-out';
                    activeTile.style.left = finalX + 'px';
                    activeTile.style.top = finalY + 'px';

                    setTimeout(() => {
                        activeTile.style.zIndex = '1';
                        activeTile.style.opacity = '1';
                        activeTile.style.transition = 'none';
                    }, 200);
                }

                isDragging = false;
                activeTile = null;
                activeIdx = null;
            });
        }


        function autoArrangeTiles() {
            const tileWidth = 55;
            const gap = 5;
            const startX = 10;
            const maxPerRow = 8; // H…ôr s…ôtird…ô max 8 da≈ü

            // ‚úÖ 2 s…ôtir √º√ß√ºn Y pozisiyalarƒ±
            const ROW_1_Y = 10;
            const ROW_2_Y = 90;

            myHand.forEach((tile, idx) => {
                const row = Math.floor(idx / maxPerRow);
                const col = idx % maxPerRow;

                tile.x = startX + col * (tileWidth + gap);

                // ‚úÖ Ya 1-ci s…ôtir, ya 2-ci s…ôtir
                tile.y = row === 0 ? ROW_1_Y : ROW_2_Y;
            });
        }

        function createTileHTML(tile, idx, x, y) {
            if (!tile) return '';

            let className = `okey-tile ${(tile.color || '').toLowerCase()}`;
            let content = '';

            if (tile.isFakeJoker || tile.isJoker) {
                content = '<div class="tile-joker-star">‚òÖ</div>';
                className += ' joker';
            } else {
                const color = (tile.color || '').toLowerCase();
                const dotColor =
                    color === 'red' ? '#d32f2f' :
                        color === 'yellow' ? '#f9a825' :
                            color === 'blue' ? '#1976d2' : '#212121';

                content = `
            <div class="tile-number">${tile.number}</div>
            <div class="tile-color-dot" style="background: ${dotColor};"></div>
        `;
            }

            return `
        <div class="${className}" 
             data-idx="${idx}" 
             draggable="true"
             style="left: ${x}px; top: ${y}px;">
            ${content}
        </div>
    `;
        }

        // function setupTileDragDrop(rowEl, rowNum) {
        //     rowEl.addEventListener('dragover', (e) => {
        //         e.preventDefault();
        //         e.stopPropagation();
        //         rowEl.classList.add('drag-over');
        //     });

        //     rowEl.addEventListener('dragleave', (e) => {
        //         const rect = rowEl.getBoundingClientRect();
        //         if (e.clientX < rect.left || e.clientX > rect.right ||
        //             e.clientY < rect.top || e.clientY > rect.bottom) {
        //             rowEl.classList.remove('drag-over');
        //         }
        //     });

        //     rowEl.addEventListener('drop', (e) => {
        //         e.preventDefault();
        //         e.stopPropagation();
        //         rowEl.classList.remove('drag-over');

        //         if (draggedFromIndex !== null) {
        //             const mid = Math.ceil(myHand.length / 2);

        //             const tiles = Array.from(rowEl.querySelectorAll('.okey-tile'));
        //             let targetIdx = tiles.length;

        //             for (let i = 0; i < tiles.length; i++) {
        //                 const rect = tiles[i].getBoundingClientRect();
        //                 if (e.clientX < rect.left + rect.width / 2) {
        //                     targetIdx = i;
        //                     break;
        //                 }
        //             }

        //             const actualTarget = rowNum === 1 ? targetIdx : mid + targetIdx;

        //             if (draggedFromIndex !== actualTarget) {
        //                 const tile = myHand.splice(draggedFromIndex, 1)[0];
        //                 const insertIdx = draggedFromIndex < actualTarget ? actualTarget - 1 : actualTarget;
        //                 myHand.splice(insertIdx, 0, tile);
        //                 renderMyTiles();
        //             }
        //         }
        //         draggedTile = null;
        //         draggedFromIndex = null;
        //     });

        //     rowEl.querySelectorAll('.okey-tile').forEach((el) => {
        //         const globalIndex = parseInt(el.dataset.idx);

        //         el.addEventListener('dragstart', (e) => {
        //             draggedTile = myHand[globalIndex];
        //             draggedFromIndex = globalIndex;
        //             el.classList.add('dragging');
        //             e.dataTransfer.effectAllowed = 'move';
        //         });

        //         el.addEventListener('dragend', () => el.classList.remove('dragging'));

        //         el.addEventListener('dragover', (e) => {
        //             e.preventDefault();
        //             e.stopPropagation();
        //         });

        //         el.addEventListener('drop', (e) => {
        //             e.preventDefault();
        //             e.stopPropagation();

        //             if (draggedFromIndex !== null && draggedFromIndex !== globalIndex) {
        //                 const tile = myHand.splice(draggedFromIndex, 1)[0];
        //                 const insertIndex = draggedFromIndex < globalIndex ? globalIndex : globalIndex;
        //                 myHand.splice(insertIndex, 0, tile);
        //                 renderMyTiles();
        //             }
        //             draggedTile = null;
        //             draggedFromIndex = null;
        //         });

        //         el.addEventListener('dblclick', () => {
        //             if (mustDiscard && hasDrawn && isMyTurn) {
        //                 const tileId = myHand[globalIndex].id;

        //                 // ‚úÖ ∆èg…ôr son da≈ü qalƒ±rsa, avtomatik oyunu bitir
        //                 if (myHand.length === 1) {
        //                     log('üèÜ Son da≈ü ikiqat klik - oyun bitir!');
        //                     showNotification('Son da≈ü atƒ±ldƒ±! Yoxlanƒ±lƒ±r...', 'success');
        //                     setTimeout(() => declareWin(), 300);
        //                 } else {
        //                     discardTile(tileId);
        //                 }
        //             }
        //         });
        //     });
        // }

        function setupMyDiscardZone() {
            const zone = document.getElementById('myDiscardZone');
            if (!zone) return;

            const newZone = zone.cloneNode(true);
            zone.parentNode.replaceChild(newZone, zone);
            const freshZone = document.getElementById('myDiscardZone');

            freshZone.addEventListener('dragenter', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (hasDrawn && mustDiscard && isMyTurn && draggedTile) {
                    freshZone.classList.add('can-drop');
                }
            });

            freshZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (hasDrawn && mustDiscard && isMyTurn && draggedTile) {
                    freshZone.classList.add('can-drop');
                    e.dataTransfer.dropEffect = 'move';
                }
            });

            freshZone.addEventListener('dragleave', (e) => {
                const rect = freshZone.getBoundingClientRect();
                if (e.clientX < rect.left || e.clientX > rect.right ||
                    e.clientY < rect.top || e.clientY > rect.bottom) {
                    freshZone.classList.remove('can-drop');
                }
            });

            freshZone.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                freshZone.classList.remove('can-drop');

                if (hasDrawn && mustDiscard && isMyTurn && draggedTile) {
                    const tileId = draggedTile.id;
                    draggedTile = null;
                    draggedFromIndex = null;

                    // ‚úÖ ∆èg…ôr son da≈ü qalƒ±rsa, avtomatik oyunu bitir
                    if (myHand.length === 1) {
                        log('üèÜ Son da≈ü atƒ±lƒ±r - oyun bitir!');
                        showNotification('Son da≈ü atƒ±ldƒ±! Yoxlanƒ±lƒ±r...', 'success');
                        setTimeout(() => declareWin(), 300);
                    } else {
                        discardTile(tileId);
                    }
                }
            });
        }

        function displayDiscardedTile(tile, playerPosition) {
            const relativePos = getRelativePosition(myPosition, playerPosition);
            let zoneId = '';

            if (relativePos === 'bottom') zoneId = 'myDiscardZone';
            else if (relativePos === 'top') zoneId = 'discardZoneTop';
            else if (relativePos === 'left') zoneId = 'discardZoneLeft';
            else if (relativePos === 'right') zoneId = 'discardZoneRight';

            const zone = document.getElementById(zoneId);
            if (zone && tile) zone.innerHTML = createTileHTML(tile, 0);
        }

        function clearAllDiscardZones() {
            ['myDiscardZone', 'discardZoneTop', 'discardZoneLeft', 'discardZoneRight'].forEach(id => {
                const zone = document.getElementById(id);
                if (zone) {
                    zone.innerHTML = id === 'myDiscardZone'
                        ? 'üóëÔ∏è<div class="discard-label">BURAYA<br>AT</div>'
                        : 'üóëÔ∏è';
                }
            });
        }

        function updatePlayersDisplay(players) {
            players.forEach((player) => {
                const relativePos = getRelativePosition(myPosition, player.position);
                let infoId = '';

                if (relativePos === 'bottom') infoId = 'myPlayerInfo';
                else if (relativePos === 'top') infoId = 'playerInfoTop';
                else if (relativePos === 'left') infoId = 'playerInfoLeft';
                else if (relativePos === 'right') infoId = 'playerInfoRight';

                const infoEl = document.getElementById(infoId);
                if (!infoEl) return;

                const nameEl = infoEl.querySelector('.player-name');
                const scoreEl = infoEl.querySelector('.player-score');

                if (nameEl) nameEl.textContent = player.name;
                if (scoreEl) scoreEl.textContent = player.score;

                if (player.isActive) infoEl.classList.add('active');
                else infoEl.classList.remove('active');
            });
        }

        function setIndicatorTile(tile) {
            const el = document.getElementById('indicatorTile');
            if (el && tile) el.innerHTML = createTileHTML(tile, 0);
        }

        function setJokerTile(tile) {
            const el = document.getElementById('jokerTile');
            if (el && tile) el.innerHTML = createTileHTML(tile, 0);
        }

        function updateTurnUI() {
            const deckStack = document.getElementById('deckStack');
            const declareBtn = document.getElementById('declareWinBtn');

            if (isMyTurn && !hasDrawn && !mustDiscard) {
                deckStack?.classList.remove('disabled');
                if (declareBtn) declareBtn.disabled = true;
            } else if (hasDrawn && mustDiscard) {
                deckStack?.classList.add('disabled');
                // ‚úÖ "Bitir" d√ºym…ôsi h…ômi≈ü…ô aktiv - kombinasiya yoxlamaq √º√ß√ºn
                if (declareBtn) declareBtn.disabled = false;
            } else {
                deckStack?.classList.add('disabled');
                // ‚úÖ Oyun bit…ônd…ôn sonra da aktiv qalsƒ±n
                if (declareBtn) declareBtn.disabled = false;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            log('üéÆ Okey Premium Loaded');
            document.getElementById('leaveRoomBtn')?.addEventListener('click', leaveRoom);
            document.getElementById('sortBtn')?.addEventListener('click', sortTiles);
            document.getElementById('deckStack')?.addEventListener('click', drawFromStock);
            document.getElementById('declareWinBtn')?.addEventListener('click', declareWin);
            initializeSignalR();
        });
        console.log(document.getElementById('myBoard')); // null deyils…ô OK
        console.log(myHand); // da≈ülar varmƒ±?
        window.joinRoom = joinRoom;
        window.tryDrawFromLeftPlayer = tryDrawFromLeftPlayer;
    </script>
</body>

</html>